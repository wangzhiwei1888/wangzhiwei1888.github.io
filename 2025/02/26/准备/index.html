<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="h5架构升级统一组件库：vant-uihttps:&#x2F;&#x2F;vant-ui.github.io&#x2F;vant&#x2F;#&#x2F;zh-CN&#x2F;home 业务组件输出：JSbridge:1234567891011121314151617181920212223242526URL Schemawindow.location.href &#x3D; &quot;myapp:&#x2F;&#x2F;action?param&#x3D;value&quot;;注入 JS">
<meta property="og:type" content="article">
<meta property="og:title" content="准备">
<meta property="og:url" content="http://example.com/2025/02/26/%E5%87%86%E5%A4%87/index.html">
<meta property="og:site_name" content="WBlog">
<meta property="og:description" content="h5架构升级统一组件库：vant-uihttps:&#x2F;&#x2F;vant-ui.github.io&#x2F;vant&#x2F;#&#x2F;zh-CN&#x2F;home 业务组件输出：JSbridge:1234567891011121314151617181920212223242526URL Schemawindow.location.href &#x3D; &quot;myapp:&#x2F;&#x2F;action?param&#x3D;value&quot;;注入 JS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/f_01.png">
<meta property="article:published_time" content="2025-02-26T05:08:00.000Z">
<meta property="article:modified_time" content="2025-03-18T03:10:52.054Z">
<meta property="article:author" content="wangzhiwei">
<meta property="article:tag" content="准备">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/f_01.png">

<link rel="canonical" href="http://example.com/2025/02/26/%E5%87%86%E5%A4%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>准备 | WBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">wangzhiwei blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/26/%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          准备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-26 13:08:00" itemprop="dateCreated datePublished" datetime="2025-02-26T13:08:00+08:00">2025-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%87%86%E5%A4%87/" itemprop="url" rel="index"><span itemprop="name">准备</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="h5架构升级"><a href="#h5架构升级" class="headerlink" title="h5架构升级"></a>h5架构升级</h2><h2 id="统一组件库："><a href="#统一组件库：" class="headerlink" title="统一组件库："></a>统一组件库：</h2><p>vant-ui<br><a target="_blank" rel="noopener" href="https://vant-ui.github.io/vant/#/zh-CN/home">https://vant-ui.github.io/vant/#/zh-CN/home</a></p>
<h3 id="业务组件输出："><a href="#业务组件输出：" class="headerlink" title="业务组件输出："></a>业务组件输出：</h3><h2 id="JSbridge"><a href="#JSbridge" class="headerlink" title="JSbridge:"></a>JSbridge:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">URL Schema</span><br><span class="line">window.location.href = &quot;myapp://action?param=value&quot;;</span><br><span class="line"></span><br><span class="line">注入 JS API</span><br><span class="line">原生应用将自身功能注入到 JavaScript 上下文中，Web 页面可以直接调用这些方法。</span><br><span class="line"></span><br><span class="line">Android 示例</span><br><span class="line"></span><br><span class="line">webView.addJavascriptInterface(new NativeBridge(this), &quot;NativeBridge&quot;);</span><br><span class="line"></span><br><span class="line">iOS 示例</span><br><span class="line"></span><br><span class="line">webView.configuration.userContentController.addScriptMessageHandler(self, name: &quot;callbackHandler&quot;);</span><br><span class="line"></span><br><span class="line">window.JsBridge.receiveDataFromApp(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回调机制</span><br><span class="line">window.WebViewJavascriptBridge.send(data, function(responseData) &#123;</span><br><span class="line">    // 处理原生回传的数据</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h2><p>性能优化：<br>资源加载优化：将资源按场景划分，仅加载当前场景所需资源，减少首次加载时间。<br>文件压缩与合并：<br>静态资源缓存：本地缓存，减少网络请求次数，提高性能。<br>CDN加速：使用CDN加速静态资源的加载，提高访问速度。<br>图片格式选择：选择合适的图片格式，如WebP、AVIF等，减少文件大小。<br>渲染优化：</p>
<p>接口数据缓存，优先读取缓存数据，</p>
<p>gzip</p>
<p>高频事件（如 scroll、touchmove）应该进行优化，使用函数防抖和函数节流等技术来限制它们的执行频率。<br>CSS3 动画比 setTimeout 更加高效，应尽可能地使用 requestAnimationFrame 动画。<br>DOM 结点过多会降低页面的渲染性能，因此应尽量减少 DOM 结点的数量。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weichen913/p/18173518">https://www.cnblogs.com/weichen913/p/18173518</a></p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>charles 、lightproxy</p>
<p>devtools-remote-debugger</p>
<p><img src="/../images/f_01.png"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">跨域的几种方式</span><br><span class="line">    jsonp cors 代理</span><br><span class="line"></span><br><span class="line">webpack原理</span><br><span class="line"></span><br><span class="line">Webpack 的核心思想是一切皆模块。无论是 JavaScript 文件、CSS 文件、图片资源，还是其他静态资源，都可以被当作模块来处理。Webpack 通过模块解析器（loader）和插件（plugin）来处理这些模块。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Webpack 的打包流程可以总结为以下步骤：</span><br><span class="line">读取配置文件：</span><br><span class="line">Webpack 读取 webpack.config.js 或 webpack.config.ts 文件，获取入口文件、输出路径、loader 和 plugin 等配置信息。</span><br><span class="line">解析模块依赖：</span><br><span class="line">从入口文件开始，递归解析模块依赖，构建模块依赖图。</span><br><span class="line">应用 Loader：</span><br><span class="line">根据配置，对模块应用相应的 loader 进行转换。</span><br><span class="line">应用 Plugin：</span><br><span class="line">在打包的各个生命周期阶段，执行 plugin 的逻辑。</span><br><span class="line">生成输出文件：</span><br><span class="line">根据模块依赖图，将所有模块打包成一个或多个输出文件（bundle）。</span><br><span class="line">将输出文件写入到配置的输出路径。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vite 原理</span><br><span class="line"></span><br><span class="line">其主要利用浏览器ESM特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。</span><br><span class="line"></span><br><span class="line">https://juejin.cn/post/7064853960636989454</span><br><span class="line"></span><br><span class="line">v-if 和 v-for能不能一起使用</span><br><span class="line"></span><br><span class="line">可以 不建议一起使用</span><br><span class="line"></span><br><span class="line">v-if 和 v-for 的优先级：v-for 的优先级高于 v-if，这意味着 v-if 的条件判断是在每次循环迭代中独立执行的。</span><br><span class="line"></span><br><span class="line">&lt;div v-for=&quot;item in filteredItems&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &#123;&#123; item.name &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  filteredItems() &#123;</span><br><span class="line">    return this.items.filter(item =&gt; item.isVisible);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data 为什么要用函数返回</span><br><span class="line"></span><br><span class="line">    确保每个组件实例有独立的数据作用域</span><br><span class="line">    防止数据在不同实例之间共享和污染</span><br><span class="line">    提高组件的可复用性和安全性</span><br><span class="line"></span><br><span class="line">nextticket</span><br><span class="line"></span><br><span class="line">    Vue 的响应式系统是异步更新 DOM 的。当数据发生变化时，Vue 不会立即更新 DOM，而是将更新任务放入一个队列中，在下一个事件循环中统一处理。这种机制可以优化性能，但有时会导致开发者在数据更新后立即操作 DOM 时，无法获取到更新后的 DOM。</span><br><span class="line">    nextTick 的作用是将回调函数延迟到 DOM 更新完成后再执行，从而确保开发者可以在回调中获取到最新的 DOM。</span><br><span class="line"></span><br><span class="line">箭头函数和普通函数的区别</span><br><span class="line">https://www.php.cn/faq/607823.html</span><br><span class="line"></span><br><span class="line">    1、</span><br><span class="line">    普通函数的 this 是动态的，取决于调用方式。</span><br><span class="line">    箭头函数的 this 是静态的，取决于定义时的上下文。</span><br><span class="line">    2、</span><br><span class="line">    普通函数会绑定 arguments 对象，它是一个类似数组的对象，包含函数调用时传递的所有参数。</span><br><span class="line">    箭头函数不绑定 arguments 对象，但可以通过参数数组解构来替代。</span><br><span class="line">    3、普通函数可以通过 new 关键字被实例化为对象，而箭头函数不能被用作构造函数。</span><br><span class="line">    4、普通函数可以使用 super 关键字来调用父类的方法，而箭头函数不能使用 super。</span><br><span class="line">    5、普通函数可以使用 yield 关键字来实现生成器函数，而箭头函数不能使用 yield。</span><br><span class="line"></span><br><span class="line">    const aaa = (...args) =&gt; &#123;</span><br><span class="line">      console.log(args)</span><br><span class="line">    &#125;</span><br><span class="line">    aaa(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line"></span><br><span class="line">mix混入的优缺点</span><br><span class="line"></span><br><span class="line">    优点：代码复用、解耦和模块化、易于维护。</span><br><span class="line">    缺点：可能导致命名冲突、代码可读性降低、维护成本增加。</span><br><span class="line">    替代方案：</span><br><span class="line">        1、Vue 3 的 Composition API</span><br><span class="line">        2、插件</span><br><span class="line">        3、高阶组件（HOC）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise几种状态 原理 </span><br><span class="line"></span><br><span class="line">    Promise 有三种主要状态（State）</span><br><span class="line">    Pending（进行中）：</span><br><span class="line">    Fulfilled（已成功）：</span><br><span class="line">    Rejected（已失败）：</span><br><span class="line"></span><br><span class="line">    Promise 的工作原理基于 事件循环和微任务队列 ，确保异步操作的结果可以被高效地处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vue的组件的生命周期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 阶段         | Vue 2 钩子                    | Vue 3 钩子                    | Composition API 钩子         |</span><br><span class="line">|--------------|-------------------------------|-------------------------------|------------------------------|</span><br><span class="line">| 创建         | beforeCreate&lt;br&gt;created       | beforeCreate&lt;br&gt;created       | setup                        |</span><br><span class="line">| 挂载         | beforeMount&lt;br&gt;mounted        | beforeMount&lt;br&gt;mounted        | onBeforeMount&lt;br&gt;onMounted   |</span><br><span class="line">| 更新         | beforeUpdate&lt;br&gt;updated       | beforeUpdate&lt;br&gt;updated       | onBeforeUpdate&lt;br&gt;onUpdated  |</span><br><span class="line">| 销毁         | beforeDestroy&lt;br&gt;destroyed    | beforeUnmount&lt;br&gt;unmounted    | onBeforeUnmount&lt;br&gt;onUnmounted |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ajax在那个生命周期调用 create</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">history 和hash 是如何实现的</span><br><span class="line"></span><br><span class="line">    https://baijiahao.baidu.com/s?id=1769914711262583821&amp;wfr=spider&amp;for=pc</span><br><span class="line">    window.addEventListener(&quot;hashchange&quot;,funcRef,false)</span><br><span class="line">    利用HTML5 History Interface 中新增的pushState()和replaceState()</span><br><span class="line"></span><br><span class="line">    window.addEventListener(&#x27;popstate&#x27;, function(event) &#123;</span><br><span class="line">        console.log(&#x27;URL changed:&#x27;, window.location.pathname);</span><br><span class="line">        // 在这里处理路由变化</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">vue几种通信方式</span><br><span class="line"></span><br><span class="line">1、props $emit触发事件</span><br><span class="line">2、vuex / pinia</span><br><span class="line">3、Provide / Injec</span><br><span class="line">4、$refs defineExpose(&#123; save, getConfig, getTempAttrsList &#125;)</span><br><span class="line">5、Event Bus: 创建一个事件中心，通过它来发送和监听事件，解耦了组件之间的通信。</span><br><span class="line"></span><br><span class="line">// event-bus.js</span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">export const EventBus = new Vue();</span><br><span class="line"></span><br><span class="line">const handler = (data) =&gt; &#123;</span><br><span class="line">  console.log(data.message);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventBus.$on(&#x27;update&#x27;, handler);</span><br><span class="line">EventBus.$off(&#x27;update&#x27;, handler); // 移除监听器</span><br><span class="line"></span><br><span class="line">EventBus.$emit(&#x27;update&#x27;, &#123; message: &#x27;Hello, World!&#x27; &#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事件循环的主要工作是协调调用栈、微任务队列和宏任务队列之间的任务执行。其工作流程：</span><br><span class="line"></span><br><span class="line">执行主线程代码：</span><br><span class="line">    JavaScript 代码从上到下执行，函数调用会被压入调用栈。</span><br><span class="line">    当调用栈为空时，表示主线程代码执行完毕。</span><br><span class="line">处理微任务队列：</span><br><span class="line">    在每次主线程代码执行完毕后，事件循环会检查微任务队列。</span><br><span class="line">    如果微任务队列中有任务，事件循环会依次执行这些任务，直到微任务队列为空。</span><br><span class="line">处理宏任务队列：</span><br><span class="line">    在微任务队列执行完毕后，事件循环会检查宏任务队列。</span><br><span class="line">    如果宏任务队列中有任务，事件循环会取出一个任务并执行。</span><br><span class="line">重复上述过程：</span><br><span class="line">    事件循环会不断重复上述过程，直到所有任务队列都为空。</span><br><span class="line"></span><br><span class="line">常见的微任务包括：Promise、MutationObserver、process.nextTick（Node.js）。</span><br><span class="line">常见的宏任务包括：setTimeout、setInterval、I/O 操作、MessageChannel。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const observer = new MutationObserver((mutationsList, observer) =&gt; &#123;</span><br><span class="line">  for (const mutation of mutationsList) &#123;</span><br><span class="line">    if (mutation.type === &#x27;childList&#x27;) &#123;</span><br><span class="line">      console.log(&#x27;Child list modified:&#x27;, mutation);</span><br><span class="line">    &#125; else if (mutation.type === &#x27;attributes&#x27;) &#123;</span><br><span class="line">      console.log(&#x27;Attribute changed:&#x27;, mutation.attributeName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 进行观察的配置</span><br><span class="line">const config = &#123;</span><br><span class="line">  childList: true,          // 监听目标节点的直接子节点变化</span><br><span class="line">  subtree: true,            // 监听目标节点及其所有后代节点的变化</span><br><span class="line">  attributes: true,         // 监听目标节点的属性变化</span><br><span class="line">  attributeFilter: [&#x27;class&#x27;], // 仅监听指定的属性</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 开始监听目标节点</span><br><span class="line">const targetNode = document.getElementById(&#x27;my-element&#x27;);</span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">observer.disconnect(); // 停止监听</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MutationObserver 在不同场景下的应用，包括动态内容加载、属性变化监控、图片懒加载、实时数据更新等</p>
<p>在 Vue 中，可以通过 @vueuse&#x2F;core 提供的 useMutationObserver 来监视 DOM 变动。<br>在表单验证场景中，可以监听表单字段的状态或错误消息的变化。</p>
<h2 id="Promise-如何解决-ajax-的-嵌套噩梦"><a href="#Promise-如何解决-ajax-的-嵌套噩梦" class="headerlink" title="Promise 如何解决 ajax 的 嵌套噩梦"></a>Promise 如何解决 ajax 的 嵌套噩梦</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function fetchData() &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &quot;/api/data&quot;,</span><br><span class="line">      success: function(data) &#123;</span><br><span class="line">        resolve(data); // 成功时调用 resolve</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function(err) &#123;</span><br><span class="line">        reject(err); // 失败时调用 reject</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processData(data) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &quot;/api/process&quot;,</span><br><span class="line">      data: &#123; input: data &#125;,</span><br><span class="line">      success: function(result) &#123;</span><br><span class="line">        resolve(result); // 成功时调用 resolve</span><br><span class="line">      &#125;,</span><br><span class="line">      error: function(err) &#123;</span><br><span class="line">        reject(err); // 失败时调用 reject</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过将异步操作封装为 Promise，可以使用链式调用来处理多个异步操作，避免嵌套回调：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fetchData()</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    console.log(&quot;Fetched data:&quot;, data);</span><br><span class="line">    return processData(data); // 返回下一个 Promise</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(result =&gt; &#123;</span><br><span class="line">    console.log(&quot;Processed result:&quot;, result);</span><br><span class="line">    return displayResult(result); // 可以继续链式调用</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.error(&quot;Error:&quot;, err); // 统一处理错误</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在可以使用 async/await 进一步简化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Vue-3-的-Composition-API-如何替代-mixin"><a href="#Vue-3-的-Composition-API-如何替代-mixin" class="headerlink" title="Vue 3 的 Composition API 如何替代 mixin"></a>Vue 3 的 Composition API 如何替代 mixin</h2><ol>
<li>使用自定义组合函数（Composables）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Composition API 的核心思想是通过自定义组合函数（Composables）来封装和复用逻辑。这些函数通常以 use 开头，类似于 React 中的 Hooks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：封装计数器逻辑</span><br><span class="line"></span><br><span class="line">// useCounter.js</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export function useCounter() &#123;</span><br><span class="line">  const count = ref(0);</span><br><span class="line">  const increment = () =&gt; count.value++;</span><br><span class="line">  return &#123; count, increment &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// MyComponent.vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useCounter &#125; from &#x27;./useCounter&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; count, increment &#125; = useCounter();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">这种方式避免了 Mixin 中常见的命名冲突问题，并且逻辑更加清晰</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>全局逻辑复用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// globalComposables.js</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export function useGlobalLogic() &#123;</span><br><span class="line">  const globalData = ref(&#x27;Global data&#x27;);</span><br><span class="line">  return &#123; globalData &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useGlobalLogic &#125; from &#x27;./globalComposables&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; globalData &#125; = useGlobalLogic();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、状态管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">对于更复杂的状态管理，可以使用 Vuex 或 Pinia 等状态管理库。这些库与 Composition API 配合得很好，提供了更强大的功能。</span><br><span class="line"></span><br><span class="line">// store.js</span><br><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;;</span><br><span class="line"></span><br><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;</span><br><span class="line">  state: () =&gt; (&#123; counter: 0 &#125;),</span><br><span class="line">  actions: &#123; increment() &#123; this.counter++; &#125; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useCounterStore &#125; from &#x27;./store&#x27;;</span><br><span class="line">import &#123; computed &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const store = useCounterStore();</span><br><span class="line">const counter = computed(() =&gt; store.counter);</span><br><span class="line">const incrementCounter = () =&gt; store.increment();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Composition API 的优势：</span><br><span class="line">更好的逻辑复用</span><br><span class="line">更灵活的代码组织</span><br><span class="line">更好的 TypeScript 支持</span><br><span class="line">更细粒度的逻辑控制</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插件如何替代mixin"><a href="#插件如何替代mixin" class="headerlink" title="插件如何替代mixin"></a>插件如何替代mixin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// myPlugin.js</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    // 添加全局方法</span><br><span class="line">    Vue.prototype.$myPluginMethod = function() &#123;</span><br><span class="line">      console.log(&#x27;This is a plugin method&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 添加自定义指令</span><br><span class="line">    Vue.directive(&#x27;my-directive&#x27;, &#123;</span><br><span class="line">      bind(el, binding) &#123;</span><br><span class="line">        el.style.color = binding.value || &#x27;red&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;;</span><br><span class="line">import App from &#x27;./App.vue&#x27;;</span><br><span class="line">import myPlugin from &#x27;./myPlugin&#x27;;</span><br><span class="line"></span><br><span class="line">const app = createApp(App);</span><br><span class="line">app.use(myPlugin);</span><br><span class="line">app.mount(&#x27;#app&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p v-my-directive=&quot;&#x27;blue&#x27;&quot;&gt;This text will be blue&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;$myPluginMethod&quot;&gt;Call Plugin Method&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高阶组件（HOC）如何替代mixin"><a href="#高阶组件（HOC）如何替代mixin" class="headerlink" title="高阶组件（HOC）如何替代mixin"></a>高阶组件（HOC）如何替代mixin</h2><p>高阶组件是一个函数，它接收一个组件作为参数，并返回一个新的组件。HOC 可以用来封装和复用组件逻辑，同时避免 Mixin 中常见的命名冲突和逻辑不清晰的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// withVip.js</span><br><span class="line">import &#123; h &#125; from &#x27;vue&#x27;;</span><br><span class="line">import OpenVipTip from &#x27;./OpenVipTip.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default function WithVip(BaseComponent) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    setup(props, &#123; attrs, slots &#125;) &#123;</span><br><span class="line">      const showVipContent = getShowVipContent();</span><br><span class="line"></span><br><span class="line">      function getShowVipContent() &#123;</span><br><span class="line">        // 业务逻辑：判断是否显示 VIP 内容</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        return showVipContent</span><br><span class="line">          ? h(BaseComponent, &#123; ...props, ...attrs &#125;, slots)</span><br><span class="line">          : h(OpenVipTip);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;EnhancedComponent /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import MyComponent from &#x27;./MyComponent.vue&#x27;;</span><br><span class="line">import WithVip from &#x27;./withVip.js&#x27;;</span><br><span class="line"></span><br><span class="line">const EnhancedComponent = WithVip(MyComponent);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Mixin：适合在组件内部复用逻辑，但可能导致命名冲突和逻辑不清晰。</span><br><span class="line">HOC：更适合封装组件逻辑，避免了 Mixin 的一些问题，同时提供了更灵活的代码组织方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>场景描述：通过高阶组件可以在不修改原始组件逻辑的情况下，为其添加额外的功能。<br>权限控制：为组件增加权限检查功能。例如，只有管理员权限的用户才能访问或操作某些组件。</p>
<h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">节流：在一段时间内只执行一次函数，即使多次触发事件，也只会在最后一次触发后执行。</span><br><span class="line">防抖：在事件触发后，延迟一段时间后执行函数，如果在延迟时间内再次触发事件，则重新计时。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个对象（除 null）都有一个隐式原型属性 __proto__，指向其构造函数的显式原型对象 prototype‌</p>
<p>‌实例对象‌ → ‌构造函数原型‌（prototype）→ ‌上级原型‌ → … → ‌Object.prototype‌ → ‌null‌<br>&#x2F;&#x2F; 原型链：cat.<strong>proto</strong> → Cat.prototype → Object.prototype → null</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="JavaScript-继承模式对比表"><a href="#JavaScript-继承模式对比表" class="headerlink" title="JavaScript 继承模式对比表"></a>JavaScript 继承模式对比表</h3><table>
<thead>
<tr>
<th>&#x3D;&#x3D;&zwnj;<strong>继承模式</strong>&zwnj;&#x3D;&#x3D;</th>
<th>引用类型共享问题</th>
<th>支持传参</th>
<th>性能效率</th>
<th>适用性</th>
</tr>
</thead>
<tbody><tr>
<td>原型链继承</td>
<td>❌</td>
<td>❌</td>
<td>中</td>
<td>简单方法继承</td>
</tr>
<tr>
<td>构造函数继承</td>
<td>✅</td>
<td>✅</td>
<td>高 ‌</td>
<td>独立属性初始化</td>
</tr>
<tr>
<td>组合继承</td>
<td>✅</td>
<td>✅ ‌</td>
<td>中（冗余）</td>
<td>通用场景</td>
</tr>
<tr>
<td>寄生组合式继承</td>
<td>✅ ‌</td>
<td>✅ ‌</td>
<td>高</td>
<td>高效完整继承 ‌</td>
</tr>
<tr>
<td>ES6 Class 继承</td>
<td>✅ ‌</td>
<td>✅ ‌</td>
<td>高 ‌</td>
<td>现代项目开发 ‌</td>
</tr>
</tbody></table>
<p>ES6 继承本质是语法糖，底层仍基于寄生组合式继承（避免多次调用父类构造函数）‌</p>
<p>ES6 Class 继承通过 extends 和 super 提供了简洁、直观的语法，解决了传统原型链继承的冗余和复杂性，同时确保继承机制的健壮性（如强制调用 super()）‌23。其底层仍遵循原型链规则，但通过语法糖优化了开发体验，是现代 JavaScript 开发的首选继承模式‌</p>
<p>寄生组合式继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function inheritPrototype(Child, Parent) &#123;</span><br><span class="line">  const prototype = Object.create(Parent.prototype); // 复制父类原型‌</span><br><span class="line">  prototype.constructor = Child; // 修正构造函数指向子类‌</span><br><span class="line">  Child.prototype = prototype; // 设置子类原型‌</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = function() &#123; console.log(this.name); &#125;;</span><br><span class="line"></span><br><span class="line">function Child(name, age) &#123;</span><br><span class="line">  Parent.call(this, name); // 继承父类实例属性‌:ml-citation&#123;ref=&quot;1,3&quot; data=&quot;citationList&quot;&#125;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Child, Parent); // 建立原型链关系</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123; this.name = name; &#125;</span><br><span class="line">  eat() &#123; console.log(`$&#123;this.name&#125; is eating`); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  constructor(name, color) &#123;</span><br><span class="line">    super(name); // 必须调用 super()</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父类的静态方法（static 修饰）会被子类继承，可通过 super 在子类静态方法中调用父类静态方法‌</span><br><span class="line">class Parent &#123;</span><br><span class="line">  static log() &#123; console.log(&quot;Parent static method&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static log() &#123;</span><br><span class="line">    super.log(); // 调用 Parent.log()</span><br><span class="line">    console.log(&quot;Child static method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="for-in-和-for-of-区别"><a href="#for-in-和-for-of-区别" class="headerlink" title="for in 和 for of 区别"></a>for in 和 for of 区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>for…of async&#x2F;await</th>
<th>for…in async&#x2F;await</th>
</tr>
</thead>
<tbody><tr>
<td>‌遍历目标‌</td>
<td>是用来遍历可迭代对象（如数组、字符串、Map、Set 等）的值</td>
<td>主要用于遍历对象（Object）的键（key）。</td>
</tr>
<tr>
<td>异步执行顺序</td>
<td>严格顺序执行</td>
<td>顺序执行但属性遍历顺序不确定</td>
</tr>
<tr>
<td>推荐场景</td>
<td>需顺序控制</td>
<td>不需要顺序控制</td>
</tr>
</tbody></table>
<h2 id="for-await-of-用法"><a href="#for-await-of-用法" class="headerlink" title="for await of 用法"></a>for await of 用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function* asyncGenerator() &#123;</span><br><span class="line">  yield await Promise.resolve(1);</span><br><span class="line">  yield await Promise.resolve(2);</span><br><span class="line">  yield await Promise.resolve(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  for await (const num of asyncGenerator()) &#123;</span><br><span class="line">    console.log(num); // 依次输出 1、2、3（间隔异步操作完成时间）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HTMLCollection和NodeList有什么区别"><a href="#HTMLCollection和NodeList有什么区别" class="headerlink" title="HTMLCollection和NodeList有什么区别"></a>HTMLCollection和NodeList有什么区别</h2><p>HTMLCollection：<br>通常通过 document.getElementById、document.getElementByTagName、document.getElementByClassName 和 document.getElementByName 等方法获取。<br>NodeList：<br>可以通过 Node.childNodes、Document.querySelectorAll 和 Element.querySelectorAll 等方法获取。</p>
<h2 id="严格模式和普通模式的区别"><a href="#严格模式和普通模式的区别" class="headerlink" title="严格模式和普通模式的区别"></a>严格模式和普通模式的区别</h2><p>严格模式和普通模式的区别：</p>
<ol>
<li>禁止未声明的变量：</li>
<li>禁止使用 with 语句</li>
<li>eval 的限制：eval 的行为被限制。它不会在其作用域中创建变量和函数，并且无法访问所在的上下文中的变量。</li>
<li>在严格模式下，不允许通过修改函数的 caller、callee 属性或 arguments 对象的某些属性来操作函数的调用链。</li>
<li>在严格模式下，如果函数没有指定 this 值，则 this 的值是 undefined，而不是全局对象</li>
<li>严格模式是 ES6 的默认模式：</li>
<li>函数参数不能重复</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); // undefined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="options-请求"><a href="#options-请求" class="headerlink" title="options 请求"></a>options 请求</h2><p>作用：<br>验证服务器是否允许跨域请求<br>了解服务器支持的 HTTP 方法和头</p>
<h2 id="OPTIONS-请求在跨域请求中会影响性能吗？"><a href="#OPTIONS-请求在跨域请求中会影响性能吗？" class="headerlink" title="OPTIONS 请求在跨域请求中会影响性能吗？"></a>OPTIONS 请求在跨域请求中会影响性能吗？</h2><p>增加网络请求数<br>服务器可以在 OPTIONS 响应中设置 Access-Control-Max-Age 响应头<br>例如，设置 Access-Control-Max-Age: 86400 表示预检结果缓存一天。</p>
<h2 id="vue2-和-vue3-区别"><a href="#vue2-和-vue3-区别" class="headerlink" title="vue2 和 vue3 区别"></a>vue2 和 vue3 区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Vue 2</th>
<th>Vue 3</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;&zwnj;<strong>响应式系统</strong>&zwnj;&#x3D;&#x3D;</td>
<td>基于 <code>Object.defineProperty</code></td>
<td>基于 <code>Proxy</code>，支持动态添加和删除属性</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>API 设计</strong>&zwnj;&#x3D;&#x3D;</td>
<td>Options API</td>
<td>Composition API + Options API</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>性能</strong>&zwnj;&#x3D;&#x3D;</td>
<td>较低，虚拟 DOM 的 diff 算法在复杂场景下性能较低</td>
<td>更高，重写了虚拟 DOM 的 diff 算法，优化了渲染性能</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>Tree Shaking</strong>&zwnj;&#x3D;&#x3D;</td>
<td>不支持</td>
<td>支持，打包时只包含用到的代码，减小了打包体积</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>TypeScript 支持</strong>&zwnj;&#x3D;&#x3D;</td>
<td>较弱，需要额外的配置和插件</td>
<td>内置支持，提供了更好的类型推断和开发体验</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>片段支持</strong>&zwnj;&#x3D;&#x3D;</td>
<td>不支持，组件模板必须有一个根元素</td>
<td>支持多根节点（Fragments）</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>Teleport</strong>&zwnj;&#x3D;&#x3D;</td>
<td>不支持</td>
<td>引入 <code>Teleport</code> 组件，可将组件渲染到 DOM 中的任意位置</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>自定义渲染器</strong>&zwnj;&#x3D;&#x3D;</td>
<td>支持较弱</td>
<td>提供了更灵活的自定义渲染器 API</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>Suspense</strong>&zwnj;&#x3D;&#x3D;</td>
<td>不支持</td>
<td>引入 <code>&lt;Suspense&gt;</code> 组件，用于处理异步组件的加载状态</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>生命周期钩子</strong>&zwnj;&#x3D;&#x3D;</td>
<td><code>beforeCreate</code>、<code>created</code> 等</td>
<td><code>beforeCreate</code> 改为 <code>setup</code>，其他钩子名前加 <code>on</code>，如 <code>onMounted</code></td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>生态兼容性</strong>&zwnj;&#x3D;&#x3D;</td>
<td>生态成熟，有大量第三方库和插件</td>
<td>生态正在逐步迁移，部分库可能还不支持 Vue 3</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>全局 API</strong>&zwnj;&#x3D;&#x3D;</td>
<td>通过 <code>new Vue()</code> 创建实例，全局配置影响所有实例</td>
<td>使用 <code>createApp()</code> 创建隔离的应用实例，全局 API 改为实例方法</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>v-model 增强</strong>&zwnj;&#x3D;&#x3D;</td>
<td>不支持多个 <code>v-model</code> 绑定</td>
<td>支持多个 <code>v-model</code> 绑定，如 <code>v-model:title</code></td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>移除过滤器</strong>&zwnj;&#x3D;&#x3D;</td>
<td>支持过滤器</td>
<td>移除过滤器，推荐用计算属性或方法替代</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&zwnj;<strong>事件总线</strong>&zwnj;&#x3D;&#x3D;</td>
<td>常用事件总线进行组件间通信</td>
<td>弃用事件总线，推荐使用 <code>provide/inject</code> 或状态管理库</td>
</tr>
</tbody></table>
<h2 id="vue3-如何实现的-对-Tree-Shaking-的支持"><a href="#vue3-如何实现的-对-Tree-Shaking-的支持" class="headerlink" title="vue3 如何实现的 对 Tree Shaking 的支持"></a>vue3 如何实现的 对 Tree Shaking 的支持</h2><p>1、Vue 3 完全基于 ES6 模块系统 （import）和导出（export）语法，编译器可以在编译阶段确定模块之间的依赖关系以及输入和输出的变量Tree Shaking 可以通过静态分析代码，识别出未使用的代码并将其移除<br>2、Vue 3 使用了先进的编译器（如 Vite、Rollup 等），这些编译器内置了对 Tree Shaking 的支持<br>3、Vue 3 的 Composition API 提供了更细粒度的功能模块，有助于 Tree Shaking 的实现。例如：<br>4、避免副作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐的做法</span><br><span class="line">console.log(&#x27;This is a side effect&#x27;);</span><br><span class="line"></span><br><span class="line">// 推荐的做法</span><br><span class="line">export function logMessage(message) &#123;</span><br><span class="line">  console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、确保打包工具（如 Webpack、Rollup）配置正确，启用 Tree Shaking 功能。以 Webpack 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    usedExports: true, // 启用Tree Shaking</span><br><span class="line">    minimize: true, // 启用代码压缩</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="vue3-如何重写了虚拟-DOM-的-diff-算法，优化了渲染性能"><a href="#vue3-如何重写了虚拟-DOM-的-diff-算法，优化了渲染性能" class="headerlink" title="vue3 如何重写了虚拟 DOM 的 diff 算法，优化了渲染性能"></a>vue3 如何重写了虚拟 DOM 的 diff 算法，优化了渲染性能</h2><p><a target="_blank" rel="noopener" href="http://localhost:4000/2024/12/12/vue3/">http://localhost:4000/2024/12/12/vue3/</a></p>
<h2 id="createApp-和-new-Vue-对比有什么好处？"><a href="#createApp-和-new-Vue-对比有什么好处？" class="headerlink" title="createApp 和 new Vue 对比有什么好处？"></a>createApp 和 new Vue 对比有什么好处？</h2><p>1、createApp 创建的应用实例是独立的，全局配置和组件仅对当前实例生效，避免了不同应用实例之间的相互影响。<br>适合大型项目或多团队协作开发，不同子项目可以挂载不同的指令、组件等，互不影响。<br>2、createApp 支持模块化设计，便于按需引入功能，减少打包体积</p>
<h2 id="首屏速度"><a href="#首屏速度" class="headerlink" title="首屏速度"></a>首屏速度</h2><p>白屏时间</p>
<p>1、减少首屏资源体积（打包工具的压缩，异步加载，更新较新的版本(按需引入) tree-shaking ,gzip ）去除大的base64体积，尽量少用三方库，图片懒加载</p>
<p>特殊情况的优化操作：<br>1.首屏数据尽量并行，如何可行让n小数据量接口合并到一个接口中<br>2.无限滚动，可以分批滚动渲染。<br>3.骨架屏，loading,先让屏幕不白，减少用户焦虑</p>
<p>什么情况会造成卡顿和渲染慢？</p>
<p>1、一次性操作大量dom</p>
<p>2、进行了复杂度很高的运算</p>
<p>3、vue和react项目中，不必要的渲染太多</p>
<p>vue3<br>v-show 代替 v-if<br>循环，动态切换的内容加上key<br>keep-alive缓存 （）<br>接口更新粒度尽量小，避免不必要的请求</p>
<p>不变数据，定期时效可以缓存在cookies 或者 localStorage中,比如 token,用户名等</p>
<p>pinia</p>
<!-- 2、减少首屏资源数量（减少http请求数量，合并css，图片） -->


<h2 id="js-深拷贝有哪些方式"><a href="#js-深拷贝有哪些方式" class="headerlink" title="js 深拷贝有哪些方式"></a>js 深拷贝有哪些方式</h2><p>在 JavaScript 中，实现深拷贝有多种方式，以下是常见的几种方法：</p>
<h3 id="1-JSON-方法"><a href="#1-JSON-方法" class="headerlink" title="1. JSON 方法"></a>1. <strong>JSON 方法</strong></h3><ul>
<li><strong>原理</strong>：通过 <code>JSON.stringify</code> 将对象序列化为字符串，再通过 <code>JSON.parse</code> 将字符串反序列化为新的对象。</li>
<li><strong>代码示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopy); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优点</strong>：简单易用，代码量少。</li>
<li><strong>缺点</strong>：<ol>
<li>无法处理函数、<code>undefined</code>、<code>Date</code>、<code>RegExp</code> 等特殊类型。</li>
<li>无法处理循环引用（会报错）。</li>
<li>无法处理 <code>Map</code>、<code>Set</code>、<code>Buffer</code> 等复杂数据结构。</li>
</ol>
</li>
</ul>
<h3 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2. 递归实现"></a>2. <strong>递归实现</strong></h3><ul>
<li><strong>原理</strong>：通过递归遍历对象的每个属性，手动创建新的对象或数组，并将属性值复制到新对象中。</li>
<li><strong>代码示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">    hash.<span class="title function_">set</span>(obj, cloneObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            cloneObj[key] = <span class="title function_">deepCopy</span>(obj[key], hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopyObj = <span class="title function_">deepCopy</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopyObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优点</strong>：可以处理大部分数据类型，包括循环引用。</li>
<li><strong>缺点</strong>：代码复杂度较高，性能可能不如其他方法。</li>
</ul>
<h3 id="3-使用-structuredClone"><a href="#3-使用-structuredClone" class="headerlink" title="3. 使用 structuredClone"></a>3. <strong>使用 <code>structuredClone</code></strong></h3><ul>
<li><strong>原理</strong>：<code>structuredClone</code> 是一个现代的深拷贝方法，专门用于复制对象和数组，支持多种复杂数据结构。</li>
<li><strong>代码示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopyObj = <span class="title function_">structuredClone</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopyObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优点</strong>：<ol>
<li>支持大部分数据类型，包括 <code>Map</code>、<code>Set</code>、<code>Date</code>、<code>ArrayBuffer</code> 等。</li>
<li>内置处理循环引用。</li>
</ol>
</li>
<li><strong>缺点</strong>：不支持函数、<code>undefined</code>、<code>Infinity</code> 等特殊值。</li>
</ul>
<h3 id="4-使用库"><a href="#4-使用库" class="headerlink" title="4. 使用库"></a>4. <strong>使用库</strong></h3><ul>
<li><strong>原理</strong>：借助第三方库（如 <code>lodash</code>）实现深拷贝。</li>
<li><strong>代码示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopyObj = _.<span class="title function_">cloneDeep</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopyObj); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优点</strong>：功能强大，支持复杂数据结构和循环引用。</li>
<li><strong>缺点</strong>：需要引入额外的库，增加项目体积。</li>
</ul>
<h3 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5. 其他方法"></a>5. <strong>其他方法</strong></h3><ul>
<li><strong><code>Object.assign</code> 和扩展运算符（<code>...</code>）</strong>：仅支持浅拷贝，不能用于深拷贝。</li>
<li>**<code>cloneNode</code>**：用于 DOM 元素的深拷贝。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果需要简单快速的深拷贝，且不涉及复杂数据结构，可以使用 <code>JSON</code> 方法。</li>
<li>如果需要支持复杂数据结构和循环引用，推荐使用 <code>structuredClone</code> 或第三方库（如 <code>lodash</code>）。</li>
<li>如果需要完全自定义深拷贝逻辑，可以手动实现递归方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var personA = &#123;</span><br><span class="line">    aget: function() &#123;</span><br><span class="line">        return 20;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: &#x27;jack&#x27;,</span><br><span class="line">    job: undefined,</span><br><span class="line">    location: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSON.stringify(personA)</span><br><span class="line"></span><br><span class="line">打印：</span><br><span class="line">&#x27;&#123;&quot;name&quot;:&quot;jack&quot;,&quot;location&quot;:null&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="typescript-定义对象型-type-或者-interface-的时候，如何在原有定义的结构中删除一个属性"><a href="#typescript-定义对象型-type-或者-interface-的时候，如何在原有定义的结构中删除一个属性" class="headerlink" title="typescript 定义对象型 type 或者 interface 的时候，如何在原有定义的结构中删除一个属性"></a>typescript 定义对象型 type 或者 interface 的时候，如何在原有定义的结构中删除一个属性</h2><p>在 TypeScript 中，如果你想在定义对象型 <code>type</code> 或 <code>interface</code> 的时候，从原有定义的结构中删除一个属性，可以使用 <code>Omit</code> 泛型工具类型。<code>Omit</code> 允许你从一个类型中排除特定的属性。</p>
<h3 id="使用-Omit-删除属性"><a href="#使用-Omit-删除属性" class="headerlink" title="使用 Omit 删除属性"></a>使用 <code>Omit</code> 删除属性</h3><h4 id="1-定义原始类型"><a href="#1-定义原始类型" class="headerlink" title="1. 定义原始类型"></a>1. <strong>定义原始类型</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-Omit-删除属性"><a href="#2-使用-Omit-删除属性" class="headerlink" title="2. 使用 Omit 删除属性"></a>2. <strong>使用 <code>Omit</code> 删除属性</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserWithoutEmail</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">User</span>, <span class="string">&#x27;email&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">UserWithoutEmail</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserWithoutEmail</code> 是从 <code>User</code> 接口中派生出来的，但不包含 <code>email</code> 属性。</p>
<h3 id="自定义实现-Omit"><a href="#自定义实现-Omit" class="headerlink" title="自定义实现 Omit"></a>自定义实现 <code>Omit</code></h3><p>如果你使用的是较旧版本的 TypeScript，可能没有内置的 <code>Omit</code> 工具类型。你可以手动实现它：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1-定义原始类型-1"><a href="#1-定义原始类型-1" class="headerlink" title="1. 定义原始类型"></a>1. <strong>定义原始类型</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用自定义-Omit-删除属性"><a href="#2-使用自定义-Omit-删除属性" class="headerlink" title="2. 使用自定义 Omit 删除属性"></a>2. <strong>使用自定义 <code>Omit</code> 删除属性</strong></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserWithoutEmail</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">User</span>, <span class="string">&#x27;email&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">UserWithoutEmail</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="1-使用-Pick-和-Exclude"><a href="#1-使用-Pick-和-Exclude" class="headerlink" title="1. 使用 Pick 和 Exclude"></a>1. <strong>使用 <code>Pick</code> 和 <code>Exclude</code></strong></h4><p>你也可以直接使用 <code>Pick</code> 和 <code>Exclude</code> 来实现类似的效果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserWithoutEmail</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">User</span>, <span class="title class_">Exclude</span>&lt;keyof <span class="title class_">User</span>, <span class="string">&#x27;email&#x27;</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-Record"><a href="#2-使用-Record" class="headerlink" title="2. 使用 Record"></a>2. <strong>使用 <code>Record</code></strong></h4><p>如果你需要更灵活的控制，可以使用 <code>Record</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserWithoutEmail</span> = <span class="title class_">Record</span>&lt;<span class="title class_">Exclude</span>&lt;keyof <span class="title class_">User</span>, <span class="string">&#x27;email&#x27;</span>&gt;, <span class="title class_">User</span>[keyof <span class="title class_">User</span>]&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>Omit&lt;T, K&gt;</code>**：这是最直接的方式，用于从类型 <code>T</code> 中排除属性 <code>K</code>。</li>
<li><strong>自定义实现</strong>：如果你的 TypeScript 版本不支持 <code>Omit</code>，可以手动实现它。</li>
<li><strong>其他方法</strong>：使用 <code>Pick</code> 和 <code>Exclude</code> 或 <code>Record</code> 也可以实现类似的效果。</li>
</ul>
<p>通过这些方法，你可以在定义对象型 <code>type</code> 或 <code>interface</code> 的时候，灵活地删除不需要的属性。</p>
<p>ts(TypeScript)常用语法(Omit、Pick、Partial、Required)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jojo1001/article/details/121074549">https://blog.csdn.net/jojo1001/article/details/121074549</a></p>
<h2 id="react-hooks-的好处是什么？用过哪些hooks，分别说明什么场景下使用？hooks对应之前react的生命周期？"><a href="#react-hooks-的好处是什么？用过哪些hooks，分别说明什么场景下使用？hooks对应之前react的生命周期？" class="headerlink" title="react hooks 的好处是什么？用过哪些hooks，分别说明什么场景下使用？hooks对应之前react的生命周期？"></a>react hooks 的好处是什么？用过哪些hooks，分别说明什么场景下使用？hooks对应之前react的生命周期？</h2><h3 id="React-Hooks-的好处"><a href="#React-Hooks-的好处" class="headerlink" title="React Hooks 的好处"></a>React Hooks 的好处</h3><p>React Hooks 是 React 16.8 引入的新特性，它允许你在函数组件中使用状态和其他 React 特性，而无需编写类组件。Hooks 的主要好处包括：</p>
<ol>
<li><strong>复用状态逻辑</strong>：Hooks 让你能够在不同的组件之间复用状态逻辑。</li>
<li><strong>简化组件结构</strong>：Hooks 让你能够将组件逻辑分解成更小的、可复用的函数。</li>
<li><strong>更好的可读性和可维护性</strong>：Hooks 让组件逻辑更加清晰，易于理解和维护。</li>
<li><strong>减少样板代码</strong>：Hooks 减少了编写类组件所需的样板代码。</li>
</ol>
<h3 id="常用的-Hooks-及其使用场景"><a href="#常用的-Hooks-及其使用场景" class="headerlink" title="常用的 Hooks 及其使用场景"></a>常用的 Hooks 及其使用场景</h3><h4 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. <code>useState</code></h4><p><strong>用途</strong>：用于在函数组件中添加状态变量。<br><strong>使用场景</strong>：需要管理组件内部状态时，例如表单输入、开关按钮等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. <code>useEffect</code></h4><p><strong>用途</strong>：用于在函数组件中执行副作用操作（如数据获取、订阅事件等）。<br><strong>使用场景</strong>：需要在组件挂载、更新或卸载时执行某些操作，例如获取数据、设置定时器等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DataFetcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="title function_">setData</span>(data));</span><br><span class="line">  &#125;, []); <span class="comment">// 空依赖数组表示仅在组件挂载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;data ? data : &#x27;Loading...&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-useContext"><a href="#3-useContext" class="headerlink" title="3. useContext"></a>3. <code>useContext</code></h4><p><strong>用途</strong>：用于在函数组件中订阅 React 上下文。<br><strong>使用场景</strong>：需要访问全局状态或主题时，例如多语言切换、主题切换等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ThemeContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./ThemeContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemedButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;theme&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4. useReducer"></a>4. <code>useReducer</code></h4><p><strong>用途</strong>：用于管理复杂的状态逻辑。<br><strong>使用场景</strong>：状态逻辑较为复杂，需要通过 reducer 函数管理时，例如表单验证、购物车逻辑等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-useRef"><a href="#5-useRef" class="headerlink" title="5. useRef"></a>5. <code>useRef</code></h4><p><strong>用途</strong>：用于在函数组件中创建一个可变的引用。<br><strong>使用场景</strong>：需要在组件之间共享可变值时，例如管理计时器、DOM 元素等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> intervalRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    intervalRef.<span class="property">current</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(intervalRef.<span class="property">current</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Timer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-useMemo"><a href="#6-useMemo" class="headerlink" title="6. useMemo"></a>6. <code>useMemo</code></h4><p><strong>用途</strong>：用于缓存计算结果，避免重复计算。<br><strong>使用场景</strong>：需要优化性能，避免不必要的计算时，例如复杂的数学运算、数据处理等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HeavyComputation</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computedData = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟复杂计算</span></span><br><span class="line">    <span class="keyword">return</span> data.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line">  &#125;, [data]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed Data: &#123;computedData.join(&#x27;, &#x27;)&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-useCallback"><a href="#7-useCallback" class="headerlink" title="7. useCallback"></a>7. <code>useCallback</code></h4><p><strong>用途</strong>：用于缓存函数，避免函数重新创建。<br><strong>使用场景</strong>：需要优化性能，避免不必要的组件重新渲染时，例如传递回调函数给子组件等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increment = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">onIncrement</span>=<span class="string">&#123;increment&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChildComponent</span>(<span class="params">&#123; onIncrement &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncrement&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hooks-与-React-生命周期的对应关系"><a href="#Hooks-与-React-生命周期的对应关系" class="headerlink" title="Hooks 与 React 生命周期的对应关系"></a>Hooks 与 React 生命周期的对应关系</h3><h4 id="1-useEffect"><a href="#1-useEffect" class="headerlink" title="1. useEffect"></a>1. <code>useEffect</code></h4><ul>
<li>**<code>componentDidMount</code>**：当依赖数组为空时，<code>useEffect</code> 在组件挂载后执行。</li>
<li>**<code>componentDidUpdate</code>**：当依赖数组有值时，<code>useEffect</code> 在组件更新后执行。</li>
<li>**<code>componentWillUnmount</code>**：<code>useEffect</code> 的清理函数在组件卸载前执行。</li>
</ul>
<h4 id="2-useState"><a href="#2-useState" class="headerlink" title="2. useState"></a>2. <code>useState</code></h4><ul>
<li>**<code>constructor</code>**：<code>useState</code> 初始化状态，类似于类组件的 <code>constructor</code>。</li>
</ul>
<h4 id="3-useContext-1"><a href="#3-useContext-1" class="headerlink" title="3. useContext"></a>3. <code>useContext</code></h4><ul>
<li>**<code>context</code>**：<code>useContext</code> 订阅上下文，类似于类组件的 <code>context</code>。</li>
</ul>
<h4 id="4-useReducer-1"><a href="#4-useReducer-1" class="headerlink" title="4. useReducer"></a>4. <code>useReducer</code></h4><ul>
<li>**<code>state</code>**：<code>useReducer</code> 管理状态，类似于类组件的 <code>state</code> 和 <code>this.setState</code>。</li>
</ul>
<h4 id="5-useRef-1"><a href="#5-useRef-1" class="headerlink" title="5. useRef"></a>5. <code>useRef</code></h4><ul>
<li>**<code>ref</code>**：<code>useRef</code> 创建引用，类似于类组件的 <code>ref</code>。</li>
</ul>
<h4 id="6-useMemo-和-useCallback"><a href="#6-useMemo-和-useCallback" class="headerlink" title="6. useMemo 和 useCallback"></a>6. <code>useMemo</code> 和 <code>useCallback</code></h4><ul>
<li><strong>优化性能</strong>：<code>useMemo</code> 和 <code>useCallback</code> 用于优化性能，避免不必要的计算和组件重新渲染。</li>
</ul>
<p>通过使用 Hooks，你可以更灵活地管理组件的状态和生命周期，使代码更加简洁和可维护。</p>
<h2 id="useReducer-的使用，和redux中的reducer有什么区别？redux的相关使用方式。"><a href="#useReducer-的使用，和redux中的reducer有什么区别？redux的相关使用方式。" class="headerlink" title="useReducer 的使用，和redux中的reducer有什么区别？redux的相关使用方式。"></a>useReducer 的使用，和redux中的reducer有什么区别？redux的相关使用方式。</h2><h3 id="useReducer-的使用与-Redux-中的-reducer-的区别"><a href="#useReducer-的使用与-Redux-中的-reducer-的区别" class="headerlink" title="useReducer 的使用与 Redux 中的 reducer 的区别"></a>useReducer 的使用与 Redux 中的 reducer 的区别</h3><h4 id="useReducer-的使用"><a href="#useReducer-的使用" class="headerlink" title="useReducer 的使用"></a>useReducer 的使用</h4><p><code>useReducer</code> 是 React 的一个 Hook，用于管理组件内部的状态。它类似于 <code>useState</code>，但更适合用于管理复杂的状态逻辑。</p>
<p><strong>基本使用</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 reducer 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中使用 useReducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redux-中的-reducer"><a href="#Redux-中的-reducer" class="headerlink" title="Redux 中的 reducer"></a>Redux 中的 reducer</h4><p>Redux 是一个用于管理全局状态的库，它与 React 一起使用时，通常用于管理复杂的全局状态。Redux 中的 reducer 用于定义如何更新状态。</p>
<p><strong>基本使用</strong>：</p>
<ol>
<li><strong>定义 reducer</strong>：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counterReducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params">state = &#123; count: <span class="number">0</span> &#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建 store</strong>：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./counterReducer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>在组件中使用 Redux</strong>：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useReducer-与-Redux-的区别"><a href="#useReducer-与-Redux-的区别" class="headerlink" title="useReducer 与 Redux 的区别"></a>useReducer 与 Redux 的区别</h3><ol>
<li><p><strong>作用范围</strong>：</p>
<ul>
<li><code>useReducer</code>：用于管理组件内部的状态，适合在单个组件或少量组件之间共享状态。</li>
<li>Redux：用于管理全局状态，适合在多个组件之间共享状态，尤其是复杂的应用。</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li><code>useReducer</code>：相对简单，适合简单的状态管理。</li>
<li>Redux：相对复杂，需要额外的配置和中间件支持，适合复杂的全局状态管理。</li>
</ul>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li><code>useReducer</code>：性能较好，因为状态更新只影响相关的组件。</li>
<li>Redux：性能稍差，因为全局状态更新时，所有订阅的组件都会重新渲染。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><code>useReducer</code>：适合在组件内部或少量组件之间管理状态。</li>
<li>Redux：适合在多个组件之间共享状态，尤其是需要全局状态管理的场景。</li>
</ul>
</li>
</ol>
<h3 id="Redux-的相关使用方式"><a href="#Redux-的相关使用方式" class="headerlink" title="Redux 的相关使用方式"></a>Redux 的相关使用方式</h3><h4 id="1-安装-Redux-和-React-Redux"><a href="#1-安装-Redux-和-React-Redux" class="headerlink" title="1. 安装 Redux 和 React-Redux"></a>1. <strong>安装 Redux 和 React-Redux</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux react-redux</span><br></pre></td></tr></table></figure>

<h4 id="2-定义-Reducer"><a href="#2-定义-Reducer" class="headerlink" title="2. 定义 Reducer"></a>2. <strong>定义 Reducer</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counterReducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params">state = &#123; count: <span class="number">0</span> &#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建-Store"><a href="#3-创建-Store" class="headerlink" title="3. 创建 Store"></a>3. <strong>创建 Store</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./counterReducer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br></pre></td></tr></table></figure>

<h4 id="4-在根组件中提供-Store"><a href="#4-在根组件中提供-Store" class="headerlink" title="4. 在根组件中提供 Store"></a>4. <strong>在根组件中提供 Store</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Counter</span> <span class="keyword">from</span> <span class="string">&#x27;./Counter&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-在组件中使用-Redux"><a href="#5-在组件中使用-Redux" class="headerlink" title="5. 在组件中使用 Redux"></a>5. <strong>在组件中使用 Redux</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-使用-Middleware"><a href="#6-使用-Middleware" class="headerlink" title="6. 使用 Middleware"></a>6. <strong>使用 Middleware</strong></h4><p>Redux 提供了中间件机制，用于处理异步操作和其他副作用。常见的中间件包括 <code>redux-thunk</code> 和 <code>redux-saga</code>。</p>
<p><strong>安装 redux-thunk</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux-thunk</span><br></pre></td></tr></table></figure>

<p><strong>配置中间件</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./counterReducer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer, <span class="title function_">applyMiddleware</span>(thunk));</span><br></pre></td></tr></table></figure>

<p><strong>使用异步操作</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;DECREMENT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">incrementAsync</span> = (<span class="params"></span>) =&gt; <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="title function_">increment</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在组件中使用异步操作</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement, incrementAsync &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(incrementAsync())&#125;&gt;Increment Async<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>useReducer</strong>：适合在组件内部或少量组件之间管理状态，简单易用。</li>
<li><strong>Redux</strong>：适合管理全局状态，尤其在复杂的应用中，提供了强大的状态管理和中间件支持。</li>
</ul>
<p>通过合理选择和使用 <code>useReducer</code> 和 Redux，可以更有效地管理 React 应用中的状态。</p>
<h2 id="如何对-react做性能优化？"><a href="#如何对-react做性能优化？" class="headerlink" title="如何对 react做性能优化？"></a>如何对 react做性能优化？</h2><p>React 性能优化可以从多个层面进行，包括组件优化、渲染优化、数据管理优化、构建优化等。以下是一些关键的优化技巧和最佳实践：</p>
<h3 id="1-组件优化"><a href="#1-组件优化" class="headerlink" title="1. 组件优化"></a>1. 组件优化</h3><h4 id="使用-React-memo-和-useMemo"><a href="#使用-React-memo-和-useMemo" class="headerlink" title="使用 React.memo 和 useMemo"></a>使用 <code>React.memo</code> 和 <code>useMemo</code></h4><ul>
<li>**<code>React.memo</code>**：用于缓存函数组件的渲染结果，避免不必要的重渲染。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ProductCard</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; id, name, price, image &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;product-card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;image&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;name&#125;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;formatPrice(price)&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="function">(<span class="params">prevProps, nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prevProps.<span class="property">id</span> === nextProps.<span class="property">id</span> &amp;&amp; prevProps.<span class="property">price</span> === nextProps.<span class="property">price</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>**<code>useMemo</code>**：用于缓存计算结果，避免重复计算。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filteredProducts = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> products.<span class="title function_">filter</span>(<span class="function"><span class="params">product</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(filters).<span class="title function_">every</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> product[key] === value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, [products, filters]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用-useCallback"><a href="#使用-useCallback" class="headerlink" title="使用 useCallback"></a>使用 <code>useCallback</code></h4><ul>
<li>**<code>useCallback</code>**：用于缓存回调函数，避免在每次渲染时创建新的函数实例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleFilter = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">newFilters</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setFilters</span>(newFilters);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-渲染优化"><a href="#2-渲染优化" class="headerlink" title="2. 渲染优化"></a>2. 渲染优化</h3><h4 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h4><ul>
<li>**<code>react-window</code> 和 <code>react-virtualized</code>**：用于优化长列表的渲染，只渲染可视区域的元素。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FixedSizeList</span> <span class="keyword">as</span> <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-window&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">VirtualizedList</span> = (<span class="params">&#123; items &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">height</span>=<span class="string">&#123;500&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemCount</span>=<span class="string">&#123;items.length&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemSize</span>=<span class="string">&#123;35&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">width</span>=<span class="string">&#123;300&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;(&#123; index, style &#125;) =&gt; (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;items[index]&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    )&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">List</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="懒加载与按需加载"><a href="#懒加载与按需加载" class="headerlink" title="懒加载与按需加载"></a>懒加载与按需加载</h4><ul>
<li>**<code>React.lazy</code> 和 <code>Suspense</code>**：用于实现组件的按需加载，减少初次加载时间。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./LazyComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">LazyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-数据管理优化"><a href="#3-数据管理优化" class="headerlink" title="3. 数据管理优化"></a>3. 数据管理优化</h3><h4 id="使用-Redux-或-Context-API"><a href="#使用-Redux-或-Context-API" class="headerlink" title="使用 Redux 或 Context API"></a>使用 Redux 或 Context API</h4><ul>
<li><p><strong>Redux</strong>：用于管理全局状态，避免通过多层组件传递 props。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span>, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Context API</strong>：用于在组件树中传递状态，避免 props drilling。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;context&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-构建优化"><a href="#4-构建优化" class="headerlink" title="4. 构建优化"></a>4. 构建优化</h3><h4 id="使用-Webpack-优化打包"><a href="#使用-Webpack-优化打包" class="headerlink" title="使用 Webpack 优化打包"></a>使用 Webpack 优化打包</h4><ul>
<li><strong>Tree Shaking</strong>：去除未使用的代码，减少打包体积。</li>
<li><strong>代码分割</strong>：将代码分割成多个 bundle，按需加载。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用-webpack-bundle-analyzer"><a href="#使用-webpack-bundle-analyzer" class="headerlink" title="使用 webpack-bundle-analyzer"></a>使用 <code>webpack-bundle-analyzer</code></h4><ul>
<li><strong>分析依赖包</strong>：找出不必要的依赖包，进行优化。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-性能分析工具"><a href="#5-性能分析工具" class="headerlink" title="5. 性能分析工具"></a>5. 性能分析工具</h3><h4 id="使用-React-DevTools-和-Chrome-DevTools"><a href="#使用-React-DevTools-和-Chrome-DevTools" class="headerlink" title="使用 React DevTools 和 Chrome DevTools"></a>使用 React DevTools 和 Chrome DevTools</h4><ul>
<li><strong>React DevTools</strong>：用于分析组件的渲染性能，找出性能瓶颈。</li>
<li><strong>Chrome DevTools</strong>：用于分析应用的性能，包括网络请求、内存使用等。</li>
</ul>
<h3 id="6-其他优化技巧"><a href="#6-其他优化技巧" class="headerlink" title="6. 其他优化技巧"></a>6. 其他优化技巧</h3><h4 id="为列表项添加唯一-key-属性"><a href="#为列表项添加唯一-key-属性" class="headerlink" title="为列表项添加唯一 key 属性"></a>为列表项添加唯一 <code>key</code> 属性</h4><ul>
<li><strong><code>key</code> 属性</strong>：帮助 React 的 diff 算法高效地复用节点，减少节点的创建和删除操作。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listItems = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="避免在-render-函数中直接定义函数"><a href="#避免在-render-函数中直接定义函数" class="headerlink" title="避免在 render 函数中直接定义函数"></a>避免在 <code>render</code> 函数中直接定义函数</h4><ul>
<li><strong>函数定义</strong>：将函数保存到组件的成员对象中，避免每次渲染生成新的函数实例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleButtonClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleButtonClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-使用-React-Query-进行高效的数据获取"><a href="#7-使用-React-Query-进行高效的数据获取" class="headerlink" title="7. 使用 React Query 进行高效的数据获取"></a>7. 使用 React Query 进行高效的数据获取</h3><ul>
<li><strong>React Query</strong>：用于数据获取、缓存和同步，简化数据管理流程。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">QueryClient</span>, <span class="title class_">QueryClientProvider</span>, useQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="keyword">new</span> <span class="title class_">QueryClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">QueryClientProvider</span> <span class="attr">client</span>=<span class="string">&#123;queryClient&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">QueryClientProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, isLoading &#125; = <span class="title function_">useQuery</span>(<span class="string">&#x27;fetchData&#x27;</span>, fetchDataFunction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isLoading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Data: &#123;JSON.stringify(data)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过以上这些优化技巧，可以显著提升 React 应用的性能，改善用户体验。</p>
<h2 id="react-memo-useMemo-useCallback的使用场景和区别？"><a href="#react-memo-useMemo-useCallback的使用场景和区别？" class="headerlink" title="react.memo,useMemo,useCallback的使用场景和区别？"></a>react.memo,useMemo,useCallback的使用场景和区别？</h2><p>在 React 中，<code>react.memo</code>、<code>useMemo</code> 和 <code>useCallback</code> 是三个常用的性能优化工具，它们分别用于不同的场景。下面将详细介绍它们的使用场景和区别。</p>
<h3 id="1-react-memo"><a href="#1-react-memo" class="headerlink" title="1. react.memo"></a>1. <code>react.memo</code></h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>react.memo</code> 是一个高阶组件（HOC），用于缓存函数组件的渲染结果，避免不必要的重渲染。它会在组件的 props 没有发生变化时，直接返回之前渲染的缓存结果。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProductCard</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; id, name, price, image &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;product-card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;image&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;name&#125;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;price&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="function">(<span class="params">prevProps, nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> prevProps.<span class="property">id</span> === nextProps.<span class="property">id</span> &amp;&amp; prevProps.<span class="property">price</span> === nextProps.<span class="property">price</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="2-useMemo"><a href="#2-useMemo" class="headerlink" title="2. useMemo"></a>2. <code>useMemo</code></h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>useMemo</code> 是一个 Hook，用于缓存函数内部的计算结果，避免重复计算。它会在依赖项发生变化时重新计算，否则直接返回缓存的结果。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [products, setProducts] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="keyword">const</span> [filters, setFilters] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filteredProducts = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> products.<span class="title function_">filter</span>(<span class="function"><span class="params">product</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(filters).<span class="title function_">every</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> product[key] === value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [products, filters]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Filtered Products: &#123;filteredProducts.length&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-useCallback"><a href="#3-useCallback" class="headerlink" title="3. useCallback"></a>3. <code>useCallback</code></h3><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>useCallback</code> 是一个 Hook，用于缓存函数，避免在每次渲染时创建新的函数实例。它会在依赖项发生变化时重新创建函数，否则直接返回缓存的函数。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [products, setProducts] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="keyword">const</span> [filters, setFilters] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleFilter = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">newFilters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setFilters</span>(newFilters);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">FilterComponent</span> <span class="attr">onFilter</span>=<span class="string">&#123;handleFilter&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>**<code>useCallback</code>**：用于函数级别的缓存，避免函数的重复创建。</li>
<li>**<code>react.memo</code>**：用于组件级别的缓存，避免组件的重复渲染。</li>
<li>**<code>useMemo</code>**：用于函数内部的缓存，避免重复计算。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>工具</th>
<th>使用场景</th>
<th>缓存内容</th>
<th>缓存条件</th>
</tr>
</thead>
<tbody><tr>
<td><code>react.memo</code></td>
<td>组件级别的缓存，避免重复渲染</td>
<td>组件的渲染结果</td>
<td>props 没有变化</td>
</tr>
<tr>
<td><code>useMemo</code></td>
<td>函数内部的缓存，避免重复计算</td>
<td>计算结果</td>
<td>依赖项没有变化</td>
</tr>
<tr>
<td><code>useCallback</code></td>
<td>函数级别的缓存，避免函数重复创建</td>
<td>函数</td>
<td>依赖项没有变化</td>
</tr>
</tbody></table>
<p>通过合理使用 <code>react.memo</code>、<code>useMemo</code> 和 <code>useCallback</code>，可以显著提升 React 应用的性能，减少不必要的渲染和计算。</p>
<h2 id="类组件和函数组件的区别？"><a href="#类组件和函数组件的区别？" class="headerlink" title="类组件和函数组件的区别？"></a>类组件和函数组件的区别？</h2><p>类组件和函数组件是 React 中两种主要的组件类型，它们在语法、功能和使用场景上有一些区别。以下是它们的主要区别和各自的特点：</p>
<h3 id="1-语法和定义方式"><a href="#1-语法和定义方式" class="headerlink" title="1. 语法和定义方式"></a>1. <strong>语法和定义方式</strong></h3><h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><p>类组件是通过继承 <code>React.Component</code> 或 <code>React.PureComponent</code> 来定义的。它们使用类的语法，并且需要在类中定义 <code>render</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 生命周期方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          Increment</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件是通过定义一个函数来创建的。它们使用函数的语法，并且可以直接返回 JSX。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-状态管理"><a href="#2-状态管理" class="headerlink" title="2. 状态管理"></a>2. <strong>状态管理</strong></h3><h4 id="类组件-1"><a href="#类组件-1" class="headerlink" title="类组件"></a>类组件</h4><p>类组件使用 <code>this.state</code> 来管理状态，并通过 <code>this.setState</code> 来更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="函数组件-1"><a href="#函数组件-1" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件使用 <code>useState</code> Hook 来管理状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-生命周期方法"><a href="#3-生命周期方法" class="headerlink" title="3. 生命周期方法"></a>3. <strong>生命周期方法</strong></h3><h4 id="类组件-2"><a href="#类组件-2" class="headerlink" title="类组件"></a>类组件</h4><p>类组件有完整的生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 在组件挂载后执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">  <span class="comment">// 在组件更新后执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 在组件卸载前执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件-2"><a href="#函数组件-2" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件使用 <code>useEffect</code> Hook 来实现副作用操作，类似于类组件的生命周期方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在组件挂载后执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在组件卸载前执行</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在组件更新后执行</span></span><br><span class="line">&#125;, [依赖项]);</span><br></pre></td></tr></table></figure>

<h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. <strong>性能优化</strong></h3><h4 id="类组件-3"><a href="#类组件-3" class="headerlink" title="类组件"></a>类组件</h4><p>类组件可以使用 <code>React.PureComponent</code> 来进行性能优化，<code>React.PureComponent</code> 会在 <code>props</code> 或 <code>state</code> 没有变化时避免不必要的渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PureClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="comment">// 组件逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件-3"><a href="#函数组件-3" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件可以使用 <code>React.memo</code> 来进行性能优化，<code>React.memo</code> 会在 <code>props</code> 没有变化时避免不必要的渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MemoizedFunctionComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">FunctionComponent</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-Hooks-的使用"><a href="#5-Hooks-的使用" class="headerlink" title="5. Hooks 的使用"></a>5. <strong>Hooks 的使用</strong></h3><h4 id="类组件-4"><a href="#类组件-4" class="headerlink" title="类组件"></a>类组件</h4><p>类组件不能直接使用 Hooks，因为 Hooks 是为函数组件设计的。</p>
<h4 id="函数组件-4"><a href="#函数组件-4" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件可以使用 Hooks 来管理状态、副作用、上下文等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 副作用操作</span></span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-代码简洁性"><a href="#6-代码简洁性" class="headerlink" title="6. 代码简洁性"></a>6. <strong>代码简洁性</strong></h3><h4 id="类组件-5"><a href="#类组件-5" class="headerlink" title="类组件"></a>类组件</h4><p>类组件的语法相对复杂，需要定义类、构造函数、<code>render</code> 方法等。</p>
<h4 id="函数组件-5"><a href="#函数组件-5" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件的语法更简洁，直接返回 JSX，适合简单的组件逻辑。</p>
<h3 id="7-使用场景"><a href="#7-使用场景" class="headerlink" title="7. 使用场景"></a>7. <strong>使用场景</strong></h3><h4 id="类组件-6"><a href="#类组件-6" class="headerlink" title="类组件"></a>类组件</h4><p>类组件适合复杂的组件逻辑，尤其是需要使用生命周期方法和管理多个状态的场景。</p>
<h4 id="函数组件-6"><a href="#函数组件-6" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数组件适合简单的组件逻辑，尤其是需要快速开发和维护的场景。随着 Hooks 的引入，函数组件的功能越来越强大，可以替代大多数类组件的使用场景。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>类组件</th>
<th>函数组件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>语法</strong></td>
<td>类语法</td>
<td>函数语法</td>
</tr>
<tr>
<td><strong>状态管理</strong></td>
<td><code>this.state</code> 和 <code>this.setState</code></td>
<td><code>useState</code> Hook</td>
</tr>
<tr>
<td><strong>生命周期方法</strong></td>
<td>完整的生命周期方法</td>
<td><code>useEffect</code> Hook</td>
</tr>
<tr>
<td><strong>性能优化</strong></td>
<td><code>React.PureComponent</code></td>
<td><code>React.memo</code></td>
</tr>
<tr>
<td><strong>Hooks 使用</strong></td>
<td>不能直接使用 Hooks</td>
<td>可以使用 Hooks</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>较复杂</td>
<td>较简洁</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>复杂逻辑和生命周期方法</td>
<td>简单逻辑和快速开发</td>
</tr>
</tbody></table>
<p>通过合理选择和使用类组件和函数组件，可以更有效地开发和维护 React 应用。</p>
<h2 id="有状态组件和无状态组件的区别？"><a href="#有状态组件和无状态组件的区别？" class="headerlink" title="有状态组件和无状态组件的区别？"></a>有状态组件和无状态组件的区别？</h2><p>在 React 中，组件可以根据是否管理自己的状态分为有状态组件（Stateful Components）和无状态组件（Stateless Components）。以下是它们的主要区别：</p>
<h3 id="1-定义和状态管理"><a href="#1-定义和状态管理" class="headerlink" title="1. 定义和状态管理"></a>1. <strong>定义和状态管理</strong></h3><h4 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h4><ul>
<li><strong>定义</strong>：有状态组件是指那些管理自己内部状态的组件。它们可以是类组件或函数组件。</li>
<li><strong>状态管理</strong>：有状态组件使用 <code>this.state</code>（类组件）或 <code>useState</code> Hook（函数组件）来管理状态。</li>
</ul>
<p><strong>类组件示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatefulClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StatefulFunctionComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h4><ul>
<li><strong>定义</strong>：无状态组件是指那些不管理自己内部状态的组件。它们只接收 props 并根据 props 渲染 UI。</li>
<li><strong>状态管理</strong>：无状态组件不管理自己的状态，它们的状态由父组件或其他外部状态管理工具（如 Redux）提供。</li>
</ul>
<p><strong>类组件示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatelessClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.onIncrement&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">StatelessFunctionComponent</span>(<span class="params">&#123; count, onIncrement &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncrement&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. <strong>性能</strong></h3><h4 id="有状态组件-1"><a href="#有状态组件-1" class="headerlink" title="有状态组件"></a>有状态组件</h4><ul>
<li><strong>性能</strong>：有状态组件在每次状态更新时会重新渲染，可能会导致性能问题，尤其是在复杂的组件树中。</li>
<li><strong>优化</strong>：可以使用 <code>React.PureComponent</code>（类组件）或 <code>React.memo</code>（函数组件）来优化性能，避免不必要的渲染。</li>
</ul>
<p><strong>类组件优化示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OptimizedStatefulClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数组件优化示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizedStatefulFunctionComponent</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="无状态组件-1"><a href="#无状态组件-1" class="headerlink" title="无状态组件"></a>无状态组件</h4><ul>
<li><strong>性能</strong>：无状态组件通常性能更好，因为它们不管理自己的状态，只根据 props 渲染 UI。</li>
<li><strong>优化</strong>：可以使用 <code>React.memo</code>（函数组件）来优化性能，避免不必要的渲染。</li>
</ul>
<p><strong>函数组件优化示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OptimizedStatelessFunctionComponent</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; count, onIncrement &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncrement&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. <strong>使用场景</strong></h3><h4 id="有状态组件-2"><a href="#有状态组件-2" class="headerlink" title="有状态组件"></a>有状态组件</h4><ul>
<li><strong>使用场景</strong>：需要管理内部状态的组件，例如表单、计数器、用户交互组件等。</li>
<li><strong>优点</strong>：适合需要频繁更新状态的场景，代码逻辑清晰，易于管理。</li>
</ul>
<h4 id="无状态组件-2"><a href="#无状态组件-2" class="headerlink" title="无状态组件"></a>无状态组件</h4><ul>
<li><strong>使用场景</strong>：不需要管理内部状态的组件，例如展示性组件、UI 组件等。</li>
<li><strong>优点</strong>：代码简洁，性能较好，易于复用和测试。</li>
</ul>
<h3 id="4-代码简洁性"><a href="#4-代码简洁性" class="headerlink" title="4. 代码简洁性"></a>4. <strong>代码简洁性</strong></h3><h4 id="有状态组件-3"><a href="#有状态组件-3" class="headerlink" title="有状态组件"></a>有状态组件</h4><ul>
<li><strong>代码复杂度</strong>：类组件的代码相对复杂，需要定义类、构造函数、<code>render</code> 方法等。</li>
<li><strong>函数组件</strong>：使用 Hooks 后，函数组件的代码简洁性有所提升，但仍然需要管理状态。</li>
</ul>
<h4 id="无状态组件-3"><a href="#无状态组件-3" class="headerlink" title="无状态组件"></a>无状态组件</h4><ul>
<li><strong>代码简洁度</strong>：无状态组件的代码通常更简洁，因为它们不需要管理状态，只需要根据 props 渲染 UI。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>有状态组件</th>
<th>无状态组件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>管理自己的状态</td>
<td>不管理自己的状态</td>
</tr>
<tr>
<td><strong>状态管理</strong></td>
<td>使用 <code>this.state</code> 或 <code>useState</code></td>
<td>状态由父组件或其他外部状态管理工具提供</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可能较差，需要优化</td>
<td>通常较好</td>
</tr>
<tr>
<td><strong>优化工具</strong></td>
<td><code>React.PureComponent</code> 或 <code>React.memo</code></td>
<td><code>React.memo</code></td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>需要管理内部状态的组件</td>
<td>不需要管理内部状态的组件</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>较复杂</td>
<td>较简洁</td>
</tr>
</tbody></table>
<p>通过合理选择和使用有状态组件和无状态组件，可以更有效地开发和维护 React 应用。</p>
<h2 id="宏任务和微任务-比如-promise-和-setTimeout-判断打印的结果"><a href="#宏任务和微任务-比如-promise-和-setTimeout-判断打印的结果" class="headerlink" title="宏任务和微任务,比如 promise 和 setTimeout 判断打印的结果"></a>宏任务和微任务,比如 promise 和 setTimeout 判断打印的结果</h2><p>好的，以下是一些关于 JavaScript 事件循环（Event Loop）、宏任务（macrotask）和微任务（microtask）的题目，涉及 <code>Promise</code> 和 <code>setTimeout</code> 的执行顺序。这些题目可以帮助你更好地理解事件循环的工作机制。</p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 1"></a>题目 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：请预测上述代码的输出顺序。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>Script start</li>
<li>Script end</li>
<li>Promise then</li>
<li>setTimeout</li>
</ol>
<p><strong>解析</strong>：</p>
<ul>
<li><code>setTimeout</code> 是宏任务，会被推入宏任务队列。</li>
<li><code>Promise.resolve().then</code> 是微任务，会被推入微任务队列。</li>
<li>事件循环先执行同步代码，然后执行微任务队列中的任务，最后执行宏任务队列中的任务。</li>
</ul>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 2"></a>题目 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 1&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 1&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 2&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 2&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：请预测上述代码的输出顺序。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>Script start</li>
<li>Script end</li>
<li>Promise then 2</li>
<li>setTimeout 1</li>
<li>Promise then 1</li>
<li>setTimeout 2</li>
</ol>
<p><strong>解析</strong>：</p>
<ul>
<li><code>setTimeout</code> 是宏任务，会被推入宏任务队列。</li>
<li><code>Promise.resolve().then</code> 是微任务，会被推入微任务队列。</li>
<li>事件循环先执行同步代码，然后执行微任务队列中的任务，最后执行宏任务队列中的任务。</li>
<li>在 <code>setTimeout 1</code> 的回调中，<code>Promise.then</code> 会生成一个新的微任务。</li>
<li>在 <code>Promise then 2</code> 的回调中，<code>setTimeout</code> 会生成一个新的宏任务。</li>
</ul>
<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目 3"></a>题目 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 1&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 2&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：请预测上述代码的输出顺序。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>Script start</li>
<li>Script end</li>
<li>Promise then 1</li>
<li>setTimeout 2</li>
<li>Promise then 2</li>
<li>setTimeout 1</li>
</ol>
<p><strong>解析</strong>：</p>
<ul>
<li><code>setTimeout</code> 是宏任务，会被推入宏任务队列。</li>
<li><code>Promise.resolve().then</code> 是微任务，会被推入微任务队列。</li>
<li>事件循环先执行同步代码，然后执行微任务队列中的任务，最后执行宏任务队列中的任务。</li>
<li>在 <code>Promise then 1</code> 的回调中，<code>setTimeout</code> 会生成一个新的宏任务。</li>
<li>在 <code>setTimeout 2</code> 的回调中，<code>Promise.then</code> 会生成一个新的微任务。</li>
</ul>
<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目 4"></a>题目 4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 1&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 1&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 2&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 2&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 3&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：请预测上述代码的输出顺序。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>Script start</li>
<li>Script end</li>
<li>Promise then 2</li>
<li>setTimeout 1</li>
<li>Promise then 1</li>
<li>setTimeout 3</li>
<li>Promise then 3</li>
<li>setTimeout 2</li>
</ol>
<p><strong>解析</strong>：</p>
<ul>
<li><code>setTimeout</code> 是宏任务，会被推入宏任务队列。</li>
<li><code>Promise.resolve().then</code> 是微任务，会被推入微任务队列。</li>
<li>事件循环先执行同步代码，然后执行微任务队列中的任务，最后执行宏任务队列中的任务。</li>
<li>在 <code>Promise then 2</code> 的回调中，<code>setTimeout</code> 会生成一个新的宏任务。</li>
<li>在 <code>setTimeout 1</code> 的回调中，<code>Promise.then</code> 会生成一个新的微任务。</li>
<li>在 <code>setTimeout 3</code> 的回调中，<code>Promise.then</code> 会生成一个新的微任务。</li>
</ul>
<h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目 5"></a>题目 5</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 1&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 2&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 1&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout 2&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise then 3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：请预测上述代码的输出顺序。</p>
<p><strong>答案</strong>：</p>
<ol>
<li>Script start</li>
<li>Script end</li>
<li>Promise then 1</li>
<li>Promise then 2</li>
<li>setTimeout 2</li>
<li>Promise then 3</li>
<li>setTimeout 1</li>
</ol>
<p><strong>解析</strong>：</p>
<ul>
<li><code>setTimeout</code> 是宏任务，会被推入宏任务队列。</li>
<li><code>Promise.resolve().then</code> 是微任务，会被推入微任务队列。</li>
<li>事件循环先执行同步代码，然后执行微任务队列中的任务，最后执行宏任务队列中的任务。</li>
<li>在 <code>Promise then 1</code> 的回调中，<code>Promise.then</code> 会生成一个新的微任务。</li>
<li>在 <code>Promise then 2</code> 的回调中，<code>setTimeout</code> 会生成一个新的宏任务。</li>
<li>在 <code>setTimeout 2</code> 的回调中，<code>Promise.then</code> 会生成一个新的微任务。</li>
</ul>
<p>通过这些题目，你可以更好地理解 JavaScript 事件循环的工作机制，以及 <code>Promise</code> 和 <code>setTimeout</code> 的执行顺序。</p>
<h2 id="英文的自我介绍，如何更好的融入团队？在团队中有冲突，如何处理？"><a href="#英文的自我介绍，如何更好的融入团队？在团队中有冲突，如何处理？" class="headerlink" title="英文的自我介绍，如何更好的融入团队？在团队中有冲突，如何处理？"></a>英文的自我介绍，如何更好的融入团队？在团队中有冲突，如何处理？</h2><h3 id="Self-Introduction-and-Team-Integration"><a href="#Self-Introduction-and-Team-Integration" class="headerlink" title="Self-Introduction and Team Integration"></a>Self-Introduction and Team Integration</h3><h4 id="Self-Introduction"><a href="#Self-Introduction" class="headerlink" title="Self-Introduction"></a>Self-Introduction</h4><p>Hey there! I’m [Your Name], a frontend developer with [X] years of experience. I love creating user-friendly and responsive web apps using modern tech like HTML5, CSS3, JavaScript, and frameworks such as React, Angular, and Vue.js. I’m also into web performance optimization and cross-browser compatibility, making sure the apps I build are fast and accessible.<br>I’m really interested in the latest frontend trends, like PWAs, SSR, and using TypeScript for better code quality. I know my way around build tools like Webpack and Babel, and I enjoy optimizing the build process to make development smoother.<br>In my last job at [Company Name], I worked on some high-impact projects, including [Project Name], where I was responsible for [specific responsibilities and achievements]. I’m excited to bring my skills and experience to your team and help make your projects a success.</p>
<h4 id="How-to-Better-Integrate-into-the-Team"><a href="#How-to-Better-Integrate-into-the-Team" class="headerlink" title="How to Better Integrate into the Team"></a>How to Better Integrate into the Team</h4><ul>
<li><strong>Open Communication</strong>: I’ll be honest and open with my team. I’ll join in on meetings, share my thoughts, and listen to others. This helps build trust and a collaborative vibe.</li>
<li><strong>Active Listening</strong>: I’ll try to understand the team’s goals and challenges. By listening closely to my colleagues, I can align my work with the team’s objectives and make meaningful contributions.</li>
<li><strong>Collaboration and Teamwork</strong>: I’ll work with team members on different projects, sharing my expertise and learning from others. A team is stronger when everyone works together and uses each other’s unique skills.</li>
<li><strong>Adaptability</strong>: Every team has its own way of doing things. I’ll be flexible and adjust my work style to fit in with the team’s processes and culture.</li>
<li><strong>Continuous Learning</strong>: I’m committed to learning and growing professionally. I’ll stay updated on the latest frontend tech and best practices, and I’ll share what I know through code reviews, workshops, and mentoring.</li>
<li><strong>Positive Attitude</strong>: I’ll keep a positive attitude and support my team members. A positive work environment is key for productivity and innovation.</li>
</ul>
<h4 id="Handling-Conflicts-in-the-Team"><a href="#Handling-Conflicts-in-the-Team" class="headerlink" title="Handling Conflicts in the Team"></a>Handling Conflicts in the Team</h4><p>Conflicts happen in teams, but they can be resolved with the right approach:</p>
<ul>
<li><strong>Stay Calm and Professional</strong>: When a conflict comes up, it’s important to stay calm and professional. Don’t react emotionally; focus on the issue rather than personal differences.</li>
<li><strong>Listen to All Perspectives</strong>: Make sure everyone involved in the conflict has a chance to speak. Active listening helps uncover the root of the problem and find a solution that everyone can agree on.</li>
<li><strong>Focus on the Issue, Not the Person</strong>: Keep the discussion focused on the specific issue, not on personal attacks. This helps maintain a respectful and productive dialogue.</li>
<li><strong>Collaborative Problem Solving</strong>: Work with the team to find a solution that addresses everyone’s concerns. Encourage open discussion and brainstorming to explore different options.</li>
<li><strong>Involve a Mediator if Necessary</strong>: If the conflict can’t be resolved within the team, consider bringing in a neutral third party, like a manager or HR representative, to help facilitate the resolution.</li>
<li><strong>Follow Up</strong>: After the conflict has been resolved, check in with the team members to make sure the solution is working and there are no lingering issues. This helps rebuild trust and keep the team environment positive.</li>
</ul>
<p>By following these strategies, I’m confident I can fit in well with the team and contribute to a positive and productive work environment. I’m looking forward to working with you all and growing together as a team.</p>
<h3 id="自我介绍与团队融合"><a href="#自我介绍与团队融合" class="headerlink" title="自我介绍与团队融合"></a>自我介绍与团队融合</h3><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>大家好！我是[你的名字]，拥有[X]年经验的前端开发者。我喜欢用HTML5、CSS3、JavaScript等现代技术，以及React、Angular和Vue.js等框架来创建用户友好且响应迅速的网页应用。我也热衷于网页性能优化和跨浏览器兼容性，确保我开发的应用既快速又易于访问。<br>我对前端开发的最新趋势非常感兴趣，比如渐进式网页应用（PWAs）、服务器端渲染（SSR），以及使用TypeScript来提升代码质量。我对Webpack和Babel等构建工具也颇为熟悉，并且喜欢优化构建流程，让开发更加顺畅。<br>在我之前于[公司名称]的工作中，我参与了一些影响力大的项目，其中包括[项目名称]，在那里我负责[具体的职责和成就]。我非常期待能将我的技能和经验带到你们的团队中，助力你们的项目取得成功。</p>
<h4 id="如何更好地融入团队"><a href="#如何更好地融入团队" class="headerlink" title="如何更好地融入团队"></a>如何更好地融入团队</h4><ul>
<li><strong>开放沟通</strong>：我会对团队保持诚实和开放。积极参与会议，分享我的想法，同时也认真倾听他人的意见。这有助于建立信任，营造协作的氛围。</li>
<li><strong>积极倾听</strong>：我会努力去理解团队的目标和挑战。通过仔细倾听同事们的看法，我能更好地将我的工作与团队的目标对齐，做出有意义的贡献。</li>
<li><strong>协作与团队合作</strong>：我会与团队成员共同参与不同项目，分享我的专业知识，同时向他人学习。当每个人都携手合作，发挥各自的独特技能时，团队才会更加强大。</li>
<li><strong>适应能力</strong>：每个团队都有自己的工作方式。我会保持灵活，调整自己的工作风格，以适应团队的流程和文化。</li>
<li><strong>持续学习</strong>：我致力于不断学习和专业成长。我会紧跟最新的前端技术动态和最佳实践，并通过代码审查、研讨会和指导等方式与团队分享我的知识。</li>
<li><strong>积极态度</strong>：我会保持积极的心态，支持我的团队成员。积极的工作环境对于提高生产力和创新能力至关重要。</li>
</ul>
<h4 id="处理团队中的冲突"><a href="#处理团队中的冲突" class="headerlink" title="处理团队中的冲突"></a>处理团队中的冲突</h4><p>冲突在团队中是正常的，但通过正确的方法可以有效解决：</p>
<ul>
<li><strong>保持冷静和专业</strong>：当冲突出现时，保持冷静和专业至关重要。不要情绪化，专注于问题本身，而不是个人差异。</li>
<li><strong>倾听所有观点</strong>：确保所有参与冲突的团队成员都有机会表达自己的看法。积极倾听有助于了解冲突的根源，并找到双方都能接受的解决方案。</li>
<li><strong>关注问题而非人</strong>：将讨论集中在具体问题上，而不是人身攻击。这有助于保持尊重和富有成效的对话。</li>
<li><strong>协作解决问题</strong>：与团队合作，寻找能够解决每个人关切的解决方案。鼓励开放讨论和头脑风暴，以探索不同的选择。</li>
<li><strong>必要时引入调解人</strong>：如果冲突无法在团队内部解决，可以考虑引入中立的第三方，如经理或人力资源代表，来帮助促进解决过程。</li>
<li><strong>后续跟进</strong>：在冲突解决后，与团队成员跟进，确保解决方案有效，并且没有遗留问题。这有助于重建信任，保持积极的团队环境。</li>
</ul>
<p>通过遵循这些策略，我相信我可以很好地融入团队，为创造一个积极和富有成效的工作环境做出贡献。我期待着与大家共同合作，共同成长。</p>
<h2 id="typescript-更多准备"><a href="#typescript-更多准备" class="headerlink" title="typescript 更多准备"></a>typescript 更多准备</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.337.search-card.all.click&vd_source=ffda878df0ed45bee1ade91d8f451048">https://www.bilibili.com/video/BV1wR4y1377K/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ffda878df0ed45bee1ade91d8f451048</a></p>
<h2 id="react-更多的基础"><a href="#react-更多的基础" class="headerlink" title="react 更多的基础"></a>react 更多的基础</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZB4y1Z7o8?spm_id_from=333.788.videopod.episodes&vd_source=ffda878df0ed45bee1ade91d8f451048&p=2">https://www.bilibili.com/video/BV1ZB4y1Z7o8?spm_id_from=333.788.videopod.episodes&amp;vd_source=ffda878df0ed45bee1ade91d8f451048&amp;p=2</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/boh5/itheima-learn-react18">https://github.com/boh5/itheima-learn-react18</a></p>
<h2 id="react-面试题"><a href="#react-面试题" class="headerlink" title="react 面试题"></a>react 面试题</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yw1FYrExD/?spm_id_from=333.337.search-card.all.click&vd_source=ffda878df0ed45bee1ade91d8f451048">https://www.bilibili.com/video/BV1Yw1FYrExD/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ffda878df0ed45bee1ade91d8f451048</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xjrrYBEeB/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1xjrrYBEeB/?spm_id_from=333.337.search-card.all.click</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1WxCGYdEjN/?spm_id_from=333.337.search-card.all.click&vd_source=ffda878df0ed45bee1ade91d8f451048">https://www.bilibili.com/video/BV1WxCGYdEjN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ffda878df0ed45bee1ade91d8f451048</a></p>
<h2 id="如何理解react-中的副作用"><a href="#如何理解react-中的副作用" class="headerlink" title="如何理解react 中的副作用"></a>如何理解react 中的副作用</h2><p>在 React 中，副作用（Side Effects）是指在组件渲染过程中或渲染之后执行的一些操作，这些操作会对外部环境产生影响，或者依赖于组件的渲染过程。</p>
<h3 id="1-为什么会有副作用"><a href="#1-为什么会有副作用" class="headerlink" title="1. 为什么会有副作用"></a>1. 为什么会有副作用</h3><p>React 的核心理念是通过 <code>state</code> 和 <code>props</code> 来驱动 UI 的更新，组件的渲染过程是纯函数性的，也就是说，组件的输出应该只依赖于输入的 <code>props</code> 和内部的 <code>state</code>。然而，在实际开发中，我们经常会遇到一些需要与外部环境交互的操作，比如：</p>
<ul>
<li>数据获取（从服务器获取数据）</li>
<li>DOM 操作（直接操作 DOM 元素）</li>
<li>订阅事件（比如订阅一个全局事件）</li>
<li>设置定时器</li>
<li>打印日志</li>
</ul>
<p>这些操作不能直接放在组件的渲染逻辑中，因为它们可能会导致以下问题：</p>
<ul>
<li>渲染过程变得不可预测</li>
<li>组件的纯函数特性被破坏</li>
<li>可能会导致性能问题</li>
<li>可能会引发内存泄漏</li>
</ul>
<p>为了解决这些问题，React 提供了专门的机制来处理副作用。</p>
<h3 id="2-React-中处理副作用的方式"><a href="#2-React-中处理副作用的方式" class="headerlink" title="2. React 中处理副作用的方式"></a>2. React 中处理副作用的方式</h3><p>在 React 中，处理副作用主要有以下几种方式：</p>
<h4 id="（1）componentDidMount-和-componentDidUpdate"><a href="#（1）componentDidMount-和-componentDidUpdate" class="headerlink" title="（1）componentDidMount 和 componentDidUpdate"></a>（1）<code>componentDidMount</code> 和 <code>componentDidUpdate</code></h4><p>在类组件中，<code>componentDidMount</code> 和 <code>componentDidUpdate</code> 是两个生命周期方法，用于处理副作用。</p>
<ul>
<li><code>componentDidMount</code>：在组件挂载完成后调用，适合处理初始化的副作用，比如数据获取、订阅事件等。</li>
<li><code>componentDidUpdate</code>：在组件更新完成后调用，适合处理更新相关的副作用，比如根据新 <code>props</code> 更新 DOM。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化副作用，比如获取数据</span></span><br><span class="line">    <span class="title function_">fetch_data</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新相关的副作用</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.<span class="property">someValue</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">someValue</span>) &#123;</span><br><span class="line">      <span class="title function_">update_DOM</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）useEffect"><a href="#（2）useEffect" class="headerlink" title="（2）useEffect"></a>（2）<code>useEffect</code></h4><p>在函数组件中，<code>useEffect</code> 是一个 Hook，用于处理副作用。它可以在组件挂载、更新和卸载时执行特定的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 副作用代码</span></span><br><span class="line">    <span class="title function_">fetch_data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个清理函数（可选）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [props.<span class="property">someValue</span>]); <span class="comment">// 依赖数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>useEffect</code> 的第一个参数是一个函数，用于定义副作用。</li>
<li>第二个参数是一个依赖数组，用于指定在哪些 <code>props</code> 或 <code>state</code> 变化时重新执行副作用。如果依赖数组为空（<code>[]</code>），则只在组件挂载和卸载时执行。</li>
<li><code>useEffect</code> 返回的函数是可选的，用于在组件卸载或重新执行副作用之前清理上一次的副作用。</li>
</ul>
<h3 id="3-副作用的特点"><a href="#3-副作用的特点" class="headerlink" title="3. 副作用的特点"></a>3. 副作用的特点</h3><h4 id="（1）异步执行"><a href="#（1）异步执行" class="headerlink" title="（1）异步执行"></a>（1）异步执行</h4><p><code>useEffect</code> 中的副作用代码是异步执行的，它不会阻塞浏览器的渲染过程。这是为了确保用户体验的流畅性。</p>
<h4 id="（2）依赖管理"><a href="#（2）依赖管理" class="headerlink" title="（2）依赖管理"></a>（2）依赖管理</h4><p><code>useEffect</code> 通过依赖数组来管理副作用的触发条件，这使得副作用的执行更加可控。</p>
<h4 id="（3）清理机制"><a href="#（3）清理机制" class="headerlink" title="（3）清理机制"></a>（3）清理机制</h4><p><code>useEffect</code> 提供了一个清理机制，可以在组件卸载或重新执行副作用之前清理上一次的副作用，避免内存泄漏。</p>
<h3 id="4-副作用的常见场景"><a href="#4-副作用的常见场景" class="headerlink" title="4. 副作用的常见场景"></a>4. 副作用的常见场景</h3><h4 id="（1）数据获取"><a href="#（1）数据获取" class="headerlink" title="（1）数据获取"></a>（1）数据获取</h4><p>在组件挂载或更新时，从服务器获取数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h4 id="（2）DOM-操作"><a href="#（2）DOM-操作" class="headerlink" title="（2）DOM 操作"></a>（2）DOM 操作</h4><p>在组件挂载或更新后，直接操作 DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-element&#x27;</span>);</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h4 id="（3）订阅事件"><a href="#（3）订阅事件" class="headerlink" title="（3）订阅事件"></a>（3）订阅事件</h4><p>在组件挂载时订阅一个全局事件，并在组件卸载时取消订阅。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Window resized&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h4 id="（4）设置定时器"><a href="#（4）设置定时器" class="headerlink" title="（4）设置定时器"></a>（4）设置定时器</h4><p>在组件挂载时设置一个定时器，并在组件卸载时清除定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Timer tick&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>副作用是 React 中不可避免的一部分，但需要谨慎处理。</li>
<li>类组件通过生命周期方法（<code>componentDidMount</code> 和 <code>componentDidUpdate</code>）处理副作用。</li>
<li>函数组件通过 <code>useEffect</code> Hook 处理副作用。</li>
<li><code>useEffect</code> 提供了依赖管理和清理机制，使得副作用的处理更加灵活和安全。</li>
<li>副作用的异步执行特性确保了渲染过程的流畅性。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%87%86%E5%A4%87/" rel="tag"># 准备</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/24/%E4%B8%AD%E6%96%87%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%EF%BC%88%E6%9C%97%E8%AF%BB%EF%BC%8C%E6%8B%BC%E9%9F%B3%EF%BC%8C%E7%BB%84%E8%AF%8D%EF%BC%8C%E6%89%8B%E5%86%99%EF%BC%8C%E7%AC%94%E7%94%BB%EF%BC%89-%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/" rel="prev" title="中文文字处理（朗读，拼音，组词，手写，笔画）+ 文字识别">
      <i class="fa fa-chevron-left"></i> 中文文字处理（朗读，拼音，组词，手写，笔画）+ 文字识别
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/03/05/%E5%87%86%E5%A4%871/" rel="next" title="准备1">
      准备1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#h5%E6%9E%B6%E6%9E%84%E5%8D%87%E7%BA%A7"><span class="nav-number">1.</span> <span class="nav-text">h5架构升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">统一组件库：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E7%BB%84%E4%BB%B6%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">业务组件输出：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSbridge"><span class="nav-number">3.</span> <span class="nav-text">JSbridge:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">性能优化：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-number">5.</span> <span class="nav-text">调试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">6.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventLoop"><span class="nav-number">7.</span> <span class="nav-text">EventLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MutationObserver"><span class="nav-number">8.</span> <span class="nav-text">MutationObserver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-ajax-%E7%9A%84-%E5%B5%8C%E5%A5%97%E5%99%A9%E6%A2%A6"><span class="nav-number">9.</span> <span class="nav-text">Promise 如何解决 ajax 的 嵌套噩梦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-3-%E7%9A%84-Composition-API-%E5%A6%82%E4%BD%95%E6%9B%BF%E4%BB%A3-mixin"><span class="nav-number">10.</span> <span class="nav-text">Vue 3 的 Composition API 如何替代 mixin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%A6%82%E4%BD%95%E6%9B%BF%E4%BB%A3mixin"><span class="nav-number">11.</span> <span class="nav-text">插件如何替代mixin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88HOC%EF%BC%89%E5%A6%82%E4%BD%95%E6%9B%BF%E4%BB%A3mixin"><span class="nav-number">12.</span> <span class="nav-text">高阶组件（HOC）如何替代mixin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="nav-number">13.</span> <span class="nav-text">节流和防抖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">14.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">15.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-number">15.1.</span> <span class="nav-text">JavaScript 继承模式对比表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-in-%E5%92%8C-for-of-%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">for in 和 for of 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-await-of-%E7%94%A8%E6%B3%95"><span class="nav-number">17.</span> <span class="nav-text">for await of 用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTMLCollection%E5%92%8CNodeList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">HTMLCollection和NodeList有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">严格模式和普通模式的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#options-%E8%AF%B7%E6%B1%82"><span class="nav-number">20.</span> <span class="nav-text">options 请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OPTIONS-%E8%AF%B7%E6%B1%82%E5%9C%A8%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%B8%AD%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">OPTIONS 请求在跨域请求中会影响性能吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2-%E5%92%8C-vue3-%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">vue2 和 vue3 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%AF%B9-Tree-Shaking-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">23.</span> <span class="nav-text">vue3 如何实现的 对 Tree Shaking 的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3-%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99%E4%BA%86%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84-diff-%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BC%98%E5%8C%96%E4%BA%86%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD"><span class="nav-number">24.</span> <span class="nav-text">vue3 如何重写了虚拟 DOM 的 diff 算法，优化了渲染性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#createApp-%E5%92%8C-new-Vue-%E5%AF%B9%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">createApp 和 new Vue 对比有什么好处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E5%B1%8F%E9%80%9F%E5%BA%A6"><span class="nav-number">26.</span> <span class="nav-text">首屏速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="nav-number">27.</span> <span class="nav-text">js 深拷贝有哪些方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JSON-%E6%96%B9%E6%B3%95"><span class="nav-number">27.1.</span> <span class="nav-text">1. JSON 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">27.2.</span> <span class="nav-text">2. 递归实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-structuredClone"><span class="nav-number">27.3.</span> <span class="nav-text">3. 使用 structuredClone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8%E5%BA%93"><span class="nav-number">27.4.</span> <span class="nav-text">4. 使用库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">27.5.</span> <span class="nav-text">5. 其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">27.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typescript-%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%9E%8B-type-%E6%88%96%E8%80%85-interface-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8E%9F%E6%9C%89%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="nav-number">28.</span> <span class="nav-text">typescript 定义对象型 type 或者 interface 的时候，如何在原有定义的结构中删除一个属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Omit-%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">28.1.</span> <span class="nav-text">使用 Omit 删除属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">28.1.1.</span> <span class="nav-text">1. 定义原始类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-Omit-%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">28.1.2.</span> <span class="nav-text">2. 使用 Omit 删除属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0-Omit"><span class="nav-number">28.2.</span> <span class="nav-text">自定义实现 Omit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">28.3.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">28.3.1.</span> <span class="nav-text">1. 定义原始类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89-Omit-%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">28.3.2.</span> <span class="nav-text">2. 使用自定义 Omit 删除属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">28.4.</span> <span class="nav-text">其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-Pick-%E5%92%8C-Exclude"><span class="nav-number">28.4.1.</span> <span class="nav-text">1. 使用 Pick 和 Exclude</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-Record"><span class="nav-number">28.4.2.</span> <span class="nav-text">2. 使用 Record</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">28.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-hooks-%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9Bhooks%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9Fhooks%E5%AF%B9%E5%BA%94%E4%B9%8B%E5%89%8Dreact%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">react hooks 的好处是什么？用过哪些hooks，分别说明什么场景下使用？hooks对应之前react的生命周期？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Hooks-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">29.1.</span> <span class="nav-text">React Hooks 的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-Hooks-%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">29.2.</span> <span class="nav-text">常用的 Hooks 及其使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useState"><span class="nav-number">29.2.1.</span> <span class="nav-text">1. useState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useEffect"><span class="nav-number">29.2.2.</span> <span class="nav-text">2. useEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-useContext"><span class="nav-number">29.2.3.</span> <span class="nav-text">3. useContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-useReducer"><span class="nav-number">29.2.4.</span> <span class="nav-text">4. useReducer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-useRef"><span class="nav-number">29.2.5.</span> <span class="nav-text">5. useRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-useMemo"><span class="nav-number">29.2.6.</span> <span class="nav-text">6. useMemo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-useCallback"><span class="nav-number">29.2.7.</span> <span class="nav-text">7. useCallback</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hooks-%E4%B8%8E-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">29.3.</span> <span class="nav-text">Hooks 与 React 生命周期的对应关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-useEffect"><span class="nav-number">29.3.1.</span> <span class="nav-text">1. useEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-useState"><span class="nav-number">29.3.2.</span> <span class="nav-text">2. useState</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-useContext-1"><span class="nav-number">29.3.3.</span> <span class="nav-text">3. useContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-useReducer-1"><span class="nav-number">29.3.4.</span> <span class="nav-text">4. useReducer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-useRef-1"><span class="nav-number">29.3.5.</span> <span class="nav-text">5. useRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-useMemo-%E5%92%8C-useCallback"><span class="nav-number">29.3.6.</span> <span class="nav-text">6. useMemo 和 useCallback</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useReducer-%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%92%8Credux%E4%B8%AD%E7%9A%84reducer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9Fredux%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E3%80%82"><span class="nav-number">30.</span> <span class="nav-text">useReducer 的使用，和redux中的reducer有什么区别？redux的相关使用方式。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#useReducer-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E-Redux-%E4%B8%AD%E7%9A%84-reducer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.1.</span> <span class="nav-text">useReducer 的使用与 Redux 中的 reducer 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useReducer-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">30.1.1.</span> <span class="nav-text">useReducer 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redux-%E4%B8%AD%E7%9A%84-reducer"><span class="nav-number">30.1.2.</span> <span class="nav-text">Redux 中的 reducer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#useReducer-%E4%B8%8E-Redux-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.2.</span> <span class="nav-text">useReducer 与 Redux 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redux-%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">30.3.</span> <span class="nav-text">Redux 的相关使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85-Redux-%E5%92%8C-React-Redux"><span class="nav-number">30.3.1.</span> <span class="nav-text">1. 安装 Redux 和 React-Redux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89-Reducer"><span class="nav-number">30.3.2.</span> <span class="nav-text">2. 定义 Reducer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA-Store"><span class="nav-number">30.3.3.</span> <span class="nav-text">3. 创建 Store</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%9C%A8%E6%A0%B9%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BE%9B-Store"><span class="nav-number">30.3.4.</span> <span class="nav-text">4. 在根组件中提供 Store</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-Redux"><span class="nav-number">30.3.5.</span> <span class="nav-text">5. 在组件中使用 Redux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%BD%BF%E7%94%A8-Middleware"><span class="nav-number">30.3.6.</span> <span class="nav-text">6. 使用 Middleware</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">30.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9-react%E5%81%9A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">如何对 react做性能优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%84%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="nav-number">31.1.</span> <span class="nav-text">1. 组件优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-React-memo-%E5%92%8C-useMemo"><span class="nav-number">31.1.1.</span> <span class="nav-text">使用 React.memo 和 useMemo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-useCallback"><span class="nav-number">31.1.2.</span> <span class="nav-text">使用 useCallback</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="nav-number">31.2.</span> <span class="nav-text">2. 渲染优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-number">31.2.1.</span> <span class="nav-text">虚拟化技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="nav-number">31.2.2.</span> <span class="nav-text">懒加载与按需加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96"><span class="nav-number">31.3.</span> <span class="nav-text">3. 数据管理优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Redux-%E6%88%96-Context-API"><span class="nav-number">31.3.1.</span> <span class="nav-text">使用 Redux 或 Context API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96"><span class="nav-number">31.4.</span> <span class="nav-text">4. 构建优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Webpack-%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85"><span class="nav-number">31.4.1.</span> <span class="nav-text">使用 Webpack 优化打包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-webpack-bundle-analyzer"><span class="nav-number">31.4.2.</span> <span class="nav-text">使用 webpack-bundle-analyzer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">31.5.</span> <span class="nav-text">5. 性能分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-React-DevTools-%E5%92%8C-Chrome-DevTools"><span class="nav-number">31.5.1.</span> <span class="nav-text">使用 React DevTools 和 Chrome DevTools</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">31.6.</span> <span class="nav-text">6. 其他优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%88%97%E8%A1%A8%E9%A1%B9%E6%B7%BB%E5%8A%A0%E5%94%AF%E4%B8%80-key-%E5%B1%9E%E6%80%A7"><span class="nav-number">31.6.1.</span> <span class="nav-text">为列表项添加唯一 key 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%9C%A8-render-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">31.6.2.</span> <span class="nav-text">避免在 render 函数中直接定义函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8-React-Query-%E8%BF%9B%E8%A1%8C%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="nav-number">31.7.</span> <span class="nav-text">7. 使用 React Query 进行高效的数据获取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-memo-useMemo-useCallback%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">react.memo,useMemo,useCallback的使用场景和区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-react-memo"><span class="nav-number">32.1.</span> <span class="nav-text">1. react.memo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">32.1.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">32.1.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-useMemo"><span class="nav-number">32.2.</span> <span class="nav-text">2. useMemo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">32.2.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">32.2.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-useCallback"><span class="nav-number">32.3.</span> <span class="nav-text">3. useCallback</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">32.3.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">32.3.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">32.3.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">32.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">类组件和函数组件的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AF%AD%E6%B3%95%E5%92%8C%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="nav-number">33.1.</span> <span class="nav-text">1. 语法和定义方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="nav-number">33.1.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="nav-number">33.1.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">33.2.</span> <span class="nav-text">2. 状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-1"><span class="nav-number">33.2.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-1"><span class="nav-number">33.2.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="nav-number">33.3.</span> <span class="nav-text">3. 生命周期方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-2"><span class="nav-number">33.3.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-2"><span class="nav-number">33.3.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">33.4.</span> <span class="nav-text">4. 性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-3"><span class="nav-number">33.4.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-3"><span class="nav-number">33.4.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Hooks-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">33.5.</span> <span class="nav-text">5. Hooks 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-4"><span class="nav-number">33.5.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-4"><span class="nav-number">33.5.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E6%80%A7"><span class="nav-number">33.6.</span> <span class="nav-text">6. 代码简洁性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-5"><span class="nav-number">33.6.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-5"><span class="nav-number">33.6.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">33.7.</span> <span class="nav-text">7. 使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-6"><span class="nav-number">33.7.1.</span> <span class="nav-text">类组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-6"><span class="nav-number">33.7.2.</span> <span class="nav-text">函数组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">33.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">有状态组件和无状态组件的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">34.1.</span> <span class="nav-text">1. 定义和状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">34.1.1.</span> <span class="nav-text">有状态组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">34.1.2.</span> <span class="nav-text">无状态组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%80%A7%E8%83%BD"><span class="nav-number">34.2.</span> <span class="nav-text">2. 性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6-1"><span class="nav-number">34.2.1.</span> <span class="nav-text">有状态组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6-1"><span class="nav-number">34.2.2.</span> <span class="nav-text">无状态组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">34.3.</span> <span class="nav-text">3. 使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6-2"><span class="nav-number">34.3.1.</span> <span class="nav-text">有状态组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6-2"><span class="nav-number">34.3.2.</span> <span class="nav-text">无状态组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E6%80%A7"><span class="nav-number">34.4.</span> <span class="nav-text">4. 代码简洁性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6-3"><span class="nav-number">34.4.1.</span> <span class="nav-text">有状态组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6-3"><span class="nav-number">34.4.2.</span> <span class="nav-text">无状态组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">34.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E6%AF%94%E5%A6%82-promise-%E5%92%8C-setTimeout-%E5%88%A4%E6%96%AD%E6%89%93%E5%8D%B0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">35.</span> <span class="nav-text">宏任务和微任务,比如 promise 和 setTimeout 判断打印的结果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-number">35.1.</span> <span class="nav-text">题目 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-number">35.2.</span> <span class="nav-text">题目 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-number">35.3.</span> <span class="nav-text">题目 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-number">35.4.</span> <span class="nav-text">题目 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-number">35.5.</span> <span class="nav-text">题目 5</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%B1%E6%96%87%E7%9A%84%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%9E%8D%E5%85%A5%E5%9B%A2%E9%98%9F%EF%BC%9F%E5%9C%A8%E5%9B%A2%E9%98%9F%E4%B8%AD%E6%9C%89%E5%86%B2%E7%AA%81%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">英文的自我介绍，如何更好的融入团队？在团队中有冲突，如何处理？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Self-Introduction-and-Team-Integration"><span class="nav-number">36.1.</span> <span class="nav-text">Self-Introduction and Team Integration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Self-Introduction"><span class="nav-number">36.1.1.</span> <span class="nav-text">Self-Introduction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-to-Better-Integrate-into-the-Team"><span class="nav-number">36.1.2.</span> <span class="nav-text">How to Better Integrate into the Team</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling-Conflicts-in-the-Team"><span class="nav-number">36.1.3.</span> <span class="nav-text">Handling Conflicts in the Team</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9B%A2%E9%98%9F%E8%9E%8D%E5%90%88"><span class="nav-number">36.2.</span> <span class="nav-text">自我介绍与团队融合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">36.2.1.</span> <span class="nav-text">自我介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E8%9E%8D%E5%85%A5%E5%9B%A2%E9%98%9F"><span class="nav-number">36.2.2.</span> <span class="nav-text">如何更好地融入团队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%9B%A2%E9%98%9F%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81"><span class="nav-number">36.2.3.</span> <span class="nav-text">处理团队中的冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typescript-%E6%9B%B4%E5%A4%9A%E5%87%86%E5%A4%87"><span class="nav-number">37.</span> <span class="nav-text">typescript 更多准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">38.</span> <span class="nav-text">react 更多的基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">39.</span> <span class="nav-text">react 面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3react-%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">40.</span> <span class="nav-text">如何理解react 中的副作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">40.1.</span> <span class="nav-text">1. 为什么会有副作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-React-%E4%B8%AD%E5%A4%84%E7%90%86%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">40.2.</span> <span class="nav-text">2. React 中处理副作用的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89componentDidMount-%E5%92%8C-componentDidUpdate"><span class="nav-number">40.2.1.</span> <span class="nav-text">（1）componentDidMount 和 componentDidUpdate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89useEffect"><span class="nav-number">40.2.2.</span> <span class="nav-text">（2）useEffect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">40.3.</span> <span class="nav-text">3. 副作用的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C"><span class="nav-number">40.3.1.</span> <span class="nav-text">（1）异步执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="nav-number">40.3.2.</span> <span class="nav-text">（2）依赖管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">40.3.3.</span> <span class="nav-text">（3）清理机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="nav-number">40.4.</span> <span class="nav-text">4. 副作用的常见场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="nav-number">40.4.1.</span> <span class="nav-text">（1）数据获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89DOM-%E6%93%8D%E4%BD%9C"><span class="nav-number">40.4.2.</span> <span class="nav-text">（2）DOM 操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6"><span class="nav-number">40.4.3.</span> <span class="nav-text">（3）订阅事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">40.4.4.</span> <span class="nav-text">（4）设置定时器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-number">40.5.</span> <span class="nav-text">5. 总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzhiwei</p>
  <div class="site-description" itemprop="description">javascript nodejs web developer...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangzhiwei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
