---
title: 准备
date: 2025-02-26 13:08:00
tags: 准备
categories: 准备
---

## h5架构升级


## 统一组件库：

vant-ui
https://vant-ui.github.io/vant/#/zh-CN/home


### 业务组件输出：



## JSbridge:


```


URL Schema
window.location.href = "myapp://action?param=value";

注入 JS API
原生应用将自身功能注入到 JavaScript 上下文中，Web 页面可以直接调用这些方法。

Android 示例

webView.addJavascriptInterface(new NativeBridge(this), "NativeBridge");

iOS 示例

webView.configuration.userContentController.addScriptMessageHandler(self, name: "callbackHandler");

window.JsBridge.receiveDataFromApp(data);


回调机制
window.WebViewJavascriptBridge.send(data, function(responseData) {
    // 处理原生回传的数据
});



```

## 性能优化：

性能优化：
资源加载优化：将资源按场景划分，仅加载当前场景所需资源，减少首次加载时间。
文件压缩与合并：
静态资源缓存：本地缓存，减少网络请求次数，提高性能。
CDN加速：使用CDN加速静态资源的加载，提高访问速度。
图片格式选择：选择合适的图片格式，如WebP、AVIF等，减少文件大小。
渲染优化：

接口数据缓存，优先读取缓存数据，

gzip

高频事件（如 scroll、touchmove）应该进行优化，使用函数防抖和函数节流等技术来限制它们的执行频率。
CSS3 动画比 setTimeout 更加高效，应尽可能地使用 requestAnimationFrame 动画。
DOM 结点过多会降低页面的渲染性能，因此应尽量减少 DOM 结点的数量。

https://www.cnblogs.com/weichen913/p/18173518



## 调试工具 

charles 、lightproxy

devtools-remote-debugger

![](../images/f_01.png)



## 其他

```
跨域的几种方式
    jsonp cors 代理

webpack原理

Webpack 的核心思想是一切皆模块。无论是 JavaScript 文件、CSS 文件、图片资源，还是其他静态资源，都可以被当作模块来处理。Webpack 通过模块解析器（loader）和插件（plugin）来处理这些模块。


Webpack 的打包流程可以总结为以下步骤：
读取配置文件：
Webpack 读取 webpack.config.js 或 webpack.config.ts 文件，获取入口文件、输出路径、loader 和 plugin 等配置信息。
解析模块依赖：
从入口文件开始，递归解析模块依赖，构建模块依赖图。
应用 Loader：
根据配置，对模块应用相应的 loader 进行转换。
应用 Plugin：
在打包的各个生命周期阶段，执行 plugin 的逻辑。
生成输出文件：
根据模块依赖图，将所有模块打包成一个或多个输出文件（bundle）。
将输出文件写入到配置的输出路径。



vite 原理

其主要利用浏览器ESM特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。

https://juejin.cn/post/7064853960636989454

v-if 和 v-for能不能一起使用

可以 不建议一起使用

v-if 和 v-for 的优先级：v-for 的优先级高于 v-if，这意味着 v-if 的条件判断是在每次循环迭代中独立执行的。

<div v-for="item in filteredItems" :key="item.id">
  {{ item.name }}
</div>

computed: {
  filteredItems() {
    return this.items.filter(item => item.isVisible);
  }
}


data 为什么要用函数返回

    确保每个组件实例有独立的数据作用域
    防止数据在不同实例之间共享和污染
    提高组件的可复用性和安全性

nextticket

    Vue 的响应式系统是异步更新 DOM 的。当数据发生变化时，Vue 不会立即更新 DOM，而是将更新任务放入一个队列中，在下一个事件循环中统一处理。这种机制可以优化性能，但有时会导致开发者在数据更新后立即操作 DOM 时，无法获取到更新后的 DOM。
    nextTick 的作用是将回调函数延迟到 DOM 更新完成后再执行，从而确保开发者可以在回调中获取到最新的 DOM。

箭头函数和普通函数的区别
https://www.php.cn/faq/607823.html

    1、
    普通函数的 this 是动态的，取决于调用方式。
    箭头函数的 this 是静态的，取决于定义时的上下文。
    2、
    普通函数会绑定 arguments 对象，它是一个类似数组的对象，包含函数调用时传递的所有参数。
    箭头函数不绑定 arguments 对象，但可以通过参数数组解构来替代。
    3、普通函数可以通过 new 关键字被实例化为对象，而箭头函数不能被用作构造函数。
    4、普通函数可以使用 super 关键字来调用父类的方法，而箭头函数不能使用 super。
    5、普通函数可以使用 yield 关键字来实现生成器函数，而箭头函数不能使用 yield。

mix混入的优缺点

    优点：代码复用、解耦和模块化、易于维护。
    缺点：可能导致命名冲突、代码可读性降低、维护成本增加。
    替代方案：
        1、Vue 3 的 Composition API
        2、插件
        3、高阶组件（HOC）


promise几种状态 原理 

    Promise 有三种主要状态（State）
    Pending（进行中）：
    Fulfilled（已成功）：
    Rejected（已失败）：

    Promise 的工作原理基于 事件循环和微任务队列 ，确保异步操作的结果可以被高效地处理。


vue的组件的生命周期



| 阶段         | Vue 2 钩子                    | Vue 3 钩子                    | Composition API 钩子         |
|--------------|-------------------------------|-------------------------------|------------------------------|
| 创建         | beforeCreate<br>created       | beforeCreate<br>created       | setup                        |
| 挂载         | beforeMount<br>mounted        | beforeMount<br>mounted        | onBeforeMount<br>onMounted   |
| 更新         | beforeUpdate<br>updated       | beforeUpdate<br>updated       | onBeforeUpdate<br>onUpdated  |
| 销毁         | beforeDestroy<br>destroyed    | beforeUnmount<br>unmounted    | onBeforeUnmount<br>onUnmounted |


ajax在那个生命周期调用 create


history 和hash 是如何实现的

    https://baijiahao.baidu.com/s?id=1769914711262583821&wfr=spider&for=pc
    window.addEventListener("hashchange",funcRef,false)
    利用HTML5 History Interface 中新增的pushState()和replaceState()

    window.addEventListener('popstate', function(event) {
        console.log('URL changed:', window.location.pathname);
        // 在这里处理路由变化
    });

vue几种通信方式

1、props $emit触发事件
2、vuex
3、Provide / Injec
4、$refs defineExpose({ save, getConfig, getTempAttrsList })
5、Event Bus: 创建一个事件中心，通过它来发送和监听事件，解耦了组件之间的通信。

// event-bus.js
import Vue from 'vue';
export const EventBus = new Vue();

const handler = (data) => {
  console.log(data.message);
};

EventBus.$on('update', handler);
EventBus.$off('update', handler); // 移除监听器

EventBus.$emit('update', { message: 'Hello, World!' });


```


## EventLoop 

```

事件循环的主要工作是协调调用栈、微任务队列和宏任务队列之间的任务执行。其工作流程：

执行主线程代码：
    JavaScript 代码从上到下执行，函数调用会被压入调用栈。
    当调用栈为空时，表示主线程代码执行完毕。
处理微任务队列：
    在每次主线程代码执行完毕后，事件循环会检查微任务队列。
    如果微任务队列中有任务，事件循环会依次执行这些任务，直到微任务队列为空。
处理宏任务队列：
    在微任务队列执行完毕后，事件循环会检查宏任务队列。
    如果宏任务队列中有任务，事件循环会取出一个任务并执行。
重复上述过程：
    事件循环会不断重复上述过程，直到所有任务队列都为空。

常见的微任务包括：Promise、MutationObserver、process.nextTick（Node.js）。
常见的宏任务包括：setTimeout、setInterval、I/O 操作、MessageChannel。



```


## Promise 如何解决 ajax 的 嵌套噩梦


```
function fetchData() {
  return new Promise((resolve, reject) => {
    $.ajax({
      url: "/api/data",
      success: function(data) {
        resolve(data); // 成功时调用 resolve
      },
      error: function(err) {
        reject(err); // 失败时调用 reject
      }
    });
  });
}

function processData(data) {
  return new Promise((resolve, reject) => {
    $.ajax({
      url: "/api/process",
      data: { input: data },
      success: function(result) {
        resolve(result); // 成功时调用 resolve
      },
      error: function(err) {
        reject(err); // 失败时调用 reject
      }
    });
  });
}

通过将异步操作封装为 Promise，可以使用链式调用来处理多个异步操作，避免嵌套回调：


fetchData()
  .then(data => {
    console.log("Fetched data:", data);
    return processData(data); // 返回下一个 Promise
  })
  .then(result => {
    console.log("Processed result:", result);
    return displayResult(result); // 可以继续链式调用
  })
  .catch(err => {
    console.error("Error:", err); // 统一处理错误
  });


现在可以使用 async/await 进一步简化



```



## Vue 3 的 Composition API 如何替代 mixin


1. 使用自定义组合函数（Composables）

```
Composition API 的核心思想是通过自定义组合函数（Composables）来封装和复用逻辑。这些函数通常以 use 开头，类似于 React 中的 Hooks


示例：封装计数器逻辑

// useCounter.js
import { ref } from 'vue';

export function useCounter() {
  const count = ref(0);
  const increment = () => count.value++;
  return { count, increment };
}



// MyComponent.vue
<script setup>
import { useCounter } from './useCounter';

const { count, increment } = useCounter();
</script>

<template>
  <div>
    <p>{{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

这种方式避免了 Mixin 中常见的命名冲突问题，并且逻辑更加清晰

```

2. 全局逻辑复用


```

// globalComposables.js
import { ref } from 'vue';

export function useGlobalLogic() {
  const globalData = ref('Global data');
  return { globalData };
}


<script setup>
import { useGlobalLogic } from './globalComposables';

const { globalData } = useGlobalLogic();
</script>

```

3、状态管理

```
对于更复杂的状态管理，可以使用 Vuex 或 Pinia 等状态管理库。这些库与 Composition API 配合得很好，提供了更强大的功能。

// store.js
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
  state: () => ({ counter: 0 }),
  actions: { increment() { this.counter++; } }
});


<script setup>
import { useCounterStore } from './store';
import { computed } from 'vue';

const store = useCounterStore();
const counter = computed(() => store.counter);
const incrementCounter = () => store.increment();
</script>

Composition API 的优势：
更好的逻辑复用
更灵活的代码组织
更好的 TypeScript 支持
更细粒度的逻辑控制


```

## 插件如何替代mixin


```

// myPlugin.js
export default {
  install(Vue) {
    // 添加全局方法
    Vue.prototype.$myPluginMethod = function() {
      console.log('This is a plugin method');
    };

    // 添加自定义指令
    Vue.directive('my-directive', {
      bind(el, binding) {
        el.style.color = binding.value || 'red';
      }
    });
  }
};


// main.js
import { createApp } from 'vue';
import App from './App.vue';
import myPlugin from './myPlugin';

const app = createApp(App);
app.use(myPlugin);
app.mount('#app');


<template>
  <div>
    <p v-my-directive="'blue'">This text will be blue</p>
    <button @click="$myPluginMethod">Call Plugin Method</button>
  </div>
</template>


```

## 高阶组件（HOC）如何替代mixin

高阶组件是一个函数，它接收一个组件作为参数，并返回一个新的组件。HOC 可以用来封装和复用组件逻辑，同时避免 Mixin 中常见的命名冲突和逻辑不清晰的问题


```

// withVip.js
import { h } from 'vue';
import OpenVipTip from './OpenVipTip.vue';

export default function WithVip(BaseComponent) {
  return {
    setup(props, { attrs, slots }) {
      const showVipContent = getShowVipContent();

      function getShowVipContent() {
        // 业务逻辑：判断是否显示 VIP 内容
        return true;
      }

      return () => {
        return showVipContent
          ? h(BaseComponent, { ...props, ...attrs }, slots)
          : h(OpenVipTip);
      };
    }
  };
}

<template>
  <EnhancedComponent />
</template>

<script setup>
import MyComponent from './MyComponent.vue';
import WithVip from './withVip.js';

const EnhancedComponent = WithVip(MyComponent);
</script>

Mixin：适合在组件内部复用逻辑，但可能导致命名冲突和逻辑不清晰。
HOC：更适合封装组件逻辑，避免了 Mixin 的一些问题，同时提供了更灵活的代码组织方式

```