<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="javascript nodejs web developer...">
<meta property="og:type" content="website">
<meta property="og:title" content="WBlog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="WBlog">
<meta property="og:description" content="javascript nodejs web developer...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wangzhiwei">
<meta property="article:tag" content="javascript nodejs web developer fe engineer">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">wangzhiwei blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-24 17:38:43" itemprop="dateCreated datePublished" datetime="2024-12-24T17:38:43+08:00">2024-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>可以容纳数据的结构被称为数据结构。<br>算法是用来对数据结构进行处理的方法<br>数据结构是静态的。<br>算法是动态的。</p>
<h3 id="线性数据结构（一维数据结构）"><a href="#线性数据结构（一维数据结构）" class="headerlink" title="线性数据结构（一维数据结构）"></a>线性数据结构（一维数据结构）</h3><p>线性数据结构强调存储与顺序</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>1、存储在物理空间上是连续的<br>2、底层的数组长度是不可变的<br>3、数组的变量，指向了数组的第一个元素的位置<br>a[1] a[2] []表示存储地址的偏移， 通过偏移查询数据性能最好</p>
<p>优点： 查询数据性能最好<br>缺点：<br>1、因为空间必须得连续，所以如果数组比较大，当空间碎片比较多的时候，容易存不下。<br>2、因为数组的长度是固定的，所以数组的内容难以被添加和删除</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>我想传递一个链表，必须传递链表的根节点。<br>每一个节点，都认为自己是根节点</p>
<p>链表的特点：</p>
<p>1、空间上不是连续的。<br>2、没存放一个值，都要多开销一个引用空间。</p>
<p>优点：</p>
<p>1、只要内存足够大，就能存的下，不用担心空间碎片的问题。<br>2、链表的插入和删除操作，非常快。<br>3、链表可以存放任意类型的数据。</p>
<p>缺点：<br>1、查询数据性能差<br>2、链表不能随机访问。<br>3、每个节点都要多开一个引用空间。当节点内数据越大，这部分多开销的内存影响越小</p>
<h3 id="链表的逆置"><a href="#链表的逆置" class="headerlink" title="链表的逆置"></a>链表的逆置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Node(val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.next = null;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历链表</span><br><span class="line">function traverseLinkedList(head) &#123;</span><br><span class="line">    let current = head;</span><br><span class="line">    while (current !== null) &#123;</span><br><span class="line">        console.log(current.val); // 访问当前节点的值</span><br><span class="line">        current = current.next;   // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 迭代方式</span><br><span class="line">function reverseLinkedList(head) &#123;</span><br><span class="line">    let prev = null;</span><br><span class="line">    let current = head;</span><br><span class="line">    while (current !== null) &#123;</span><br><span class="line">        let nextNode = current.next;</span><br><span class="line">        current.next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev; // 新的头节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归方式</span><br><span class="line">function reverseLinkedListRecursive(head) &#123;</span><br><span class="line">    if (head === null || head.next === null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    let newHead = reverseLinkedListRecursive(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var node1 = new Node(1);</span><br><span class="line">var node2 = new Node(2);</span><br><span class="line">var node3 = new Node(3);</span><br><span class="line">var node4 = new Node(4);</span><br><span class="line">var node5 = new Node(5);</span><br><span class="line">node1.next = node2;</span><br><span class="line">node2.next = node3;</span><br><span class="line">node3.next = node4;</span><br><span class="line">node4.next = node5;</span><br><span class="line"></span><br><span class="line">console.log(node1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(&quot;Original Linked List:&quot;);</span><br><span class="line">traverseLinkedList(node1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// const result = reverseLinkedList(node1);</span><br><span class="line"></span><br><span class="line">// console.log(result);</span><br><span class="line"></span><br><span class="line">// console.log(&quot;Reversed Linked List:&quot;);</span><br><span class="line">// traverseLinkedList(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const res1 = reverseLinkedListRecursive(node1);</span><br><span class="line"></span><br><span class="line">console.log(res1);</span><br><span class="line"></span><br><span class="line">console.log(&quot;Reversed Linked List:&quot;);</span><br><span class="line">traverseLinkedList(res1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度分析</p>
<p>最坏情况：<br>当数组是逆序时，冒泡排序需要进行最多的比较和交换操作。<br>外层循环执行 ( n ) 次（其中 ( n ) 是数组的长度）。<br>内层循环在第一次迭代时执行 ( n-1 ) 次，在第二次迭代时执行 ( n-2 ) 次，依此类推，直到最后一次迭代执行 1 次。<br>因此，总的比较次数为： [ (n-1) + (n-2) + \cdots + 1 &#x3D; \frac{n(n-1)}{2} ]<br>这个和是一个二次函数，时间复杂度为 ( O(n^2) )。</p>
<p>平均情况：<br>在平均情况下，数组元素是随机排列的。<br>冒泡排序仍然需要进行大约 ( \frac{n(n-1)}{2} ) 次比较和交换操作。<br>因此，平均时间复杂度也是 ( O(n^2) )。</p>
<p>最好情况：<br>当数组已经有序时，冒泡排序只需要进行一次完整的遍历来确认没有需要交换的元素。<br>这种情况下，内层循环只执行一次，总的比较次数为 ( n-1 )。<br>因此，最好时间复杂度为 ( O(n) )。<br>空间复杂度<br>冒泡排序是一种原地排序算法，它不需要额外的存储空间来存储数组元素，因此空间复杂度为 ( O(1) )。</p>
<p><img src="/../images/sf.gif"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var arr2 = [10, 9, 20, 30, 15, 25, 35, 40, 45, 50];</span><br><span class="line">let num = 0;</span><br><span class="line">// 冒泡排序</span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                let temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleSort(arr2)</span><br><span class="line">console.log(arr2, num); // 输出排序后的次数 45 次，数组排序 如何变都是 45 次 O(n^2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr = [9, 10, 15, 20, 25, 30, 35, 40, 45, 50]</span><br><span class="line">num = 0;</span><br><span class="line">// 优化后的冒泡排序</span><br><span class="line">function bubbleSort2(arr) &#123;</span><br><span class="line">    let n = arr.length;</span><br><span class="line">    let swapped;</span><br><span class="line">    do &#123;</span><br><span class="line">        swapped = false;</span><br><span class="line">        for (let i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            if (arr[i] &gt; arr[i + 1]) &#123;</span><br><span class="line">                // 交换 arr[i] 和 arr[i + 1]</span><br><span class="line">                let temp = arr[i];</span><br><span class="line">                arr[i] = arr[i + 1];</span><br><span class="line">                arr[i + 1] = temp;</span><br><span class="line">                swapped = true;</span><br><span class="line">            &#125;</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">        // 每次遍历后，最大的元素会被放到最后，所以可以减少一次遍历</span><br><span class="line">        n--;</span><br><span class="line">    &#125; while (swapped);</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let sortedArray = bubbleSort2(arr);</span><br><span class="line">console.log(&quot;Sorted Array:&quot;, sortedArray);</span><br><span class="line">console.log(num); // 输出排序后的次数 9 次, O(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/24/nodejs%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/24/nodejs%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/" class="post-title-link" itemprop="url">nodejs宏任务和微任务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-24 14:32:22" itemprop="dateCreated datePublished" datetime="2024-12-24T14:32:22+08:00">2024-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nodejs/" itemprop="url" rel="index"><span itemprop="name">nodejs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="nodejs宏任务和微任务"><a href="#nodejs宏任务和微任务" class="headerlink" title="nodejs宏任务和微任务"></a>nodejs宏任务和微任务</h2><p>在 Node.js 中，事件循环机制处理任务的方式分为宏任务（macrotask）和微任务（microtask）。以下是它们的区别及执行顺序：</p>
<ul>
<li><p><strong>宏任务（Macrotask）</strong></p>
<ul>
<li>包含：<code>setTimeout</code>, <code>setInterval</code>, I&#x2F;O 操作, UI 渲染, <code>setImmediate</code></li>
<li>每次执行完一个宏任务后会进入微任务队列检查并执行所有微任务</li>
<li>下一次事件循环开始时才会继续执行下一个宏任务</li>
</ul>
</li>
<li><p><strong>微任务（Microtask）</strong></p>
<ul>
<li>包含：<code>Promise.then</code>, <code>process.nextTick</code>, <code>Object.observe</code>(已废弃), <code>MutationObserver</code></li>
<li>在当前任务（无论是宏任务还是微任务）执行完毕后立即执行，直到微任务队列为空</li>
<li><code>process.nextTick</code> 的优先级最高，在当前操作完成后立即执行，甚至早于其他微任务</li>
</ul>
</li>
</ul>
<h3 id="执行顺序示例："><a href="#执行顺序示例：" class="headerlink" title="执行顺序示例："></a>执行顺序示例：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 宏任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微任务</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 微任务，优先级最高</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p>这是因为：</p>
<ol>
<li>同步代码先执行，输出 <code>start</code> 和 <code>end</code></li>
<li>然后执行微任务队列中的任务，由于 <code>process.nextTick</code> 优先级最高，所以首先输出 <code>nextTick</code></li>
<li>接着执行剩余的微任务，输出 <code>promise1</code> 和 <code>promise2</code></li>
<li>最后回到事件循环执行宏任务，输出 <code>setTimeout</code></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/24/AST%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/24/AST%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">AST学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-24 11:40:26" itemprop="dateCreated datePublished" datetime="2024-12-24T11:40:26+08:00">2024-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AST/" itemprop="url" rel="index"><span itemprop="name">AST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），是源代码语法结构的⼀种抽象表示。<br>它以树状的形式表现编程语⾔的语法结构，树上的每个节点都表示源代码中的⼀种结构。<br>AST 运⽤⼴泛，⽐如：<br>⾼级语⾔的编译、机器码的⽣成<br>⼀些⾼级编辑器的错误提示、代码⾼亮、代码⾃动补全；<br>对于前端来说很多⼯具，例如 elint 、 pretiier 对代码错误或⻛格的检查，babel、typescript<br>对代码的编译处理等等。<br>AST 转化流程<br>我们可以实现⼀个⾮常简单的词法分析⼯具，来感受⼀下词法分析的魅⼒，以及这中间我们需要处理的<br>内容。<br>在例⼦中我们可以发现，我们通过读取字符串中每个元素，依次记录⾥⾯出现的内容，最终基于内容⽣<br>成配置，然后再基于配置创建新的代码的结构。<br>整个解析过程主要分为以下两个步骤：<br>分词：将整个代码字符串分割成最⼩语法单元数组<br>语法分析：在分词基础上建⽴分析语法单元之间的关系<br>词法分析器⾥，每个关键字是⼀个 Token ，每个标识符是⼀个 Token，每个操作符是⼀个 Token，每<br>个标点符号也都是⼀个 Token。除此之外，还会过滤掉源程序中的注释和空⽩字符（换⾏符、空格、制<br>表符等。<br>我们可以通过 ast-explore 来查看代码⽚段转化的结果：<br>我们可以看到，对于左侧的代码结构，通过解析字符及对应的格式，然后序列化成为⼀个对象的格式，<br>我们可以通过这个对象，来描述整体的代码的内容。<br>如果我们希望将 let 转化为 var，那后续我们只需要在基于配置渲染⽬标时，将 let 转化为 var ⽣成即<br>可。对于 AST 的类型来说，解析的过程中有这么多的类型，针对不同的语句，最终会以下⾯的类型进⾏转<br>化：</p>
<h2 id="模拟-AST-过程"><a href="#模拟-AST-过程" class="headerlink" title="模拟 AST 过程"></a>模拟 AST 过程</h2><p>index.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// before: (add 20 (subtract 4 2))</span><br><span class="line">// after: add(2, subtract(4, 2))</span><br><span class="line"></span><br><span class="line">// 分词，处理每个字符内容</span><br><span class="line">function generateToken(str) &#123;</span><br><span class="line">  let current = 0;</span><br><span class="line">  let tokens = [];</span><br><span class="line">  while(current &lt; str.length) &#123;</span><br><span class="line">    let char = str[current];</span><br><span class="line"></span><br><span class="line">    if (char === &quot;(&quot;) &#123;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        type: &quot;paren&quot;,</span><br><span class="line">        value: &quot;(&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">      current++;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (char === &quot;)&quot;) &#123;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        type: &quot;paren&quot;,</span><br><span class="line">        value: &quot;)&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">      current++;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (/\s/.test(char)) &#123;</span><br><span class="line">      current++;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (/[0-9]/.test(char)) &#123;</span><br><span class="line">      let numberValue = &#x27;&#x27;;</span><br><span class="line">      while(/[0-9]/.test(char)) &#123;</span><br><span class="line">        numberValue += char;</span><br><span class="line">        char = str[++current];</span><br><span class="line">      &#125;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        type: &#x27;number&#x27;,</span><br><span class="line">        value: numberValue</span><br><span class="line">      &#125;);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (/[a-z]/.test(char)) &#123;</span><br><span class="line">      let stringValue = &#x27;&#x27;;</span><br><span class="line">      while(/[a-z]/.test(char)) &#123;</span><br><span class="line">        stringValue += char;</span><br><span class="line">        char = str[++current];</span><br><span class="line">      &#125;</span><br><span class="line">      tokens.push(&#123;</span><br><span class="line">        type: &#x27;name&#x27;,</span><br><span class="line">        value: stringValue</span><br><span class="line">      &#125;);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new TypeError(&quot;未能识别的字符&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AST 生成</span><br><span class="line">function generateAST(tokens) &#123;</span><br><span class="line">  let current = 0;</span><br><span class="line"></span><br><span class="line">  let ast = &#123;</span><br><span class="line">    type: &quot;Program&quot;,</span><br><span class="line">    body: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function walk() &#123;</span><br><span class="line">    let token = tokens[current];</span><br><span class="line">    if (token.type === &#x27;number&#x27;) &#123;</span><br><span class="line">      current++;</span><br><span class="line">      return &#123;</span><br><span class="line">        type: &quot;NumberLiteral&quot;,</span><br><span class="line">        value: token.value,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (token.type === &#x27;paren&#x27; &amp;&amp; token.value === &quot;(&quot;) &#123;</span><br><span class="line">      token = tokens[++current];</span><br><span class="line">      let node = &#123;</span><br><span class="line">        type: &quot;CallExpression&quot;,</span><br><span class="line">        name: token.value,</span><br><span class="line">        params: [],</span><br><span class="line">      &#125;;</span><br><span class="line">      token = tokens[++current];</span><br><span class="line"></span><br><span class="line">      while(</span><br><span class="line">        (token.type !== &quot;paren&quot;) || (token.type === &#x27;paren&#x27; &amp;&amp; token.value !== &quot;)&quot;)</span><br><span class="line">      ) &#123;</span><br><span class="line">        node.params.push(walk());</span><br><span class="line">        token = tokens[current];</span><br><span class="line">      &#125;</span><br><span class="line">      current++;</span><br><span class="line">      return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new TypeError(token.type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while(current &lt; tokens.length) &#123;</span><br><span class="line">    ast.body.push(walk())</span><br><span class="line">  &#125;</span><br><span class="line">  return ast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AST 转化： babel 插件需要我们处理的部分</span><br><span class="line">function transformer(ast) &#123;</span><br><span class="line">  let newAst = &#123;</span><br><span class="line">    type: &quot;Program&quot;,</span><br><span class="line">    body: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ast._context = newAst.body;</span><br><span class="line"></span><br><span class="line">  DFS(ast, &#123;</span><br><span class="line">    NumberLiteral: &#123;</span><br><span class="line">      enter(node, parent) &#123;</span><br><span class="line">        parent._context.push(&#123;</span><br><span class="line">          type: &quot;NumberLiteral&quot;,</span><br><span class="line">          value: node.value</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    CallExpression: &#123;</span><br><span class="line">      enter(node, parent) &#123;</span><br><span class="line">        let expression = &#123;</span><br><span class="line">          type: &quot;CallExpression&quot;,</span><br><span class="line">          callee: &#123;</span><br><span class="line">            type: &quot;Identifier&quot;,</span><br><span class="line">            name: node.name</span><br><span class="line">          &#125;,</span><br><span class="line">          arguments: [],</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        node._context = expression.arguments;</span><br><span class="line">        if (parent.type !== &quot;CallExpression&quot;) &#123;</span><br><span class="line">          expression = &#123;</span><br><span class="line">            type: &quot;ExpressionStatement&quot;,</span><br><span class="line">            expression: expression,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        parent._context.push(expression);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return newAst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AST 遍历</span><br><span class="line">function DFS(ast, visitor) &#123;</span><br><span class="line"></span><br><span class="line">  function traverseArray(children, parent) &#123;</span><br><span class="line">    children.forEach(child =&gt; traverseNode(child, parent));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function traverseNode(node, parent) &#123;</span><br><span class="line">    let methods = visitor[node.type];</span><br><span class="line">    if (methods &amp;&amp; methods.enter) &#123;</span><br><span class="line">      methods.enter(node, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    switch(node.type) &#123;</span><br><span class="line">      case &quot;Program&quot;:</span><br><span class="line">        traverseArray(node.body, node);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;CallExpression&quot;:</span><br><span class="line">        traverseArray(node.params, node);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;NumberLiteral&quot;:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (methods &amp;&amp; methods.exit) &#123;</span><br><span class="line">      methods.exit(node, parent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return traverseNode(ast, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ast -&gt; code 生成代码过程</span><br><span class="line">function generate(ast) &#123;</span><br><span class="line">  switch(ast.type) &#123;</span><br><span class="line">    case &quot;Program&quot;: return ast.body.map(subAst =&gt; generate(subAst)).join(&#x27;\n&#x27;);</span><br><span class="line">    case &quot;ExpressionStatement&quot;: return generate(ast.expression) + &quot;;&quot;;</span><br><span class="line">    case &quot;CallExpression&quot;: return generate(ast.callee) + &quot;(&quot; +ast.arguments.map(arg =&gt; generate(arg)).join(&#x27;, &#x27;) + &quot;)&quot;;</span><br><span class="line">    case &quot;Identifier&quot;: return ast.name;</span><br><span class="line">    case &quot;NumberLiteral&quot;: return ast.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function parser(input) &#123;</span><br><span class="line">  const tokens = generateToken(input);</span><br><span class="line">  console.log(tokens);</span><br><span class="line">  const ast = generateAST(tokens);</span><br><span class="line">  console.log(JSON.stringify(ast, null, 2));</span><br><span class="line">  const newAst = transformer(ast);</span><br><span class="line">  console.log(JSON.stringify(newAst, null, 2));</span><br><span class="line">  const code = generate(newAst);</span><br><span class="line">  return code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = parser;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>test.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const parser = require(&#x27;./index.js&#x27;);</span><br><span class="line"></span><br><span class="line">const input = &quot;(add 2 (subtract 4 2))&quot;</span><br><span class="line">const output = &quot;add(2,subtract(4,2));&quot;</span><br><span class="line"></span><br><span class="line">console.log(&quot;input&quot;, input);</span><br><span class="line">console.log(&quot;output&quot;, parser(input));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThisExpression | Identifier | Literal |</span><br><span class="line">ArrayExpression | ObjectExpression | FunctionExpression |</span><br><span class="line">ArrowFunctionExpression | ClassExpression |</span><br><span class="line">TaggedTemplateExpression | MemberExpression | Super | MetaProperty |</span><br><span class="line">NewExpression | CallExpression | UpdateExpression | AwaitExpression |</span><br><span class="line">UnaryExpression |</span><br><span class="line">BinaryExpression | LogicalExpression | ConditionalExpression |</span><br><span class="line">YieldExpression | AssignmentExpression | SequenceExpression;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>针对不同的⼯具，最终也有不同的效果：<br>@babel&#x2F;parser : 转化为 AST 抽象语法树；<br>@babel&#x2F;traverse 对 AST 节点进⾏递归遍历；<br>@babel&#x2F;types 对具体的 AST 节点进⾏进⾏修改；<br>@babel&#x2F;generator : AST 抽象语法树⽣成为新的代码；</p>
<p>Babel 的处理步骤</p>
<p>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），⽣成（generate）。.</p>
<p>词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。.</p>
<p>你可以把令牌看作是⼀个扁平的语法⽚段数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n * n;</span><br><span class="line">[</span><br><span class="line">&#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</span><br><span class="line">&#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</span><br><span class="line">&#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每⼀个 type 有⼀组属性来描述该令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    type: &#123;</span><br><span class="line">        label: &#x27;name&#x27;,</span><br><span class="line">        keyword: undefined,</span><br><span class="line">        beforeExpr: false,</span><br><span class="line">        startsExpr: true,</span><br><span class="line">        rightAssociative: false,</span><br><span class="line">        isLoop: false,isAssign: false,</span><br><span class="line">        prefix: false,</span><br><span class="line">        postfix: false,</span><br><span class="line">        binop: null,</span><br><span class="line">        updateContext: null</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和 AST 节点⼀样它们也有 start ， end ， loc 属性。</p>
<p>对于⼀个 babel 插件来说，我们先从先从⼀个接收了当前 babel 对象作为参数的 function 开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default function(babel) &#123;</span><br><span class="line">// plugin contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>由于你将会经常这样使⽤，所以直接取出 babel.types 会更⽅便：（译注：这是 ES2015 语法中的对<br>象解构，即 Destructuring）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default function(&#123; types: t &#125;) &#123;</span><br><span class="line">// plugin contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着返回⼀个对象，其 visitor 属性是这个插件的主要访问者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default function(&#123; types: t &#125;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        visitor: &#123;</span><br><span class="line">        // visitor contents</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Visitor 中的每个函数接收2个参数： path 和 state</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function(&#123; types: t &#125;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        visitor: &#123;</span><br><span class="line">            Identifier(path, state) &#123;&#125;,</span><br><span class="line">            ASTNodeTypeHere(path, state) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们快速编写⼀个可⽤的插件来展示⼀下它是如何⼯作的。下⾯是我们的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo === bar;</span><br></pre></td></tr></table></figure>

<p>其 AST 形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: &quot;BinaryExpression&quot;,</span><br><span class="line">    operator: &quot;===&quot;,</span><br><span class="line">    left: &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;foo&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">        type: &quot;Identifier&quot;,</span><br><span class="line">        name: &quot;bar&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我们从添加 BinaryExpression 访问者⽅法开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function(&#123; types: t &#125;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        visitor: &#123;</span><br><span class="line">            BinaryExpression(path) &#123;</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们更确切⼀些，只关注哪些使⽤了 &#x3D;&#x3D;&#x3D; 的 BinaryExpression 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">visitor: &#123;</span><br><span class="line">    BinaryExpression(path) &#123;</span><br><span class="line">    if (path.node.operator !== &quot;===&quot;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们⽤新的标识符来替换 left 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BinaryExpression(path) &#123;</span><br><span class="line">    if (path.node.operator !== &quot;===&quot;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    path.node.left = t.identifier(&quot;sebmck&quot;);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是如果我们运⾏这个插件我们会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sebmck === bar;</span><br></pre></td></tr></table></figure>

<p>现在只需要替换 right 属性了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BinaryExpression(path) &#123;</span><br><span class="line">    if (path.node.operator !== &quot;===&quot;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    path.node.left = t.identifier(&quot;sebmck&quot;);</span><br><span class="line">    path.node.right = t.identifier(&quot;dork&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是我们的最终结果了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sebmck === dork;</span><br></pre></td></tr></table></figure>



<p>我们可以⽤更复杂的⼀些配置来完善我们的插件。。</p>
<h2 id="Babel-插件开发"><a href="#Babel-插件开发" class="headerlink" title="Babel 插件开发"></a>Babel 插件开发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.</span><br><span class="line">├── index.js</span><br><span class="line">├── node_modules</span><br><span class="line">├── output.js</span><br><span class="line">├── package.json</span><br><span class="line">├── plugin.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;babel&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.11.1&quot;,</span><br><span class="line">    &quot;@babel/types&quot;: &quot;^7.11.0&quot;,</span><br><span class="line">    &quot;babel-cli&quot;: &quot;^6.26.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.babelrc </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;./plugin&quot;, &#123;</span><br><span class="line">      &quot;tips&quot;: &quot;newTips&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plugin.js</span><br><span class="line"></span><br><span class="line">module.exports = function(&#123;types: t&#125;) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier(path, state) &#123;</span><br><span class="line">        const name = path.node.name;</span><br><span class="line">        console.log(state.opts);</span><br><span class="line"></span><br><span class="line">        // path.node.name = `__$&#123;name&#125;`;</span><br><span class="line">        if (state.opts[name]) &#123;</span><br><span class="line">          path.node.name = state.opts[name];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      MemberExpression(path) &#123;</span><br><span class="line">        if (path.get(&quot;object&quot;).matchesPattern(&quot;process.env&quot;)) &#123;</span><br><span class="line">          const key = path.toComputedKey();</span><br><span class="line">          if (t.isStringLiteral(key)) &#123;</span><br><span class="line">            path.replaceWith(t.valueToNode(process.env[key.value]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      BinaryExpression(path) &#123;</span><br><span class="line">        console.log(path.node.left);</span><br><span class="line">        console.log(path.node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index.js</span><br><span class="line"></span><br><span class="line">let tips;</span><br><span class="line">let array;</span><br><span class="line">const a = process.env.NODE_ENV</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行babel 编译命令</span><br><span class="line">NODE_ENV=&quot;production&quot; ./node_modules/.bin/babel index.js -o output.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">生成 output.js 文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let newTips;</span><br><span class="line">let array;</span><br><span class="line">const a = &quot;production&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p>其他：<br><a target="_blank" rel="noopener" href="https://www.astexplorer.net/">https://www.astexplorer.net/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/23/typescript%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/23/typescript%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">typescript复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-23 17:34:43" itemprop="dateCreated datePublished" datetime="2024-12-23T17:34:43+08:00">2024-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnpm i typescript</span><br><span class="line">cnpm i @types/node</span><br><span class="line"></span><br><span class="line">npx tsc --init</span><br><span class="line"></span><br><span class="line">生成  tsconfig.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npx tsc </span><br><span class="line">npx tsc --watch </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nodejs 环境的tsconfig.json 配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    </span><br><span class="line">    &quot;target&quot;: &quot;es2016&quot;, //目标代码</span><br><span class="line">    &quot;lib&quot;: [&quot;es2016&quot;], //开发时的库</span><br><span class="line">    // &quot;module&quot;:&quot;ES2015&quot;, //模块规范</span><br><span class="line">    &quot;module&quot;:&quot;CommonJS&quot;, //设置编译结果中使用的模块化标准</span><br><span class="line">    &quot;outDir&quot;: &quot;dist&quot;, //输出目录</span><br><span class="line">    &quot;strictNullChecks&quot;: true, //严格空检查</span><br><span class="line">    &quot;removeComments&quot;: true, //编译结果移除注释</span><br><span class="line">    &quot;esModuleInterop&quot;: true, //兼启用es模块化交互非es模块导出</span><br><span class="line">    &quot;noEmitOnError&quot;: true, // 编译错误不输出编译结果</span><br><span class="line">    // &quot;moduleResolution&quot;: &quot;node&quot; //设置解析模块的模式</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [&quot;src/**/*&quot;],  //指定编译文件</span><br><span class="line">  // &quot;files&quot;: [&quot;src/index.ts&quot;] //指定编译文件,</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 泛型 在函数中使用</span><br><span class="line"></span><br><span class="line">function take2&lt;T = number&gt;(arr: T[], n: number): T[]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (n &gt; arr.length) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    const newArr:T[] = [];</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newArr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">take2&lt;number&gt;([1,2], 3);</span><br><span class="line"></span><br><span class="line">take2&lt;string&gt;([&#x27;1&#x27;,&#x27;2&#x27;], 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的泛型应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function combin&lt;T extends number | string&gt;(a: T, b: T): T&#123;</span><br><span class="line">    return (a as any) + (b as any) as T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const res = combin(1,2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const res1 = combin(&#x27;a&#x27;,&#x27;b&#x27;);</span><br><span class="line"></span><br><span class="line">// const res2 = combin(3,&#x27;b&#x27;); // 报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">函数中的泛型应用</span><br><span class="line"></span><br><span class="line">type callBack&lt;T&gt; = (n: T, i: number) =&gt; boolean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function filter&lt;T&gt;(arr: T[], callback: callBack&lt;T&gt;): T[]</span><br><span class="line">&#123;</span><br><span class="line">    const newArr: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (callback(arr[i], i)) &#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">console.log(filter(arr, (n) =&gt; n &gt; 2));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">构造函数中的泛型应用</span><br><span class="line"></span><br><span class="line">class ArrayHelper&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    constructor(private arr: T[])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    take(n: number): T[]</span><br><span class="line">    &#123;</span><br><span class="line">        if (n &gt; this.arr.length) &#123;</span><br><span class="line">            return this.arr;</span><br><span class="line">        &#125;</span><br><span class="line">        const newArr:T[] = [];</span><br><span class="line">        for (let i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            newArr.push(this.arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return newArr;</span><br><span class="line">    &#125;</span><br><span class="line">    filter(callback: callBack&lt;T&gt;): T[]</span><br><span class="line">    &#123;</span><br><span class="line">        const newArr: T[] = [];</span><br><span class="line">        for (let i = 0; i &lt; this.arr.length; i++) &#123;</span><br><span class="line">            if (callback(this.arr[i], i)) &#123;</span><br><span class="line">                newArr.push(this.arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newArr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   shuffle() &#123;</span><br><span class="line"></span><br><span class="line">    for (let i = this.arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        const j = Math.floor(Math.random() * (i + 1));</span><br><span class="line">        [this.arr[i], this.arr[j]] = [this.arr[j], this.arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const helper = new ArrayHelper(arr);</span><br><span class="line"></span><br><span class="line">const newA = helper.filter(n =&gt; n &gt; 2);</span><br><span class="line"></span><br><span class="line">console.log(newA);</span><br><span class="line"></span><br><span class="line">helper.shuffle();</span><br><span class="line"></span><br><span class="line">console.log(helper.take(3));</span><br></pre></td></tr></table></figure>

<p>泛型约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface hasNameProperty &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function nameToUpperCase &lt;T extends hasNameProperty&gt; (obj: T): T</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    obj.name = obj.name.split(&quot; &quot;)</span><br><span class="line">        .map(n =&gt; n[0].toUpperCase() + n.slice(1))</span><br><span class="line">        .join(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const o = &#123;</span><br><span class="line">    name: &quot;john wang&quot;,</span><br><span class="line">    age: 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const newO = nameToUpperCase(o);</span><br><span class="line"></span><br><span class="line">console.log(newO.name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="导入三方模块"><a href="#导入三方模块" class="headerlink" title="导入三方模块"></a>导入三方模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 导入文件系统模块 在 ts 中异常</span><br><span class="line">// import fs from &#x27;fs&#x27;;</span><br><span class="line"></span><br><span class="line">//需要改写为 </span><br><span class="line">import &#123;readFileSync&#125; from &#x27;fs&#x27;;</span><br><span class="line"></span><br><span class="line">//或改写为</span><br><span class="line">//import * as fs from &quot;fs&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const input = readFileSync(&#x27;./input.txt&#x27;, &#x27;utf-8&#x27;).split(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编译后代码</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);</span><br><span class="line">const fs_1 = require(&quot;fs&quot;);</span><br><span class="line">const input = (0, fs_1.readFileSync)(&#x27;./input.txt&#x27;, &#x27;utf-8&#x27;).split(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//或改写为</span><br><span class="line">import * as fs from &quot;fs&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const input = fs.readFileSync(&#x27;./input.txt&#x27;, &#x27;utf-8&#x27;).split(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">编译后代码</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) &#123;</span><br><span class="line">    if (k2 === undefined) k2 = k;</span><br><span class="line">    var desc = Object.getOwnPropertyDescriptor(m, k);</span><br><span class="line">    if (!desc || (&quot;get&quot; in desc ? !m.__esModule : desc.writable || desc.configurable)) &#123;</span><br><span class="line">      desc = &#123; enumerable: true, get: function() &#123; return m[k]; &#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Object.defineProperty(o, k2, desc);</span><br><span class="line">&#125;) : (function(o, m, k, k2) &#123;</span><br><span class="line">    if (k2 === undefined) k2 = k;</span><br><span class="line">    o[k2] = m[k];</span><br><span class="line">&#125;));</span><br><span class="line">var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) &#123;</span><br><span class="line">    Object.defineProperty(o, &quot;default&quot;, &#123; enumerable: true, value: v &#125;);</span><br><span class="line">&#125;) : function(o, v) &#123;</span><br><span class="line">    o[&quot;default&quot;] = v;</span><br><span class="line">&#125;);</span><br><span class="line">var __importStar = (this &amp;&amp; this.__importStar) || (function () &#123;</span><br><span class="line">    var ownKeys = function(o) &#123;</span><br><span class="line">        ownKeys = Object.getOwnPropertyNames || function (o) &#123;</span><br><span class="line">            var ar = [];</span><br><span class="line">            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span><br><span class="line">            return ar;</span><br><span class="line">        &#125;;</span><br><span class="line">        return ownKeys(o);</span><br><span class="line">    &#125;;</span><br><span class="line">    return function (mod) &#123;</span><br><span class="line">        if (mod &amp;&amp; mod.__esModule) return mod;</span><br><span class="line">        var result = &#123;&#125;;</span><br><span class="line">        if (mod != null) for (var k = ownKeys(mod), i = 0; i &lt; k.length; i++) if (k[i] !== &quot;default&quot;) __createBinding(result, mod, k[i]);</span><br><span class="line">        __setModuleDefault(result, mod);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);</span><br><span class="line">const fs = __importStar(require(&quot;fs&quot;));</span><br><span class="line">const input = fs.readFileSync(&#x27;./input.txt&#x27;, &#x27;utf-8&#x27;).split(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>非要用 import fs from ‘fs’; 要改写 配置文件</p>
<p>增加<br>“esModuleInterop”: true, &#x2F;&#x2F;兼容es6模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import fs from &#x27;fs&#x27;;</span><br><span class="line">const input = fs.readFileSync(&#x27;./input.txt&#x27;, &#x27;utf-8&#x27;).split(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">编译后代码</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) &#123;</span><br><span class="line">    return (mod &amp;&amp; mod.__esModule) ? mod : &#123; &quot;default&quot;: mod &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);</span><br><span class="line">const fs_1 = __importDefault(require(&quot;fs&quot;));</span><br><span class="line">const input = fs_1.default.readFileSync(&#x27;./input.txt&#x27;, &#x27;utf-8&#x27;).split(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="TS中书写-commjs-模块代码"><a href="#TS中书写-commjs-模块代码" class="headerlink" title="TS中书写 commjs 模块代码"></a>TS中书写 commjs 模块代码</h2><p>导出 export &#x3D; xxxx</p>
<p>导入 import xxx &#x3D; require(‘xxx’);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">c.ts</span><br><span class="line">export = &#123;</span><br><span class="line">    add: (a:number,b:number)=&gt;a+b,</span><br><span class="line">    name: &#x27;c&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">05.ts</span><br><span class="line"></span><br><span class="line">import aa = require(&#x27;./c&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(aa.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编译后代码</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;);</span><br><span class="line">const aa = require(&quot;./c&quot;);</span><br><span class="line">console.log(aa.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    add: (a, b) =&gt; a + b,</span><br><span class="line">    name: &#x27;c&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Gend &#123;</span><br><span class="line">    Male = &#x27;male&#x27;,</span><br><span class="line">    Female = &#x27;female&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let gen: Gend;</span><br><span class="line"></span><br><span class="line">gen = Gend.Male;</span><br><span class="line">gen = Gend.Female;</span><br><span class="line"></span><br><span class="line">会参与编译 枚举属性的值是字符串或数字，为数字时会自增，可以赋值（不建议）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="接口和别名"><a href="#接口和别名" class="headerlink" title="接口和别名"></a>接口和别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Gender = &#x27;male&#x27; | &#x27;female&#x27;;</span><br><span class="line">let gender: Gender;</span><br><span class="line">gender = &#x27;male&#x27;;</span><br><span class="line">gender = &#x27;female&#x27;;</span><br><span class="line"></span><br><span class="line">function showGender(gender: Gender): void</span><br><span class="line">&#123;</span><br><span class="line">    console.log(gender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//接口</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    sayHello(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类型别名</span><br><span class="line">type Person2 = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let p1: Person = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;,</span><br><span class="line">    age: 18,</span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(&#x27;hello&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let p2: Person2 = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Condition = (n: number) =&gt; boolean;</span><br><span class="line"></span><br><span class="line">function sum(number: number[], callback: Condition) &#123;</span><br><span class="line"></span><br><span class="line">    let s = 0;</span><br><span class="line"></span><br><span class="line">    number.forEach(n =&gt; &#123;</span><br><span class="line">        if (callback(n)) &#123;</span><br><span class="line">            s += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result =  sum([1,2,3,4,5], n =&gt; n % 2 === 0);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="接口（Interface）和类型别名（Type-Alias）的区别"><a href="#接口（Interface）和类型别名（Type-Alias）的区别" class="headerlink" title="接口（Interface）和类型别名（Type Alias）的区别"></a>接口（Interface）和类型别名（Type Alias）的区别</h2><p>在 TypeScript 中，接口和类型别名都可以用来定义对象的形状，但它们有一些关键的区别。以下是它们的主要差异：</p>
<h3 id="1-扩展性（Extensibility）"><a href="#1-扩展性（Extensibility）" class="headerlink" title="1. 扩展性（Extensibility）"></a>1. 扩展性（Extensibility）</h3><ul>
<li><p><strong>接口</strong>：可以使用 <code>extends</code> 关键字来扩展其他接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">employeeId</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型别名</strong>：不能直接扩展其他类型别名，但可以通过交叉类型（intersection types）实现类似的效果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Employee</span> = <span class="title class_">Person</span> &amp; &#123;</span><br><span class="line">    <span class="attr">employeeId</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-合并（Merging）"><a href="#2-合并（Merging）" class="headerlink" title="2. 合并（Merging）"></a>2. 合并（Merging）</h3><ul>
<li><p><strong>接口</strong>：支持声明合并（declaration merging），即多个同名接口会自动合并为一个接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型别名</strong>：不支持声明合并，多个同名类型别名会导致编译错误。</p>
</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><p><strong>接口</strong>：主要用于定义对象的形状，通常用于描述类、函数参数或返回值等。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span> <span class="keyword">implements</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">role</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型别名</strong>：更加灵活，可以用于定义原始类型、联合类型、元组等复杂类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPerson</span> = &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-可重载（Overloading）"><a href="#4-可重载（Overloading）" class="headerlink" title="4. 可重载（Overloading）"></a>4. 可重载（Overloading）</h3><ul>
<li><p><strong>接口</strong>：可以用于函数重载。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    (<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    (<span class="attr">a</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型别名</strong>：不能直接用于函数重载，但可以通过函数类型定义实现类似效果。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = &#123;</span><br><span class="line">    (<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    (<span class="attr">a</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-性能"><a href="#5-性能" class="headerlink" title="5. 性能"></a>5. 性能</h3><ul>
<li><strong>接口</strong>：编译后会被优化掉，不会生成额外的 JavaScript 代码。</li>
<li><strong>类型别名</strong>：同样不会生成额外的 JavaScript 代码，但在某些情况下可能会有细微的性能差异。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果你需要定义对象的形状并且希望支持扩展和合并，建议使用接口。</li>
<li>如果你需要定义更复杂的类型（如联合类型、元组等），或者需要更高的灵活性，建议使用类型别名。</li>
</ul>
<p>在你的代码中，<code>Person</code> 和 <code>Person2</code> 分别使用了接口和类型别名来定义相同的内容。你可以根据上述区别选择更适合你需求的方式。</p>
<h2 id="可重载"><a href="#可重载" class="headerlink" title="可重载"></a>可重载</h2><p>在 TypeScript 中，函数重载（Function Overloading） 是指定义多个具有相同名称但参数列表不同的函数签名。编译器会根据调用时传递的参数类型和数量来选择最匹配的函数签名。函数重载允许你为同一个函数提供多种调用方式，从而提高代码的灵活性和可读性。</p>
<p>示例：</p>
<p>typescript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义两个重载签名</span><br><span class="line">function add(a: number, b: number): number;</span><br><span class="line">function add(a: string, b: string): string;</span><br><span class="line"></span><br><span class="line">// 实现函数</span><br><span class="line">function add(a: any, b: any): any &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">console.log(add(1, 2));      // 输出: 3</span><br><span class="line">console.log(add(&quot;hello&quot;, &quot; world&quot;));  // 输出: hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    </span><br><span class="line">    readonly id:number</span><br><span class="line">    name:string</span><br><span class="line">    age:number</span><br><span class="line">    pid?:string</span><br><span class="line"></span><br><span class="line">    // ts语法 访问修饰符</span><br><span class="line">    private publishNumber:number = 3</span><br><span class="line">    private curNumber:number = 0</span><br><span class="line"></span><br><span class="line">    constructor(name:string,age:number)&#123;</span><br><span class="line">        this.id = Math.random();</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publish()&#123;</span><br><span class="line">        if (this.curNumber &gt;= this.publishNumber) &#123;</span><br><span class="line">            console.log(`$&#123;this.name&#125; 已经发布文章上限`);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.curNumber++;</span><br><span class="line">        console.log(`$&#123;this.name&#125; 发布了第$&#123;this.curNumber&#125;篇文章`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const u = new User(&#x27;张三&#x27;,18);</span><br><span class="line">u.pid = &#x27;1111&#x27;;</span><br><span class="line">// u.id = 2;</span><br><span class="line">console.log(u.id);</span><br><span class="line">console.log(u.pid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u.publish();</span><br><span class="line">u.publish();</span><br><span class="line">u.publish();</span><br><span class="line">u.publish();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编译后代码</span><br><span class="line">==&gt;&gt;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.publishNumber = 3;</span><br><span class="line">        this.curNumber = 0;</span><br><span class="line">        this.id = Math.random();</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    publish() &#123;</span><br><span class="line">        if (this.curNumber &gt;= this.publishNumber) &#123;</span><br><span class="line">            console.log(`$&#123;this.name&#125; 已经发布文章上限`);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.curNumber++;</span><br><span class="line">        console.log(`$&#123;this.name&#125; 发布了第$&#123;this.curNumber&#125;篇文章`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const u = new User(&#x27;张三&#x27;, 18);</span><br><span class="line">u.pid = &#x27;1111&#x27;;</span><br><span class="line">console.log(u.id);</span><br><span class="line">console.log(u.pid);</span><br><span class="line">u.publish();</span><br><span class="line">u.publish();</span><br><span class="line">u.publish();</span><br><span class="line">u.publish();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="React-TS"><a href="#React-TS" class="headerlink" title="React + TS"></a>React + TS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="JSX-和-TSX-的区别"><a href="#JSX-和-TSX-的区别" class="headerlink" title="JSX 和 TSX 的区别"></a>JSX 和 TSX 的区别</h2><p>在 React 开发中，JSX 和 TSX 是两种不同的文件扩展名，它们用于定义组件的模板语法。以下是它们的主要区别：</p>
<h3 id="1-文件扩展名"><a href="#1-文件扩展名" class="headerlink" title="1. 文件扩展名"></a>1. 文件扩展名</h3><ul>
<li><strong>JSX</strong>: 文件扩展名为 <code>.jsx</code>，主要用于编写 React 组件，但不包含 TypeScript 类型检查。</li>
<li><strong>TSX</strong>: 文件扩展名为 <code>.tsx</code>，不仅支持 JSX 语法，还集成了 TypeScript 的类型检查功能。</li>
</ul>
<h3 id="2-类型检查"><a href="#2-类型检查" class="headerlink" title="2. 类型检查"></a>2. 类型检查</h3><ul>
<li><strong>JSX</strong>: 没有内置的类型检查功能，因此无法在编译时捕获类型错误。</li>
<li><strong>TSX</strong>: 支持 TypeScript 的类型检查，可以在编译时检测并报告类型错误，提高代码的健壮性和可维护性。</li>
</ul>
<h3 id="3-语法兼容性"><a href="#3-语法兼容性" class="headerlink" title="3. 语法兼容性"></a>3. 语法兼容性</h3><ul>
<li><strong>JSX</strong>: 只能使用 JavaScript 语法。</li>
<li><strong>TSX</strong>: 可以使用 TypeScript 语法，包括类型注解、接口、泛型等。</li>
</ul>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h3><h3 id="JSX-示例"><a href="#JSX-示例" class="headerlink" title="JSX 示例"></a>JSX 示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure>

<h3 id="TSX-示例"><a href="#TSX-示例" class="headerlink" title="TSX 示例"></a>TSX 示例</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComponentProps</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * React.FC&lt;MyComponentProps&gt; 是 TypeScript 中用于定义 React 函数组件的一种类型。</span></span><br><span class="line"><span class="comment">    React.FC 是 React.FunctionComponent 的缩写，它是一个泛型，可以接受一个对象作为参数，这个对象描述了组件的属性类型。</span></span><br><span class="line"><span class="comment">    MyComponentProps 是你自定义的一个接口或类型，用来定义组件接收的 props 类型。</span></span><br><span class="line"><span class="comment">    使用 React.FC&lt;MyComponentProps&gt; 有以下好处：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    明确指定了组件的 props 类型，增强了代码的可读性和可维护性。</span></span><br><span class="line"><span class="comment">    提供了更好的编辑器支持，如自动补全和类型检查。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ** /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> // 推荐使用</span></span><br><span class="line"><span class="comment">const MyComponent: React.FC&lt;MyComponentProps&gt; = (&#123; name &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="comment">    return (</span></span><br><span class="line"><span class="comment">        &lt;div&gt;</span></span><br><span class="line"><span class="comment">            &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;/div&gt;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">export default MyComponent;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">或者</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">export function MyComponent(props: MyComponentProps) &#123;</span></span><br><span class="line"><span class="comment">    return (</span></span><br><span class="line"><span class="comment">        &lt;div&gt;</span></span><br><span class="line"><span class="comment">            &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;/div&gt;</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<h3 id="5-编译和工具支持"><a href="#5-编译和工具支持" class="headerlink" title="5. 编译和工具支持"></a>5. 编译和工具支持</h3><ul>
<li><strong>JSX</strong>: 使用 Babel 等工具进行编译，通常与 Webpack 或其他模块打包工具结合使用。</li>
<li><strong>TSX</strong>: 使用 TypeScript 编译器（tsc）进行编译，同时可以与 Babel 结合使用以支持更广泛的浏览器兼容性。</li>
</ul>
<h3 id="6-性能"><a href="#6-性能" class="headerlink" title="6. 性能"></a>6. 性能</h3><ul>
<li><strong>JSX</strong> 和 <strong>TSX</strong> 在运行时性能上没有显著差异，因为最终都会被编译为普通的 JavaScript 代码。但是，TSX 提供了更好的开发时体验，减少了潜在的类型错误。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果你希望在 React 项目中使用 TypeScript 进行类型检查和增强的开发体验，建议使用 <code>.tsx</code> 文件。</li>
<li>如果你只需要简单的 JSX 语法且不需要 TypeScript 的类型检查，可以选择 <code>.jsx</code> 文件。</li>
</ul>
<p>在现代 React 开发中，推荐使用 <code>.tsx</code> 文件，因为它提供了更好的类型安全性和开发体验。</p>
<h2 id="tsx-中-extends-React-Component-使用举例"><a href="#tsx-中-extends-React-Component-使用举例" class="headerlink" title="tsx 中 extends React.Component 使用举例"></a>tsx 中 extends React.Component 使用举例</h2><p>在 TypeScript 中，如果你使用 <code>tsx</code> 文件并希望定义一个继承自 <code>React.Component</code> 的类组件，你可以按照以下步骤进行。假设你已经安装了 <code>react</code> 和 <code>react-dom</code>，并且已经正确配置了 <code>tsconfig.json</code> 以支持 JSX。</p>
<p>以下是一个简单的例子：</p>
<ol>
<li><p>首先，确保你已经安装了 <code>@types/react</code> 和 <code>@types/react-dom</code>，以便 TypeScript 能够识别 React 类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/react @types/react-dom</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个 <code>.tsx</code> 文件，例如 <code>MyComponent.tsx</code>，并在其中定义一个继承自 <code>React.Component</code> 的类组件。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComponentProps</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComponentState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="title class_">MyComponentProps</span>, <span class="title class_">MyComponentState</span>&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">props</span>: <span class="title class_">MyComponentProps</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  incrementCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;this.state.count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.incrementCount&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在这个例子中：</p>
<ul>
<li><code>MyComponentProps</code> 定义了组件的 props 类型。</li>
<li><code>MyComponentState</code> 定义了组件的状态类型。</li>
<li><code>MyComponent</code> 类继承自 <code>React.Component</code>，并指定了 props 和 state 的类型。</li>
<li><code>incrementCount</code> 方法用于更新组件的状态。</li>
<li><code>render</code> 方法返回组件的 JSX 结构。</li>
</ul>
<p>确保你的 <code>tsconfig.json</code> 文件配置正确，以便支持 JSX 语法。你可以在 <code>compilerOptions</code> 中添加 <code>&quot;jsx&quot;: &quot;react&quot;</code> 来明确指定 JSX 的处理方式。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2016&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;es2016&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dom&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CommonJS&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noEmitOnError&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样配置后，TypeScript 就能够正确处理 <code>.tsx</code> 文件中的 JSX 语法。</p>
<h2 id="TS-VUE3"><a href="#TS-VUE3" class="headerlink" title="TS + VUE3"></a>TS + VUE3</h2><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/typescript/composition-api.html">https://cn.vuejs.org/guide/typescript/composition-api.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/20/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%93%8D%E4%BD%9Cdom%E6%8E%A7%E5%88%B6vue-element-%E4%B8%AD-el-input-%E7%9A%84%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/20/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%93%8D%E4%BD%9Cdom%E6%8E%A7%E5%88%B6vue-element-%E4%B8%AD-el-input-%E7%9A%84%E5%80%BC/" class="post-title-link" itemprop="url">油猴脚本中操作dom控制vue-element 中 el-input 的值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-20 09:06:08" itemprop="dateCreated datePublished" datetime="2024-12-20T09:06:08+08:00">2024-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">工具集合</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要使用油猴插件（Tampermonkey）修改Vue-Element的el-input的值，关键在于理解Vue的响应式原理和事件触发机制。以下是具体的步骤和代码示例：</p>
<ol>
<li>获取el-input元素：首先，你需要定位到页面中的el-input元素。可以使用CSS选择器来获取这个元素。</li>
<li>修改值：直接设置input元素的value属性是不够的，因为这样不会触发Vue的响应式更新。你需要手动触发一个input事件来通知Vue更新其数据。</li>
<li>触发事件：创建一个新的Event对象，并使用dispatchEvent方法来触发input事件，这样Vue就能检测到输入框的值变化。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         login</span></span><br><span class="line"><span class="comment">// @namespace    https://192.168.40.51:8000</span></span><br><span class="line"><span class="comment">// @version      2024-12-20</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       jason</span></span><br><span class="line"><span class="comment">// @match        https://192.168.40.51:8000/*</span></span><br><span class="line"><span class="comment">// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// @run-at       document-idle</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello login&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> userName = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.el-input__inner&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (userName) &#123;</span><br><span class="line">            userName.<span class="property">value</span> = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">            userName.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>, &#123; <span class="attr">bubbles</span>: <span class="literal">true</span>, <span class="attr">cancelable</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Username input not found&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> passWord = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.el-input__inner&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (passWord) &#123;</span><br><span class="line">            passWord.<span class="property">value</span> = <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">            passWord.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>, &#123; <span class="attr">bubbles</span>: <span class="literal">true</span>, <span class="attr">cancelable</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Password input not found&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.el-button&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截所有ajax请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// ==UserScript==</span><br><span class="line">// @name         拦截所有ajax请求</span><br><span class="line">// @namespace    https://192.168.40.51:8000</span><br><span class="line">// @version      2024-12-20</span><br><span class="line">// @description  try to take over the world!</span><br><span class="line">// @author       jason</span><br><span class="line">// @match        http://192.168.40.117:8080/*</span><br><span class="line">// @match        https://192.168.40.51:8000/*</span><br><span class="line">// @match        https://192.168.40.46/*</span><br><span class="line">// @match        http://192.168.40.115:8080/*</span><br><span class="line">// @match        https://192.168.40.116/*</span><br><span class="line">// @match        http://localhost:8000/*</span><br><span class="line">// @match        https://localhost:8000/*</span><br><span class="line">// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==</span><br><span class="line">// @grant        none</span><br><span class="line">// @run-at       document-start</span><br><span class="line">// ==/UserScript==</span><br><span class="line"></span><br><span class="line">(function() &#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">    // 保存原始的 XMLHttpRequest 方法</span><br><span class="line">    const originalOpen = XMLHttpRequest.prototype.open;</span><br><span class="line">    const originalSend = XMLHttpRequest.prototype.send;</span><br><span class="line">    const originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;</span><br><span class="line"></span><br><span class="line">    // 重写 open 方法</span><br><span class="line">    XMLHttpRequest.prototype.open = function(method, url, async) &#123;</span><br><span class="line">        this._method = method;</span><br><span class="line">        this._url = url;</span><br><span class="line">        this._async = async;</span><br><span class="line">        this._requestHeaders = &#123;&#125;; // 用于存储请求头</span><br><span class="line">        this._requestData = null; // 用于存储请求体</span><br><span class="line">        originalOpen.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 重写 setRequestHeader 方法</span><br><span class="line">    XMLHttpRequest.prototype.setRequestHeader = function(header, value) &#123;</span><br><span class="line">        this._requestHeaders[header] = value;</span><br><span class="line">        originalSetRequestHeader.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 重写 send 方法</span><br><span class="line">    XMLHttpRequest.prototype.send = function(data) &#123;</span><br><span class="line">        // 捕获请求体</span><br><span class="line">        if (data instanceof FormData) &#123;</span><br><span class="line">            const formData = new FormData();</span><br><span class="line">            data.forEach((value, key) =&gt; &#123;</span><br><span class="line">                formData.append(key, value);</span><br><span class="line">            &#125;);</span><br><span class="line">            this._requestData = formData;</span><br><span class="line">        &#125; else if (data instanceof Blob || data instanceof ArrayBuffer) &#123;</span><br><span class="line">            this._requestData = data;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this._requestData = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.addEventListener(&#x27;load&#x27;, function() &#123;</span><br><span class="line">            console.log(&#x27;AJAX Request:&#x27;, &#123;</span><br><span class="line">                method: this._method,</span><br><span class="line">                url: this._url,</span><br><span class="line">                async: this._async,</span><br><span class="line">                requestHeaders: this._requestHeaders, // 添加请求头信息</span><br><span class="line">                requestData: this._requestData, // 添加请求体信息</span><br><span class="line">                response: this.responseText,</span><br><span class="line">                status: this.status,</span><br><span class="line">                statusText: this.statusText</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        originalSend.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;hello login&#x27;);</span><br><span class="line">    // 其他代码...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在油猴脚本中，@run-at 元数据块用于指定脚本何时执行。不同的 @run-at 值会影响脚本的执行时机，从而影响脚本的行为和效果。以下是常见的 @run-at 值及其含义：</p>
<p>@run-at document-start</p>
<p>含义：脚本在文档解析开始时立即执行，此时 document.documentElement 可能尚未创建，document.head 也尚未完全加载。<br>适用场景：适用于需要在页面加载之前执行某些操作的情况，例如修改页面的初始加载行为。<br>@run-at document-end</p>
<p>含义：脚本在文档解析完成后执行，此时 document.body 已经可用，但所有外部资源（如图片、样式表、子框架等）可能尚未加载完成。<br>适用场景：适用于需要在页面加载完成后执行某些操作的情况，但不需要等待所有外部资源加载完成。<br>@run-at document-idle</p>
<p>含义：脚本在文档解析完成后且所有外部资源（如图片、样式表、子框架等）加载完成后执行。<br>适用场景：适用于需要在页面完全加载后执行某些操作的情况，确保所有资源都已加载完毕。</p>
<p>注意匹配规则设置</p>
<p>&#x2F;&#x2F; @match        <a target="_blank" rel="noopener" href="http://192.168.40.117:8080/">http://192.168.40.117:8080/</a>*<br>&#x2F;&#x2F; @match        <a target="_blank" rel="noopener" href="https://192.168.40.51:8000/">https://192.168.40.51:8000/</a>*<br>&#x2F;&#x2F; @match        <a target="_blank" rel="noopener" href="https://192.168.40.46/">https://192.168.40.46/</a>*<br>&#x2F;&#x2F; @match        <a target="_blank" rel="noopener" href="http://192.168.40.115:8080/">http://192.168.40.115:8080/</a>*</p>
<p>http https 要区分 <a target="_blank" rel="noopener" href="https://192.168.40.46/">https://192.168.40.46/</a>* 改为 <a target="_blank" rel="noopener" href="https://192.168.40.*/">https://192.168.40.*/</a>* 不生效</p>
<p>与其他库（如react）集成： 当你需要与不基于 Vue 的库或框架集成时，可能会用到 dispatchEvent 来触发特定的事件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">工程化问题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-19 09:49:12" itemprop="dateCreated datePublished" datetime="2024-12-19T09:49:12+08:00">2024-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>下面的模块导出了什么结果？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">b</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">c</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>说一下你对前端工程化，模块化，组件化的理解？</p>
<blockquote>
<p>参考答案：</p>
<p>这三者中，模块化是基础，没有模块化，就没有组件化和工程化</p>
<p>模块化的出现，解决了困扰前端的两大难题：全局污染问题和依赖混乱问题，从而让精细的拆分前端工程成为了可能。</p>
<p>工程化的出现，解决了前端开发环境和生产环境要求不一致的矛盾。在开发环境中，我们希望代码使用尽可能的细分，代码格式尽可能的统一和规范，而在生产环境中，我们希望代码尽可能的被压缩、混淆，尽可能的优化体积。工程化的出现，就是为了解决这一矛盾，它可以让我们舒服的在开发环境中书写代码，然后经过打包，生成最合适的生产环境代码，这样就解放了开发者的精力，让开发者把更多的注意力集中在开发环境上即可。</p>
<p>组件化开发是一些前端框架带来的概念，它把一个网页，或者一个站点，甚至一个完整的产品线，划分为多个小的组件，组件是一个可以复用的单元，它包含了一个某个区域的完整功能。这样一来，前端便具备了开发复杂应用的能力。</p>
</blockquote>
</li>
<li><p>webpack 和 gulp 的区别是什么？</p>
<blockquote>
<p>直播讲解</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>webpack 是基于模块化的构建工具，gulp 是基于工作流的构建工具。</p>
<p>webpack 是一个打包器，它以一个入口为起点，构建出整个项目的依赖关系图，然后进行打包合并，生成打包结果。</p>
<p>gulp 是一个过程管理器，每一步做什么完全看开发人员如何配置，把每一个步骤连接起来形成一个完整的构建流水线。</p>
<p>这两者并不矛盾，完全可以在一个工程中同时使用 webpack 和 gulp，将 webpack 作为 gulp 流水线中的一环。</p>
</blockquote>
</li>
<li><p>webpack 中的 loader 属性和 plugins 属性的区别是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>它们都是 webpack 功能的扩展点。</p>
<p>loader 是加载器，主要用于代码转换，比如 JS 代码降级，CSS 预编译、模块化等</p>
<p>plugins 是插件，webpack 打包流程中每个环节都提供了钩子函数，可以利用这些钩子函数参与到打包生命周期中，更改或增加 webpack 的某些功能，比如生成页面和 css 文件、压缩打包结果等</p>
</blockquote>
</li>
<li><p>webpack 的核心概念都有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>loader</p>
<p>加载器，主要用于代码转换，比如 JS 代码降级，CSS 预编译、模块化等</p>
</li>
<li><p>plugin</p>
<p>插件，webpack 打包流程中每个环节都提供了钩子函数，可以利用这些钩子函数参与到打包生命周期中，更改或增加 webpack 的某些功能，比如生成页面和 css 文件、压缩打包结果等</p>
</li>
<li><p>module</p>
<p>模块。webpack 将所有依赖均视为模块，无论是 js、css、html、图片，统统都是模块</p>
</li>
<li><p>entry</p>
<p>入口。打包过程中的概念，webpack 以一个或多个文件作为入口点，分析整个依赖关系。</p>
</li>
<li><p>chunk</p>
<p>打包过程中的概念，一个 chunk 是一个相对独立的打包过程，以一个或多个文件为入口，分析整个依赖关系，最终完成打包合并</p>
</li>
<li><p>bundle</p>
<p>webpack 打包结果</p>
</li>
<li><p>tree shaking</p>
<p>树摇优化。在打包结果中，去掉没有用到的代码。</p>
</li>
<li><p>HMR</p>
<p>热更新。是指在运行期间，遇到代码更改后，无须重启整个项目，只更新变动的那一部分代码。</p>
</li>
<li><p>dev server</p>
<p>开发服务器。在开发环境中搭建的临时服务器，用于承载对打包结果的访问</p>
</li>
</ul>
</blockquote>
</li>
<li><p>commonjs 和 es6 模块的区别是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>CMJ 是社区标准，ESM 是官方标准</li>
<li>CMJ 是使用 API 实现的模块化，ESM 是使用新语法实现的模块化</li>
<li>CMJ 仅在 node 环境中支持，ESM 各种环境均支持</li>
<li>CMJ 是动态的依赖，ESM 既支持动态，也支持静态</li>
<li>ESM 导入时有符号绑定，CMJ 只是普通函数调用和赋值</li>
</ol>
</blockquote>
</li>
<li><p>ES6 中如何实现模块化的异步加载？</p>
<blockquote>
<p>参考答案：</p>
<p>使用动态导入即可，导入后，得到的是一个 Promise，完成后，得到一个模块对象，其中包含了所有的导出结果。</p>
</blockquote>
</li>
<li><p>说一下 webpack 中的几种 hash 的实现原理是什么？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>hash</p>
<p>hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值</p>
</li>
<li><p>chunkhash</p>
<p>每个打包过程单独的 hash 值，如果一个项目有多个 entry，则每个 entry 维护自己的 chunkhash。</p>
</li>
<li><p>contenthash</p>
<p>每个文件内容单独的 hash 值，它和打包结果文件内容有关，只要文件内容不变，contenthash 不变。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>webpack 如果使用了 hash 命名，那是每次都会重新生成 hash 吗？</p>
<blockquote>
<p>参考答案：</p>
<p>不会。它跟关联的内容是否有变化有关系，如果没有变化，hash 就不会变。具体来说，contenthash 和具体的打包文件内容有关，chunkhash 和某一 entry 为起点的打包过程中涉及的内容有关，hash 和整个工程所有模块内容有关。</p>
</blockquote>
</li>
<li><p>webpack 中是如何处理图片的？ （抖音直播）</p>
<blockquote>
<p>参考答案：</p>
<p>webpack 本身不处理图片，它会把图片内容仍然当做 JS 代码来解析，结果就是报错，打包失败。如果要处理图片，需要通过 loader 来处理。其中，url-loader 会把图片转换为 base64 编码，然后得到一个 dataurl，file-loader 则会将图片生成到打包目录中，然后得到一个资源路径。但无论是哪一种 loader，它们的核心功能，都是把图片内容转换成 JS 代码，因为只有转换成 JS 代码，webpack 才能识别。</p>
</blockquote>
</li>
<li><p>webpack 打包出来的 html 为什么 style 放在头部 script 放在底部？</p>
<blockquote>
<p>说明：这道题的表述是有问题的，webpack 本身并不打包 html，相反，它如果遇到 html 代码会直接打包失败，因为 webpack 本身只能识别 JS。之所以能够打包出 html 文件，是因为插件或 loader 的作用，其中，比较常见的插件是 html-webpack-plugin。所以这道题的正确表述应该是：「html-webpack-plugin 打包出来的 html 为什么 style 放在头部 script 放在底部？」</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>浏览器在解析 HTML 时是从上到下进行解析的，当遇到样式和 JS 时，都会停止 HTML 解析，转而解析样式和执行 JS。而我们往往希望，页面的样式解析完成后再解析 HTML，这样可以避免页面闪烁，基于此，样式应该放到顶部；而相反的，我们希望在解析完 HTML 后再执行 JS，这样可以让用户尽快的看到页面，同时也让 JS 执行时能够拿到完整的 DOM 树，基于此，JS 代码应该放到底部。</p>
<p>不过，在 HTML5 中出现了 async 和 defer 属性，使用该属性可以更好的解决 JS 的问题，我们可以把 script 放到顶部，让浏览器尽快下载，但延迟执行。实际上，在新版本的 html-webpack-plugin 中，它已经这样做了。</p>
</blockquote>
</li>
<li><p>webpack 配置如何实现开发环境不使用 cdn、生产环境使用 cdn？</p>
<blockquote>
<p>要配置 CDN，有两个步骤：</p>
<ol>
<li>在 html 模板中直接加入 cdn 引用</li>
<li>在 webpack 配置中，加入<code>externals</code>配置，告诉 webpack 不要打包其中的模块，转而使用全局变量</li>
</ol>
<p>若要在开发环境中不使用 CDN，只需根据环境变量判断不同的环境，进行不同的打包处理即可。</p>
<ol>
<li>在 html 模板中使用 ejs 模板语法进行判断，只有在生产环境中引入 CDN</li>
<li>在 webpack 配置中，可以根据<code>process.env</code>中的环境变量进行判断是否使用<code>externals</code>配置</li>
<li>在<code>package.json</code>脚本中设置不同的环境变量完成打包或开发启动。</li>
</ol>
</blockquote>
</li>
<li><p>介绍一下 webpack4 中的 tree-shaking 的工作流程？</p>
<blockquote>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/tree-shaking">https://tsejx.github.io/webpack-guidebook/principle-analysis/operational-principle/tree-shaking</a></p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>tree-shaking 仅支持 ESM 的静态导入语法，对于 CMJ 或者 ESM 中的动态导入不支持 tree shaking。</p>
<p>具体流程主要分为两步：标记和删除</p>
<ol>
<li><p>标记</p>
<p>webpack 在分析依赖时，会使用注释的方式对导入和导出进行标记，对于模块中没有被其他模块用到的导出标记为 unused harmony export</p>
</li>
<li><p>删除</p>
<p>之后在 Uglifyjs (或者其他类似的工具) 步骤进行代码精简，把标记为无用的代码删除。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>说一下 webpack loader 的作用是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>用于转换代码。有时是因为 webpack 无法识别某些内容，比如图片、css 等，需要由 loader 将其转换为 JS 代码。有时是因为某些代码需要被特殊处理，比如 JS 兼容性的处理，需要由 loader 将其进一步转换。不管是什么情况，loader 的作用只有一个，就是转换代码。</p>
</blockquote>
</li>
<li><p>在开发过程中如果需要对已有模块进行扩展，如何进行开发保证调用方不受影响？</p>
<blockquote>
<p>参考答案：</p>
<p>实际上就是一个版本管理的问题。</p>
<p>如果此次模块升级只是修复了某一些 bug，作为补丁版本升级即可，不影响主版本和次版本号</p>
<p>如果此次模块升级会新增一些内容，完全兼容之前的 API，作为次版本升级即可</p>
<p>如果此次模块升级会修改之前的 API，则作为主版本升级</p>
<p>在开发项目时，让项目依赖模块的主版本，因此，当模块更新时，只要不是主版本更新，项目都可以非常方便的升级模块版本，无须改动任何代码。但若涉及主版本更新，项目可以完全无视此次版本更新，仍然使用之前的旧版本，无须改动任何代码；当然也可以升级主版本，但就会涉及代码的改动，这就好比跟将 vue2 升级到 vue3 会涉及大量改动一样。</p>
<p>而在开发模块时，在一开始就要精心设计 API，尽量保证 API 的接口稳定，不要经常变动主版本号。如果实在要更新主版本，就需要在一段时间内同时维护两个版本（新的主版本，旧的主版本），给予其他项目一定的升级时间。</p>
</blockquote>
</li>
<li><p>export 和 export default 的区别是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>export 为普通导出，又叫做具名导出，顾名思义，它导出的数据必须带有命名，比如变量定义、函数定义这种带有命名的语句。在导出的模块对象中，命名即为模块对象的属性名。在一个模块中可以有多个具名导出</p>
<p>export default 为默认导出，在模块对象中名称固定为 default，因此无须命名，通常导出一个表达式或字面量。在一个模块中只能有一个默认导出。</p>
</blockquote>
</li>
<li><p>webpack 打包原理是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译</li>
<li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件</li>
<li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再把翻译后的内容转换成 AST，通过对 AST 的分析找出该模块依赖的模块，再 <code>递归</code> 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li><strong>完成模块编译</strong>：在经过第 4 步使用 <code>loader</code> 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的 <code>依赖关系图</code></li>
<li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</blockquote>
</li>
<li><p>webpack 热更新原理是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>当开启热更新后，页面中会植入一段 websocket 脚本，同时，开发服务器也会和客户端建立 websocket 通信，当源码发生变动时，webpack 会进行以下处理：</p>
<ol>
<li>webpack 重新打包</li>
<li>webpack-dev-server 检测到模块的变化，于是通过 webscoket 告知客户端变化已经发生</li>
<li>客户端收到消息后，通过 ajax 发送请求到开发服务器，以过去打包的 hash 值请求服务器的一个 json 文件</li>
<li>服务器告诉客户端哪些模块发生了变动，同时告诉客户端这次打包产生的新 hash 值</li>
<li>客户端再次用过去的 hash 值，以 JSONP 的方式请求变动的模块</li>
<li>服务器响应一个函数调用，用于更新模块的代码</li>
<li>此时，模块代码已经完成更新。客户端按照之前的监听配置，执行相应模块变动后的回调函数。</li>
</ol>
</blockquote>
</li>
<li><p>如何优化 webpack 的打包速度？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>noParse</p>
<p>很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库</p>
</li>
<li><p>externals</p>
<p>对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包</p>
</li>
<li><p>限制 loader 的范围</p>
<p>在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉</p>
</li>
<li><p>开启 loader 缓存</p>
<p>可以利用<code>cache-loader</code>缓存 loader 的编译结果，避免在源码没有变动时反复编译</p>
</li>
<li><p>开启多线程编译</p>
<p>可以利用<code>thread-loader</code>开启多线程编译，提升编译效率</p>
</li>
<li><p>动态链接库</p>
<p>对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库</p>
</li>
</ol>
</blockquote>
</li>
<li><p>webpack 如何实现动态导入？</p>
<blockquote>
<p>参考答案：</p>
<p>当遇到代码中包含动态导入语句时，webpack 会将导入的模块及其依赖分配到单独的一个 chunk 中进行打包，形成单独的打包结果。而动态导入的语句会被编译成一个普通的函数调用，该函数在执行时，会使用 JSONP 的方式动态的把分离出去的包加载到模块集合中。</p>
</blockquote>
</li>
<li><p>说一下 webpack 有哪几种文件指纹</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>hash</p>
<p>hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值</p>
</li>
<li><p>chunkhash</p>
<p>每个打包过程单独的 hash 值，如果一个项目有多个 entry，则每个 entry 维护自己的 chunkhash。</p>
</li>
<li><p>contenthash</p>
<p>每个文件内容单独的 hash 值，它和打包结果文件内容有关，只要文件内容不变，contenthash 不变。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>常用的 webpack Loader 都有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li>cache-loader：启用编译缓存</li>
<li>thread-loader：启用多线程编译</li>
<li>css-loader：编译 css 代码为 js</li>
<li>file-loader：保存文件到输出目录，将文件内容转换成文件路径</li>
<li>postcss-loader：将 css 代码使用 postcss 进行编译</li>
<li>url-loader：将文件内容转换成 dataurl</li>
<li>less-loader：将 less 代码转换成 css 代码</li>
<li>sass-loader：将 sass 代码转换成 css 代码</li>
<li>vue-loader：编译单文件组件</li>
<li>babel-loader：对 JS 代码进行降级处理</li>
</ul>
</blockquote>
</li>
<li><p>说一下 webpack 常用插件都有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li>clean-webpack-plugin：清除输出目录</li>
<li>copy-webpack-plugin：复制文件到输出目录</li>
<li>html-webpack-plugin：生成 HTML 文件</li>
<li>mini-css-extract-plugin：将 css 打包成单独文件的插件</li>
<li>HotModuleReplacementPlugin：热更新的插件</li>
<li>purifycss-webpack：去除无用的 css 代码</li>
<li>optimize-css-assets-webpack-plugin：优化 css 打包体积</li>
<li>uglify-js-plugin：对 JS 代码进行压缩、混淆</li>
<li>compression-webpack-plugin：gzip 压缩</li>
<li>webpack-bundle-analyzer：分析打包结果</li>
</ul>
</blockquote>
</li>
<li><p>使用 babel-loader 会有哪些问题，可以怎样优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>如果不做特殊处理，babel-loader 会对所有匹配的模块进行降级，这对于那些已经处理好兼容性问题的第三方库显得多此一举，因此可以使用 exclude 配置排除掉这些第三方库</li>
<li>在旧版本的 babel-loader 中，默认开启了对 ESM 的转换，这样会导致 webpack 的 tree shaking 失效，因为 tree shaking 是需要保留 ESM 语法的，所以需要关闭 babel-loader 的 ESM 转换，在其新版本中已经默认关闭了。</li>
</ol>
</blockquote>
</li>
<li><p>babel 是如何对 class 进行编译的？</p>
<blockquote>
<p>参考答案：</p>
<p>本质上就是把 class 语法转换成普通构造函数定义，并做了以下处理：</p>
<ol>
<li>增加了对 this 指向的检测</li>
<li>将原型方法和静态方法变为不可枚举</li>
<li>将整个代码放到了立即执行函数中，运行后返回构造函数本身</li>
</ol>
</blockquote>
</li>
<li><p>解释一下 babel-polyfill 的作用是什么？</p>
<blockquote>
<p>说明：</p>
<p>babel-polyfill 已经是一个非常古老的项目了，babel 从 7.4 版本开始已不再支持它，转而使用更加强大的 core-js，此题也适用于问「core-js 的作用是什么」</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>默认情况下，babel 本身只转换新的语法，而不对新的 API 进行处理。由于旧的环境中无法支持新的 API，比如 IE6 无法支持 fetch api，这就需要一个补丁，用旧语言的特性实现一遍新的 API，babel-polyfill 就是用来做这件事的。</p>
</blockquote>
</li>
<li><p>解释一下 less 的&amp;的操作符是做什么用的？</p>
<blockquote>
<p>参考答案：</p>
<p>&amp;符号后面的内容会和父级选择器合并书写，即中间不加入空格字符</p>
</blockquote>
</li>
<li><p>在前端工程化中，可以进行哪些方面的优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>对传输性能的优化</p>
<ul>
<li><p>压缩和混淆</p>
<p>使用 Uglifyjs 或其他类似工具对打包结果进行压缩、混淆，可以有效的减少包体积</p>
</li>
<li><p>tree shaking</p>
<p>项目中尽量使用 ESM，可以有效利用 tree shaking 优化，降低包体积</p>
</li>
<li><p>抽离公共模块</p>
<p>将一些公共代码单独打包，这样可以充分利用浏览器缓存，其他代码变动后，不影响公共代码，浏览器可以直接从缓存中找到公共代码。</p>
<p>具体方式有多种，比如 dll、splitChunks</p>
</li>
<li><p>异步加载</p>
<p>对一些可以延迟执行的模块可以使用动态导入的方式异步加载它们，这样在打包结果中，它们会形成单独的包，同时，在页面一开始解析时并不需要加载它们，而是页面解析完成后，执行 JS 的过程中去加载它们。</p>
<p>这样可以显著提高页面的响应速度，在单页应用中尤其有用。</p>
</li>
<li><p>CDN</p>
<p>对一些知名的库使用 CDN，不仅可以节省打包时间，还可以显著提升库的加载速度</p>
</li>
<li><p>gzip</p>
<p>目前浏览器普遍支持 gzip 格式，因此可以将静态文件均使用 gzip 进行压缩</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ul>
</li>
<li><p>对打包过程的优化</p>
<ul>
<li><p>noParse</p>
<p>很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库</p>
</li>
<li><p>externals</p>
<p>对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包</p>
</li>
<li><p>限制 loader 的范围</p>
<p>在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉</p>
</li>
<li><p>开启 loader 缓存</p>
<p>可以利用<code>cache-loader</code>缓存 loader 的编译结果，避免在源码没有变动时反复编译</p>
</li>
<li><p>开启多线程编译</p>
<p>可以利用<code>thread-loader</code>开启多线程编译，提升编译效率</p>
</li>
<li><p>动态链接库</p>
<p>对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库</p>
</li>
</ul>
</li>
<li><p>对开发体验的优化</p>
<ul>
<li><p>lint</p>
<p>使用 eslint、stylelint 等工具保证团队代码风格一致</p>
</li>
<li><p>HMR</p>
<p>使用热替换避免页面刷新导致的状态丢失，提升开发体验</p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>如果有一个工程打包特别大-如何进行优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>CDN</p>
<p>如果工程中使用了一些知名的第三方库，可以考虑使用 CDN，而不进行打包</p>
</li>
<li><p>抽离公共模块</p>
<p>如果工程中用到了一些大的公共库，可以考虑将其分割出来单独打包</p>
</li>
<li><p>异步加载</p>
<p>对于那些不需要在一开始就执行的模块，可以考虑使用动态导入的方式异步加载它们，以尽量减少主包的体积</p>
</li>
<li><p>压缩、混淆</p>
</li>
<li><p>tree shaking</p>
<p>尽量使用 ESM 语法进行导入导出，充分利用 tree shaking 去除无用代码</p>
</li>
<li><p>gzip</p>
<p>开启 gzip 压缩，进一步减少包体积</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>webpack 怎么进行首屏加载的优化？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>CDN</p>
<p>如果工程中使用了一些知名的第三方库，可以考虑使用 CDN，而不进行打包</p>
</li>
<li><p>抽离公共模块</p>
<p>如果工程中用到了一些大的公共库，可以考虑将其分割出来单独打包</p>
</li>
<li><p>异步加载</p>
<p>对于那些不需要在一开始就执行的模块，可以考虑使用动态导入的方式异步加载它们，以尽量减少主包的体积</p>
</li>
<li><p>压缩、混淆</p>
</li>
<li><p>tree shaking</p>
<p>尽量使用 ESM 语法进行导入导出，充分利用 tree shaking 去除无用代码</p>
</li>
<li><p>gzip</p>
<p>开启 gzip 压缩，进一步减少包体积</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>介绍一下 webpack scope hoisting？</p>
<blockquote>
<p>参考答案：</p>
<p>scope hoisting 是 webpack 的内置优化，它是针对模块的优化，在生产环境打包时会自动开启。</p>
<p>在未开启scope hoisting时，webpack 会将每个模块的代码放置在一个独立的函数环境中，这样是为了保证模块的作用域互不干扰。</p>
<p>而 scope hoisting 的作用恰恰相反，是把多个模块的代码合并到一个函数环境中执行。在这一过程中，webpack 会按照顺序正确的合并模块代码，同时对涉及的标识符做适当处理以避免重名。</p>
<p>这样做的好处是减少了函数调用，对运行效率有一定提升，同时也降低了打包体积。</p>
<p>但 scope hoisting 的启用是有前提的，如果遇到某些模块多次被其他模块引用，或者使用了动态导入的模块，或者是非 ESM 的模块，都不会有 scope hoisting。</p>
</blockquote>
</li>
<li><p>webpack proxy 工作原理，为什么能解决跨域？</p>
<blockquote>
<p>说明：</p>
<p>严格来说，webpack 只是一个打包工具，它并没有 proxy 的功能，甚至连服务器的功能都没有。之所以能够在 webpack 中使用 proxy 配置，是因为它的一个插件，即 webpack-dev-server 的能力。</p>
<p>所以，此题应该问做：「webpack-dev-server 工作原理，为什么能解决跨域？」</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>首先，proxy 配置是针对开发环境的，对生产环境没有任何意义。</p>
<p>当我们通过 webpack-dev-server 启动开发服务器后，所有的打包资源都可以通过访问开发服务器获得。</p>
<p>与此同时，我们又配置了 proxy，当我们向开发服务器请求特定的地址时，开发服务器会将其代理到目标地址。因此，后续对代理地址的请求，就可以变为直接请求开发服务器。</p>
<p>这样一来，我们请求静态页面的域和请求代理地址的域就同源了，因为都是请求开发服务器，所以就不会产生跨域问题。</p>
</blockquote>
</li>
<li><p>组件发布的是不是所有依赖这个组件库的项目都需要升级？</p>
<blockquote>
<p>参考答案：</p>
<p>实际上就是一个版本管理的问题。</p>
<p>如果此次模块升级只是修复了某一些 bug，作为补丁版本升级即可，不影响主版本和次版本号</p>
<p>如果此次模块升级会新增一些内容，完全兼容之前的 API，作为次版本升级即可</p>
<p>如果此次模块升级会修改之前的 API，则作为主版本升级</p>
<p>在开发项目时，让项目依赖模块的主版本，因此，当模块更新时，只要不是主版本更新，项目都可以非常方便的升级模块版本，无须改动任何代码。但若涉及主版本更新，项目可以完全无视此次版本更新，仍然使用之前的旧版本，无须改动任何代码；当然也可以升级主版本，但就会涉及代码的改动，这就好比跟将 vue2 升级到 vue3 会涉及大量改动一样。</p>
<p>而在开发模块时，在一开始就要精心设计 API，尽量保证 API 的接口稳定，不要经常变动主版本号。如果实在要更新主版本，就需要在一段时间内同时维护两个版本（新的主版本，旧的主版本），给予其他项目一定的升级时间。</p>
</blockquote>
</li>
<li><p>开发过程中，如何进行公共组件的设计？（字节跳动）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>确定使用场景</p>
<p>明确这个公共组件的需求是怎么产生的，它目前的使用场景有哪些，将来还可能出现哪些使用场景。</p>
<p>明确使用场景至关重要，它决定了这个组件的使用边界在哪，通用到什么程度，从而决定了这个组件的开发难度</p>
</li>
<li><p>设计组件功能</p>
<p>根据其使用场景，设计出组件的属性、事件、使用说明文档</p>
</li>
<li><p>测试用例</p>
<p>根据使用说明文档编写组件测试用例</p>
</li>
<li><p>完成开发</p>
<p>根据使用说明文档、测试用例完成开发</p>
</li>
</ol>
</blockquote>
</li>
<li><p>说一下项目里有做过哪些 webpack 上的优化（字节跳动）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>对传输性能的优化</p>
<ul>
<li><p>压缩和混淆</p>
<p>使用 Uglifyjs 或其他类似工具对打包结果进行压缩、混淆，可以有效的减少包体积</p>
</li>
<li><p>tree shaking</p>
<p>项目中尽量使用 ESM，可以有效利用 tree shaking 优化，降低包体积</p>
</li>
<li><p>抽离公共模块</p>
<p>将一些公共代码单独打包，这样可以充分利用浏览器缓存，其他代码变动后，不影响公共代码，浏览器可以直接从缓存中找到公共代码。</p>
<p>具体方式有多种，比如 dll、splitChunks</p>
</li>
<li><p>异步加载</p>
<p>对一些可以延迟执行的模块可以使用动态导入的方式异步加载它们，这样在打包结果中，它们会形成单独的包，同时，在页面一开始解析时并不需要加载它们，而是页面解析完成后，执行 JS 的过程中去加载它们。</p>
<p>这样可以显著提高页面的响应速度，在单页应用中尤其有用。</p>
</li>
<li><p>CDN</p>
<p>对一些知名的库使用 CDN，不仅可以节省打包时间，还可以显著提升库的加载速度</p>
</li>
<li><p>gzip</p>
<p>目前浏览器普遍支持 gzip 格式，因此可以将静态文件均使用 gzip 进行压缩</p>
</li>
<li><p>环境适配</p>
<p>有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。</p>
</li>
</ul>
</li>
<li><p>对打包过程的优化</p>
<ul>
<li><p>noParse</p>
<p>很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库</p>
</li>
<li><p>externals</p>
<p>对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包</p>
</li>
<li><p>限制 loader 的范围</p>
<p>在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉</p>
</li>
<li><p>开启 loader 缓存</p>
<p>可以利用<code>cache-loader</code>缓存 loader 的编译结果，避免在源码没有变动时反复编译</p>
</li>
<li><p>开启多线程编译</p>
<p>可以利用<code>thread-loader</code>开启多线程编译，提升编译效率</p>
</li>
<li><p>动态链接库</p>
<p>对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库</p>
</li>
</ul>
</li>
<li><p>对开发体验的优化</p>
<ul>
<li><p>lint</p>
<p>使用 eslint、stylelint 等工具保证团队代码风格一致</p>
</li>
<li><p>HMR</p>
<p>使用热替换避免页面刷新导致的状态丢失，提升开发体验</p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>具体说一下 splitchunksplugin 的使用场景及使用方法。（字节跳动）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>公共模块</p>
<p>比如某些多页应用会有多个入口，从而形成多个 chunk，而这些 chunk 中用到了一些公共模块，为了减少整体的包体积，可以使用 splitchunksplugin 将公共模块分离出来。</p>
<p>可以配置 minChunks 来指定被多少个 chunk 引用时进行分包</p>
</li>
<li><p>并行下载</p>
<p>由于 HTML5 支持 defer 和 async，因此可以同时下载多个 JS 文件以充分利用带宽。如果打包结果是一个很大的文件，就无法利用到这一点。</p>
<p>可以利用 splitchunks 插件将文件进行拆分，通过配置 maxSize 属性指定包体积达到多大时进行拆分</p>
</li>
</ol>
</blockquote>
</li>
<li><p>描述一下 webpack 的构建流程？（CVTE）</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译</li>
<li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件</li>
<li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再把翻译后的内容转换成 AST，通过对 AST 的分析找出该模块依赖的模块，再 <code>递归</code> 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li><strong>完成模块编译</strong>：在经过第 4 步使用 <code>loader</code> 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的 <code>依赖关系图</code></li>
<li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</blockquote>
</li>
<li><p>解释一下 webpack 插件的实现原理？（CVTE）</p>
<blockquote>
<p>参考答案：</p>
<p>本质上，webpack 的插件是一个带有<code>apply</code>函数的对象。当 webpack 创建好 compiler 对象后，会执行注册插件的 apply 函数，同时将 compiler 对象作为参数传入。</p>
<p>在 apply 函数中，开发者可以通过 compiler 对象监听多个钩子函数的执行，不同的钩子函数对应 webpack 编译的不同阶段。当 webpack 进行到一定阶段后，会调用这些监听函数，同时将 compilation 对象传入。开发者可以使用 compilation 对象获取和改变 webpack 的各种信息，从而影响构建过程。</p>
</blockquote>
</li>
<li><p>有用过哪些插件做项目的分析吗？（CVTE）</p>
<blockquote>
<p>参考答案：</p>
<p>用过 webpack-bundle-analyzer 分析过打包结果，主要用于优化项目打包体积</p>
</blockquote>
</li>
<li><p>什么是 babel，有什么作用？</p>
<blockquote>
<p>参考答案：</p>
<p>babel 是一个 JS 编译器，主要用于将下一代的 JS 语言代码编译成兼容性更好的代码。</p>
<p>它其实本身做的事情并不多，它负责将 JS 代码编译成为 AST，然后依托其生态中的各种插件对 AST 中的语法和 API 进行处理</p>
</blockquote>
</li>
<li><p>解释一下 npm 模块安装机制是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>npm 会检查本地的 node_modules 目录中是否已经安装过该模块，如果已经安装，则不再重新安装</li>
<li>npm 检查缓存中是否有相同的模块，如果有，直接从缓存中读取安装</li>
<li>如果本地和缓存中均不存在，npm 会从 registry 指定的地址下载安装包，然后将其写入到本地的 node_modules 目录中，同时缓存起来。</li>
</ol>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/network%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/network%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">network问题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-19 09:45:52" itemprop="dateCreated datePublished" datetime="2024-12-19T09:45:52+08:00">2024-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>简述 TCP 连接的过程（淘系）</p>
<blockquote>
<p>参考答案：</p>
<p>TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：</p>
<p>首先服务器进入监听状态，然后即可处理连接</p>
<p>第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。</p>
<p>第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。</p>
<p>第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。</p>
<p>最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成</p>
</blockquote>
</li>
<li><p>介绍下 HTTPS 中间人攻击</p>
<blockquote>
<p>参考答案：</p>
<p>针对 HTTPS 攻击主要有 SSL 劫持攻击和 SSL 剥离攻击两种。</p>
<p>SSL 劫持攻击是指攻击者劫持了客户端和服务器之间的连接，将服务器的合法证书替换为伪造的证书，从而获取客户端和服务器之间传递的信息。这种方式一般容易被用户发现，浏览器会明确的提示证书错误，但某些用户安全意识不强，可能会点击继续浏览，从而达到攻击目的。</p>
<p>SSL 剥离攻击是指攻击者劫持了客户端和服务器之间的连接，攻击者保持自己和服务器之间的 HTTPS 连接，但发送给客户端普通的 HTTP 连接，由于 HTTP 连接是明文传输的，即可获取客户端传输的所有明文数据。</p>
</blockquote>
</li>
<li><p>介绍下 <code>http1.0</code>、<code>http1.1</code>、<code>http2.0</code> 协议的区别？</p>
<blockquote>
<p>参考答案：</p>
<p>首先说 http1.0</p>
<p>它的特点是每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：</p>
<ol>
<li><p>无法复用连接</p>
<p>每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低</p>
</li>
<li><p>队头阻塞</p>
<p>如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。</p>
</li>
</ol>
<p>然后是 http1.1</p>
<p>http1.1 是 http1.0 的改进版，它做出了以下改进：</p>
<ol>
<li><p>长连接</p>
<p>http1.1 允许在请求时增加请求头<code>connection:keep-alive</code>，这样便允许后续的客户端请求在一段时间内复用之前的 TCP 连接</p>
</li>
<li><p>管道化</p>
<p>基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回。</p>
</li>
<li><p>缓存处理</p>
<p>新增响应头 cache-control，用于实现客户端缓存。</p>
</li>
<li><p>断点传输</p>
<p>在上传&#x2F;下载资源时，如果资源过大，将其分割为多个部分，分别上传&#x2F;下载，如果遇到网络故障，可以从已经上传&#x2F;下载好的地方继续请求，不用从头开始，提高效率</p>
</li>
</ol>
<p>最后是 http2.0</p>
<p>http2.0 进一步优化了传输效率，它主要有以下改进：</p>
<ol>
<li><p>二进制分帧</p>
<p>将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装</p>
</li>
<li><p>多路复用</p>
<p>基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序</p>
</li>
<li><p>头部压缩</p>
<p>http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量</p>
</li>
<li><p>服务器推</p>
<p>http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求</p>
</li>
</ol>
</blockquote>
</li>
<li><p>为什么 HTTP1.1 不能实现多路复用（腾讯）</p>
<blockquote>
<p>参考答案：</p>
<p>HTTP&#x2F;1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。</p>
</blockquote>
</li>
<li><p>简单讲解一下 http2 的多路复用（网易）</p>
<blockquote>
<p>参考答案：</p>
<p>在 HTTP&#x2F;2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
</blockquote>
</li>
<li><p>谈谈你对 TCP 三次握手和四次挥手的理解</p>
<blockquote>
<p>TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：</p>
<p>首先服务器进入监听状态，然后即可处理连接</p>
<p>第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。</p>
<p>第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。</p>
<p>第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。</p>
<p>最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成</p>
<p>当需要关闭连接时，需要进行四次挥手才能关闭</p>
<ol>
<li>Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。</li>
<li>Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。</li>
<li>Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。</li>
<li>Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。</li>
<li>Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。</li>
<li>Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。</li>
</ol>
</blockquote>
</li>
<li><p>介绍 HTTPS 握手过程</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li>
<li>服务器响应公钥和服务器证书</li>
<li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li>
<li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li>
<li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li>
<li>后续客户端和服务器使用会话密钥加密信息传递消息</li>
</ol>
</blockquote>
</li>
<li><p>HTTPS 握手过程中，客户端如何验证证书的合法性</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>校验证书的颁发机构是否受客户端信任。</li>
<li>通过 CRL 或 OCSP 的方式校验证书是否被吊销。</li>
<li>对比系统时间，校验证书是否在有效期内。</li>
<li>通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。</li>
</ol>
</blockquote>
</li>
<li><p>Http 状态码 301 和 302 的应用场景分别是什么</p>
<blockquote>
<p>参考答案：</p>
<p>301 表示永久重定向，302 表示临时重定向。</p>
<p>如果浏览器收到的是 301，则会缓存重定向的地址，之后不会再重新请求服务器，直接使用缓存的地址请求，这样可以减少请求次数。</p>
<p>但如果浏览器收到的是 302，则不会缓存重定向地址，浏览器将来会继续以原有地址请求。</p>
<p>因此，301 适合地址永久转移的场景，比如域名变更；而 302 适合临时转移的场景，比如首页临时跳转到活动页</p>
</blockquote>
</li>
<li><p>cookie 和 token 都存放在 header 中，为什么不会劫持 token？</p>
<blockquote>
<p>参考答案：</p>
<p>由于浏览器会自动发送 cookie 到服务器，因此攻击者可以利用这种特点进行 csrf 攻击。</p>
<p>而通常 token 是不放到 cookie 中的，需要浏览器端使用 JS 自行保存到 localstorage 中，在请求时也需要手动的加入到请求头中，因此不容易引发 csrf 攻击。</p>
</blockquote>
</li>
<li><p>介绍下如何实现 token 加密</p>
<blockquote>
<p>参考答案：</p>
<p>以最常见的 token 格式 jwt 为例</p>
<p>token 分为三段，分别是 header、payload、signature</p>
<p>其中，header 标识签名算法和令牌类型；payload 标识主体信息，包含令牌过期时间、发布时间、发行者、主体内容等；signature 是使用特定的算法对前面两部分进行加密，得到的加密结果。</p>
<p>token 有防篡改的特点，如果攻击者改动了前面两个部分，就会导致和第三部分对应不上，使得 token 失效。而攻击者不知道加密秘钥，因此又无法修改第三部分的值。</p>
<p>所以，在秘钥不被泄露的前提下，一个验证通过的 token 是值得被信任的。</p>
</blockquote>
</li>
<li><p>说下单点登录（新东方）</p>
<blockquote>
<p>参考答案：</p>
<p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过 passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，在一定时间内可以无需再次向 passport 发起认证。</p>
<p>具体流程是：</p>
<ol>
<li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li>
<li>sso 认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</li>
<li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 1</li>
<li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统 2 的受保护资源</li>
<li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li>
<li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</li>
<li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 2</li>
<li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</li>
</ol>
</blockquote>
</li>
<li><p>http1.1 是如何复用 tcp 连接的？（网易）</p>
<blockquote>
<p>参考答案：</p>
<p>客户端请求服务器时，通过请求行告诉服务器使用的协议是 http1.1，同时在请求头中附带<code>connection:keep-alive</code>（为保持兼容），告诉服务器这是一个长连接，后续请求可以重复使用这一次的 TCP 连接。</p>
<p>这样做的好处是减少了三次握手和四次挥手的次数，一定程度上提升了网络利用率。但由于 http1.1 不支持多路复用，响应顺序必须按照请求顺序抵达客户端，不能真正实现并行传输，因此在 http2.0 出现之前，实际项目中往往把静态资源，比如图片，分发到不同域名下的资源服务器，以便实现真正的并行传输。</p>
</blockquote>
</li>
<li><p>文件上传如何做断点续传（网易）</p>
<blockquote>
<p>参考答案：</p>
<p>客户端将文件的二进制内容进行分片，每片数据按顺序进行序号标识，上传每片数据时同时附带其序号。服务器接收到每片数据时，将其保存成一个临时文件，并记录每个文件的 hash 和序号。</p>
<p>若上传中止，将来再次上传时，可以向服务器索要已上传的分片序号，客户端仅需上传剩余分片即可。</p>
<p>当全部分片上传完成后，服务器按照分片的顺序组装成完整的文件，并删除分片文件。</p>
</blockquote>
</li>
<li><p>介绍 SSL 和 TLS（寺库）</p>
<blockquote>
<p>参考答案：</p>
<p>它们都是用于保证传输安全的协议，介于传输层和应用层之间，TLS 是 SSL 的升级版。</p>
<p>它们的基本流程一致：</p>
<ol>
<li>客户端向服务器端索要公钥，并使用数字证书验证公钥。</li>
<li>客户端使用公钥加密会话密钥，服务端用私钥解密会话密钥，于是得到一个双方都认可的会话密钥</li>
<li>传输的数据使用会话密钥加密，然后再传输，接收消息方使用会话密钥解密得到原始数据</li>
</ol>
</blockquote>
</li>
<li><p>说说网络的五层模型（寺库）</p>
<blockquote>
<p>参考答案：</p>
<p>从上到下分别为：应用层、传输层、网络层、数据链路层、物理层。在发送消息时，消息从上到下进行打包，每一层会在上一层基础上加包，而接受消息时，从下到上进行解包，最终得到原始信息。</p>
<p>其中：</p>
<p>应用层主要面向互联网中的应用场景，比如网页、邮件、文件中心等等，它的代表协议有 http、smtp、pop3、ftp、DNS 等等</p>
<p>传输层主要面向传输过程，比如 TCP 协议是为了保证可靠的传输，而 UDP 协议则是一种无连接的广播，它们提供了不同的传输方式</p>
<p>网络层主要解决如何定位目标的问题，比如 IP、ICMP、ARP 等等</p>
<p>数据链路层的作用是将数据可靠的传输到目标，比如常见的以太网协议、P2P 协议</p>
<p>物理层是要规范网络两端使用的物理设备，比如蓝牙、wifi、光纤、网线接头等等</p>
</blockquote>
</li>
<li><p>GET 和 POST 的区别（流利说）</p>
<blockquote>
<p>参考答案：</p>
<p>从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。</p>
<p>之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。</p>
<p>受浏览器的影响，在实际开发中，GET 和 POST 有以下区别：</p>
<ol>
<li>浏览器在发送 GET 请求时，不会附带请求体</li>
<li>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</li>
<li>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</li>
<li>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</li>
<li>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</li>
<li>GET 请求的地址可以被保存为浏览器书签，POST 不可以</li>
</ol>
</blockquote>
</li>
<li><p>http 劫持是什么？</p>
<blockquote>
<p>参考答案：</p>
<p>是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息。</p>
</blockquote>
</li>
<li><p>HTTP 劫持、DNS 劫持与 XSS</p>
<blockquote>
<p>参考答案：</p>
<p>http 劫持是指攻击者在客户端和服务器之间同时建立了连接通道，通过某种方式，让客户端请求发送到自己的服务器，然后自己就拥有了控制响应内容的能力，从而给客户端展示错误的信息，比如在页面中加入一些广告内容。</p>
<p>DNS 劫持是指攻击者劫持了 DNS 服务器，获得了修改 DNS 解析记录的权限，从而导致客户端请求的域名被解析到了错误的 IP 地址，攻击者通过这种方式窃取用户资料或破坏原有正常服务。</p>
<p>XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。</p>
<p>要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。</p>
</blockquote>
</li>
<li><p>介绍 xss csrf 攻击</p>
<blockquote>
<p>参考答案：</p>
<p>XSS：</p>
<p>XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。</p>
<p>要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。</p>
<p>CSRF：</p>
<p>CSRF 是跨站请求伪造，是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法</p>
<p>它首先引导用户访问一个危险网站，当用户访问网站后，网站会发送请求到被攻击的站点，这次请求会携带用户的cookie发送，因此就利用了用户的身份信息完成攻击</p>
<p>防御 CSRF 攻击有多种手段：</p>
<ol>
<li>不使用cookie</li>
<li>为表单添加校验的 token 校验</li>
<li>cookie中使用sameSite字段</li>
<li>服务器检查 referer 字段</li>
</ol>
</blockquote>
</li>
<li><p>https 验证身份也就是 TSL&#x2F;SSL 身份验证的过程</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li>
<li>服务器响应公钥和服务器证书</li>
<li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li>
<li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li>
<li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li>
<li>后续客户端和服务器使用会话密钥加密信息传递消息</li>
</ol>
</blockquote>
</li>
<li><p>为什么需要 CA 机构对证书签名</p>
<blockquote>
<p>参考答案：</p>
<p>主要是为了解决证书的可信问题。如果没有权威机构对证书进行签名，客户端就无法知晓证书是否是伪造的，从而增加了中间人攻击的风险，https 就变得毫无意义。</p>
</blockquote>
</li>
<li><p>身份验证过程中会涉及到密钥，对称加密，非对称加密，摘要的概念，请解释一下</p>
<blockquote>
<p>参考答案：</p>
<p>密钥</p>
<p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p>
<p>对称加密</p>
<p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有 DES、3DES、TDEA、Blowfish、RC5 和 IDEA。</p>
<p>非对称加密</p>
<p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p>
<p>摘要</p>
<p>摘要算法又称哈希&#x2F;散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用 16 进制的字符串表示）。算法不可逆。</p>
</blockquote>
</li>
<li><p>webSocket 协议是什么，能简述一下吗？</p>
<blockquote>
<p>参考答案：</p>
<p>websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。</p>
<p>首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，请求行中的 path 需要使用<code>ws:</code>开头的地址，请求头中要分别加入<code>upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version</code>标记</p>
<p>然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含<code>Switching Protocols</code>，同时响应头中包含<code>upgrade、connection、Sec-WebSocket-Accept</code>标记</p>
<p>当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。</p>
</blockquote>
</li>
<li><p>webSocket 与传统的 http 有什么优势</p>
<blockquote>
<p>参考答案：</p>
<p>当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成</p>
<p>第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</p>
<p>第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</p>
<p>无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。</p>
<p>websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。</p>
</blockquote>
</li>
<li><p>如何劫持 https 的请求，提供思路</p>
<blockquote>
<p>参考答案：</p>
<p>https 有防篡改的特点，只要浏览器证书验证过程是正确的，很难在用户不察觉的情况下进行攻击。但若能够更改浏览器的证书验证过程，便有机会实现 https 中间人攻击。</p>
<p>所以，要劫持 https，首先要伪造一个证书，并且要想办法让用户信任这个证书，可以有多种方式，比如病毒、恶意软件、诱导等。一旦证书被信任后，就可以利用普通中间人攻击的方式，使用伪造的证书进行攻击。</p>
</blockquote>
</li>
<li><p>怎样解决跨域问题？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>使用 JSONP</p>
<p>这是一种古老的解决跨域问题的思路。</p>
<p>在需要跨域请求时，事先准备好一个处理服务器数据的函数，然后生成一个<code>&lt;script&gt;</code>元素，<code>src</code>指向跨域站点，同时把准备好的函数名通过地址参数传递到服务器。</p>
<p>跨域站点返回一段调用该函数的脚本，当客户端接收到脚本后就会运行事先准备的函数，从而实现跨域获取数据。</p>
<p>JSONP 实现简单、兼容性好，但缺点也很明显，它只支持 get 请求，同时也有安全性问题，并且对服务器端代码侵入性比较强。</p>
</li>
<li><p>使用 cors</p>
<p>在请求时，客户端使用一些特殊的请求头向服务器申请跨域访问，并通过这些请求头告诉服务器自己的行为。服务器根据自身的规则决定是否允许跨域，如果允许，则通过响应头告诉客户端可以发送跨域请求。</p>
<p>cors 协议已被各种主流浏览器支持，它安全性高，同时也不会侵入服务器代码，是目前最主流的跨域方式</p>
</li>
</ol>
<p>除此之外，远古时期的跨域处理还包括 iframe、form 等，由于它们缺陷非常明显，故很少使用了。</p>
</blockquote>
</li>
<li><p>前端如何实现即时通讯？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>短轮询。即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</li>
<li>长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</li>
<li>websocket，握手完毕后会建立持久性的连接通道，随后服务器可以在任何时候推送新消息给客户端</li>
</ol>
</blockquote>
</li>
<li><p>HTTP 常用状态码 301 302 304 403</p>
<blockquote>
<p>参考答案：</p>
<p>301 永久重定向，浏览器会把重定向后的地址缓存起来，将来用户再次访问原始地址时，直接引导用户访问新地址</p>
<p>302 临时重定向，浏览器会引导用户进入新地址，但不会缓存原始地址，下一次用户访问源地址时，浏览器仍然要请求原地址的服务器</p>
<p>304 资源未修改，服务器通过该状态码告诉客户端，请求的资源和过去一样，并没有任何变化，建议自行使用过去的缓存。通常，304 状态码的响应中，服务器不会附带任何的响应体。</p>
<p>403 不允许访问。服务器通过该状态码告诉客户端，这个资源目前不允许访问。这种状态码通常出现在权限不足的情况下。</p>
</blockquote>
</li>
<li><p>在浏览器地址栏输入地址，并按下回车键后，发生了哪些事情？</p>
<blockquote>
<ol>
<li><p>参考答案：</p>
<ol>
<li>浏览器自动补全协议、端口</li>
<li>浏览器自动完成url编码</li>
<li>浏览器根据url地址查找本地缓存，根据缓存规则看是否命中缓存，若命中缓存则直接使用缓存，不再发出请求</li>
<li>通过DNS解析找到服务器的IP地址</li>
<li>浏览器向服务器发出建立TCP连接的申请，完成三次握手后，连接通道建立</li>
<li>若使用了HTTPS协议，则还会进行SSL握手，建立加密信道。使用SSL握手时，会确定是否使用HTTP2</li>
<li>浏览器决定要附带哪些cookie到请求头中</li>
<li>浏览器自动设置好请求头、协议版本、cookie，发出GET请求</li>
<li>服务器处理请求，进入后端处理流程。完成处理后，服务器响应一个HTTP报文给浏览器。</li>
<li>浏览器根据使用的协议版本，以及Connection字段的约定，决定是否要保留TCP连接。</li>
<li>浏览器根据响应状态码决定如何处理这一次响应</li>
<li>浏览器根据响应头中的Content-Type字段识别响应类型，如果是text&#x2F;html，则对响应体的内容进行HTML解析，否则做其他处理</li>
<li>浏览器根据响应头的其他内容完成缓存、cookie的设置</li>
<li>浏览器开始从上到下解析HTML，若遇到外部资源链接，则进一步请求资源</li>
<li>解析过程中生成DOM树、CSSOM树，然后一边生成，一边把二者合并为渲染树（rendering tree），随后对渲染树中的每个节点计算位置和大小（reflow），最后把每个节点利用GPU绘制到屏幕（repaint）</li>
<li>在解析过程中还会触发一系列的事件，当DOM树完成后会触发DOMContentLoaded事件，当所有资源加载完毕后会触发load事件</li>
</ol>
</li>
</ol>
</blockquote>
</li>
<li><p>HTTPS 握手</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息</li>
<li>服务器响应公钥和服务器证书</li>
<li>客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器</li>
<li>服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪</li>
<li>客户端使用会话密钥解密消息，知道了服务器已经准备就绪。</li>
<li>后续客户端和服务器使用会话密钥加密信息传递消息</li>
</ol>
</blockquote>
</li>
<li><p>网页验证码是干嘛的，是为了解决什么安全问题？</p>
<blockquote>
<p>参考答案：</p>
<p>验证码主要用于让服务器区分请求是人还是机器发送的。这样做是为了避免某些程序恶意的提交大量信息到服务器，进而导致服务器产生大量的垃圾数据。有时，验证码也可以防止机器暴力破解用户密码，它通过在短时间内不断提交登录信息，尝试各种密码组合来达到破解的目的。</p>
</blockquote>
</li>
<li><p>http1.0、http2.0、http3.0 之间的区别</p>
<blockquote>
<p>参考答案：</p>
<p>http1.0</p>
<p>每次请求和响应完毕后都会销毁 TCP 连接，同时规定前一个响应完成后才能发送下一个请求。这样做有两个问题：</p>
<ol>
<li><p>无法复用连接</p>
<p>每次请求都要创建新的 TCP 连接，完成三次握手和四次挥手，网络利用率低</p>
</li>
<li><p>队头阻塞</p>
<p>如果前一个请求被某种原因阻塞了，会导致后续请求无法发送。</p>
</li>
</ol>
<p>http2.0</p>
<p>http2.0 优化了传输效率，它主要有以下改进：</p>
<ol>
<li><p>二进制分帧</p>
<p>将传输的消息分为更小的二进制帧，每帧有自己的标识序号，即便被随意打乱也能在另一端正确组装</p>
</li>
<li><p>多路复用</p>
<p>基于二进制分帧，在同一域名下所有访问都是从同一个 tcp 连接中走，并且不再有队头阻塞问题，也无须遵守响应顺序</p>
</li>
<li><p>头部压缩</p>
<p>http2.0 通过字典的形式，将头部中的常见信息替换为更少的字符，极大的减少了头部的数据量，从而实现更小的传输量</p>
</li>
<li><p>服务器推</p>
<p>http2.0 允许服务器直接推送消息给客户端，无须客户端明确的请求</p>
</li>
</ol>
<p>http3.0</p>
<p>http3.0 目前还在草案阶段，它完全抛弃了 TCP 协议，转而使用 UDP 协议，是为了进一步提升性能。</p>
<p>虽然 http2.0 进行了大量的优化，但它无法摆脱 TCP 协议本身的问题，比如建立连接时间长、对头阻塞问题等等。</p>
<p>为了保证传输的可靠性，http3.0 使用了 QUIC 协议。</p>
</blockquote>
</li>
<li><p>cookie&#x2F;sessionStorage&#x2F;localStorage 的区别</p>
<blockquote>
<p>参考答案：</p>
<p>cookie、sessionStorage、localStorage 都是保存本地数据的方式</p>
<p>其中，cookie 兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现<code>set-cookie</code>字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任。与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，CSRF 攻击就是一个典型的利用 cookie 的攻击方式。虽然 cookie 不断的改进，但前端仍然需要另一种更加安全的保存数据的方式</p>
<p>HTML5 新增了 sessionStorage 和 localStorage，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击。<br>cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M，而 sessionStorage 和 localStorage 则没有限制<br>cookie 会与 domain、path 关联，而 sessionStorage 和 localStorage 只与 domain 关联</p>
</blockquote>
</li>
<li><p>post 请求什么时候用 form data 什么时候用 request payload</p>
<blockquote>
<p>参考答案：</p>
<p>form data 适合传递简单的键值对信息，由于传递的信息比较扁平，难以传递深层次嵌套的数据</p>
<p>request payload 适合传递任意格式的数据，包括单个数字、布尔、深层次嵌套的对象、数组等，但 request payload 不适合传递文件数据</p>
<p>在前后端分离的项目中，对于非文件数据的传递，都推荐使用 request payload 的形式，以传递最明确的数据类型和数据结构，而对于文件上传，则推荐使用传统的 form data</p>
</blockquote>
</li>
<li><p>http 常见请求方法有哪些？</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li>GET，表示向服务器获取资源</li>
<li>POST，表示向服务器提交信息，通常用于产生新的数据，比如注册</li>
<li>PUT，表示希望修改服务器的数据，通常用于修改</li>
<li>DELETE，表示希望删除服务器的数据</li>
<li>OPTIONS，发生在跨域的预检请求中，表示客户端向服务器申请跨域提交</li>
<li>TRACE，回显服务器收到的请求，主要用于测试和诊断</li>
<li>CONNECT，用于建立连接管道，通常在代理场景中使用，网页中很少用到</li>
</ul>
</blockquote>
</li>
<li><p>列举优化网络性能方法</p>
<blockquote>
<p>参考答案：</p>
<ul>
<li><p>优化打包体积</p>
<p>利用一些工具压缩、混淆最终打包代码，减少包体积</p>
</li>
<li><p>多目标打包</p>
<p>利用一些打包插件，针对不同的浏览器打包出不同的兼容性版本，这样一来，每个版本中的兼容性代码就会大大减少，从而减少包体积</p>
</li>
<li><p>压缩</p>
<p>现代浏览器普遍支持压缩格式，因此服务端的各种文件可以压缩后再响应给客户端，只要解压时间小于优化的传输时间，压缩就是可行的</p>
</li>
<li><p>CDN</p>
<p>利用 CDN 可以大幅缩减静态资源的访问时间，特别是对于公共库的访问，可以使用知名的 CDN 资源，这样可以实现跨越站点的缓存</p>
</li>
<li><p>缓存</p>
<p>对于除 HTML 外的所有静态资源均可以开启协商缓存，利用构建工具打包产生的文件 hash 值来置换缓存</p>
</li>
<li><p>http2</p>
<p>开启 http2 后，利用其多路复用、头部压缩等特点，充分利用带宽传递大量的文件数据</p>
</li>
<li><p>雪碧图</p>
<p>对于不使用 HTTP2 的场景，可以将多个图片合并为雪碧图，以达到减少文件的目的</p>
</li>
<li><p>defer、async</p>
<p>通过 defer 和 async 属性，可以让页面尽早加载 js 文件</p>
</li>
<li><p>prefetch、preload</p>
<p>通过 prefetch 属性，可以让页面在空闲时预先下载其他页面可能要用到的资源</p>
<p>通过 preload 属性，可以让页面预先下载本页面可能要用到的资源</p>
</li>
<li><p>多个静态资源域</p>
<p>对于不使用 HTTP2 的场景，将相对独立的静态资源分到多个域中保存，可以让浏览器同时开启多个 TCP 连接，并行下载</p>
</li>
</ul>
</blockquote>
</li>
<li><p>session 怎么消除</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>过期时间</p>
<p>当客户端长时间没有传递 sessionid 过来时，服务器可以在过期时间之后自动清除 session</p>
</li>
<li><p>客户端主动通知</p>
<p>可以使用 JS 监听客户端页面关闭或其他退出操作，然后通知服务器清除 session</p>
</li>
</ol>
</blockquote>
</li>
<li><p>什么是 DNS 域名解析？</p>
<blockquote>
<p>参考答案：</p>
<p>DNS 域名解析是指把域名解析成 IP 地址的过程。</p>
<p>在具体的实现上，域名解析是由多个层级的服务器共同完成的。在查询域名时，客户端会先检查自身的 DNS 映射表，若找不到解析记录，则使用用户配置的 DNS 服务器，若目标 DNS 服务器中找不到记录，则继续往上一个层级寻找，直到到达根域名服务器，根域名服务器会根据域名的类型，将解析任务分发到对应的子域名服务器依次查找，直到找到解析记录为止。</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/browser%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/browser%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">browser问题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-19 09:43:46" itemprop="dateCreated datePublished" datetime="2024-12-19T09:43:46+08:00">2024-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>介绍下重绘和重排（repaint &amp; reflow），以及如何进行优化</p>
<blockquote>
<p>参考答案：</p>
<p>整个页面可以看做是一幅画，这幅画是由浏览器绘制出来的，浏览器绘制这幅画的过程称之为渲染。</p>
<p>渲染是一件复杂的工作，它大致分为以下几个过程：</p>
<ol>
<li>解析 HTML，生成 DOM 树，解析 CSS，生成样式规则树</li>
<li>将 DOM 树和样式规则树结合，生成渲染树(Render Tree)</li>
<li>根据生成的渲染树，确定元素的布局信息（元素的尺寸、位置），<strong>这一步称之为 reflow，译作重排或回流</strong></li>
<li>根据渲染树和布局信息，生成元素的像素信息（元素横纵的像素点，左上角的偏移量、每个像素的颜色等）。<strong>这一步称之为 repaint，译作重绘</strong></li>
<li>将像素信息提交到 GPU 完成屏幕绘制</li>
</ol>
<p>当元素的布局信息发生变化时，会导致重排。</p>
<p>当元素的像素信息发生变化时，会导致重绘。</p>
<p>重排一定会导致重绘，因此布局信息的变化一定会导致像素信息的变化。</p>
<p>在实际开发中，获取和设置元素尺寸、位置均会导致重排和重绘，而仅设置元素的外观（比如背景颜色）则只会导致重绘，不会导致重排。</p>
<p>重排是一项繁琐的工作，会降低效率，因此在开发中，应该尽量避免直接获取和设置元素的尺寸、位置，尽量使用变量来保存元素的布局信息。</p>
</blockquote>
</li>
<li><p>说说浏览器和 Node 事件循环的区别</p>
<blockquote>
<p>参考答案：</p>
<p>浏览器的事件循环比较简单，它把任务分为宏任务和微任务，当执行栈清空后，会优先调取微任务运行，当微任务队列清空后，才会调取宏任务运行。</p>
<p>而 node 的事件循环机制比较复杂，它将整个任务调度分为 6 个阶段，当执行栈清空后，将依次循环 6 个阶段：</p>
<ol>
<li>timers</li>
<li>pending callbacks</li>
<li>idle, prepare</li>
<li>poll</li>
<li>check</li>
<li>close callback</li>
</ol>
<p>在进入任何一个阶段时，都将检查微队列中是否有任务需要执行，只有微队列清空后才能顺利进入下一个阶段。</p>
</blockquote>
</li>
<li><p>浏览器缓存读取规则</p>
<blockquote>
<p>参考答案：</p>
<p>当需要获取一个资源时，浏览器会先检查缓存中是否存在，若命中缓存，则不会发送请求。浏览器按照一定的顺序检查缓存，具体顺序是：</p>
<ol>
<li><p>service worker</p>
<p>在 service worker 中，开发者可以根据需要将远程获取的资源缓存到 cache storage 中，之后对该资源的请求会直接从缓存中获取。</p>
<p>这部分缓存需要前端开发者手动完成的</p>
</li>
<li><p>memory cache</p>
<p>浏览器会自动将请求过的资源自动加入到 memory cache，这主要是为了解决一个页面中有多次相同的请求，比如页面中链接了多张相同的图片。</p>
<p>memory cache 是浏览器自动完成的，它保存在内存中。</p>
</li>
<li><p>disk cache</p>
<p>当浏览器得到的响应头中包含<code>cache-control</code>等缓存指令时，会按照指令的要求设置 disk cache。请求的资源会被保存在磁盘中，在指定的期限内有效。</p>
<p>disk cache 是长期的，即使关闭浏览器也不会消失。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</p>
<blockquote>
<p>参考答案：</p>
<p>首先，在很多场景中，处理埋点的服务器很有可能是第三方服务器，比如百度的站点统计埋点，百度就是一个第三方服务器，这就不可避免的带来跨域问题。</p>
<p>其次，埋点服务方需要提供一种特别利于安装的埋点置入代码，使用传统的 ajax 会使代码变得臃肿。</p>
<p>同时，埋点请求绝大部分都是 get 请求，又无须得到服务器的响应结果。</p>
<p>基于以上的特点，使用 img 元素请求服务器就变得理所当然了，img 元素发出的请求天生支持跨域，书写的代码简单，只需要创建一个 img 元素，然后设置 src 为埋点请求地址即可。</p>
<p>其实请求一旦发出，埋点就成功了，无须得到服务器的响应结果。但如果服务器不给予任何响应的话，可能会导致浏览器端控制台报错，尽管这个报错并不影响实质的功能。为了避免这种情况，服务器于是响应一个最小体积的图片即可，而 1x1 像素的透明 gif 图片是体积最小的图片，自然就选用了它作为响应结果。</p>
</blockquote>
</li>
<li><p>请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</p>
<blockquote>
<p>参考答案：</p>
<p>memory cache 是浏览器自动完成的，它不关心 http 语义，但会遵守<code>cache-control: no-store</code>指令。浏览器在请求资源后，会自动将资源加入 memory cache，在后续的请求中，若请求的 url 地址和之前缓存的对应地址相同，则直接使用 memory cache。memory cache 只缓存 get 请求，并且缓存的内容在内存中，因此会很快的清理。</p>
<p>disk cache 遵守 http 缓存语义，它会按照服务器响应头中指定的缓存要求进行缓存，由于它存在于磁盘中，因此，即便浏览器关闭后缓存内容也不会消失。它的保存时间由服务器的<code>cache-control</code>字段指定，当缓存失效后，会重新发送请求到服务器，进入协商缓存的流程。</p>
</blockquote>
</li>
<li><p>什么是浏览器同源策略？</p>
<blockquote>
<p>参考答案：</p>
<p>所谓同源，是指协议、主机、端口均相同的地址。</p>
<p>同源策略是指，当前页面和页面运行过程中发出的请求必须是同源的，即必须协议、主机、端口均相同，否则即被视为跨域请求。</p>
<p>浏览器中的大部分内容都是受同源策略限制的，但是以下三个标签可以不受限制：</p>
<ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</blockquote>
</li>
<li><p>DOM Tree 是如何构建的？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>转码: 浏览器将接收到的二进制数据按照指定编码格式转化为 HTML 字符串</li>
<li>生成 Tokens: 之后开始 parser，浏览器会将 HTML 字符串解析成 Tokens</li>
<li>构建 Nodes: 对 Node 添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope</li>
<li>生成 DOM Tree: 通过 node 包含的指针确定的关系构建出 DOM Tree</li>
</ol>
</blockquote>
</li>
<li><p>浏览器如何解析 css 选择器？</p>
<blockquote>
<p>参考答案：</p>
<p>浏览器读取到选择器时，会从 DOM 树中找到匹配的对应节点，然后将样式附着到对应的 DOM 元素上。当选择器出现多个层级时，浏览器会使用「从右到左」的顺序进行匹配，对应到 DOM 树的遍历上，是从叶子到根的方向进行筛选，这样可以提升匹配效率。</p>
</blockquote>
</li>
<li><p>浏览器是如何渲染 UI 的？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li>浏览器解析 HTML，形成 DOM Tree</li>
<li>解析 HTML 过程中遇到 CSS，则进行 CSS 解析，生成 Style Rules</li>
<li>将 DOM Tree 与 Style Rules 合成为 Render Tree</li>
<li>进入布局（Layout）阶段，为每个节点分配一个应出现在屏幕上的确切坐标</li>
<li>随后调用 GPU 进行绘制（Paint），遍历 Render Tree 的节点，并将元素呈现出来</li>
</ol>
</blockquote>
</li>
<li><p>浏览器的主要组成部分是什么？</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>用户界面（user interface）</p>
<p>用于呈现浏览器窗口部件，比如地址栏、前进后退按钮、书签、顶部菜单等</p>
</li>
<li><p>浏览器引擎（browser engine）</p>
<p>用户在用户界面和渲染引擎中传递指令</p>
</li>
<li><p>渲染引擎（rendering engine）</p>
<p>负责解析 HTML、CSS，并将解析的内容显示到屏幕上。我们平时说的浏览器内核就是指这部分。</p>
</li>
<li><p>网络（networking）</p>
<p>用户网络调用，比如发送 http 请求</p>
</li>
<li><p>用户界面后端（UI backend）</p>
<p>用于绘制基本的窗口小部件，比如下拉列表、文本框、按钮等，向上提供公开的接口，向下调用操作系统的用户界面。</p>
</li>
<li><p>JS 解释器（JavaScript interpreter）</p>
<p>解释执行 JS 代码。我们平时说的 JS 引擎就是指这部分。</p>
</li>
<li><p>数据存储（data storage）</p>
<p>用户保存数据到磁盘中。比如 cookie、localstorage 等都是使用的这部分功能。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>常见的浏览器内核有哪些?</p>
<blockquote>
<p>参考答案：</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>内核（渲染引擎）</th>
<th>JavaScript 引擎</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>Blink（新） Webkit（旧）</td>
<td>V8</td>
</tr>
<tr>
<td>FireFox</td>
<td>Gecko</td>
<td>SpiderMonkey</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Edge</td>
<td>EdgeHTML</td>
<td>Chakra</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
<td>Chakra</td>
</tr>
<tr>
<td>PhantomJS</td>
<td>Webkit</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Node.js</td>
<td>无</td>
<td>V8</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>怎样选择合适的缓存策略</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>对于一次性的资源，比如验证码图片，不进行缓存。</p>
<p>设置响应头<code>cache-control: no-store</code></p>
</li>
<li><p>对于频繁变动的资源，比如某些数据接口，使用协商缓存。</p>
<p>设置响应头<code>cache-control: no-cache</code>，同时配合<code>ETag</code>标记，让浏览器缓存资源，但每次都会发送请求询问资源是否更新。</p>
</li>
<li><p>对于静态资源，比如 JS、CSS、图片等文件，使用强制缓存。</p>
<p>设置响应头<code>cache-control: max-age=有效时长</code>，设置一个很长的过期时间，比如十年，然后通过文件 hash 的处理更新</p>
</li>
</ol>
</blockquote>
</li>
<li><p>为什么用多个域名存储网站资源更有效？</p>
<blockquote>
<p>参考答案：</p>
<p>主要原因是浏览器对同一个域下的 TCP 连接数是有限制的，这样就导致某个网页如果外部资源多了，比如图片很多的网页，在解析页面时，由于 TCP 连接数受限，就无法同时发起多个下载连接，无法充分利用带宽资源。因此，可以把静态资源放到多个域名下，这样就绕开了连接数的限制，做到了并发下载。</p>
</blockquote>
</li>
<li><p>前端需要注意哪些 SEO</p>
<blockquote>
<p>参考答案：</p>
<ol>
<li><p>语义化</p>
<p>多使用语义化标签，让正确的标签对应正确的内容。</p>
</li>
<li><p>重要内容前置</p>
<p>可以利用弹性盒布局中的 order 属性，将核心、重要的内容尽量放到文档的前面。</p>
</li>
<li><p>服务端渲染</p>
<p>由于目前的搜索引擎对客户端渲染并不友好，因此使用服务端渲染仍然是 SEO 的重要手段。</p>
</li>
<li><p>TDK</p>
<p>利用 title、meta 元素，设置网页的标题、描述、关键字</p>
</li>
</ol>
</blockquote>
</li>
<li><p>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢</p>
<blockquote>
<p>参考答案：</p>
<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>离线的情况下，浏览器就直接使用离线存储的资源。</p>
</blockquote>
</li>
<li><p>如何兼容低版本浏览器</p>
</li>
</ol>
<blockquote>
<p>参考答案：</p>
<p>分为三个部分来说</p>
<p>HTML</p>
<p>低版本浏览器无法识别新增的HTML5元素，如果要兼容这部分浏览器，需要做以下处理：</p>
<ol>
<li>对于非可替换元素，比如article、section、header、footer等，这种元素虽然低版本浏览器不识别，但它仍然会把它们渲染出来，只是没有浏览器的默认样式。因此，我们只需要在css中稍作处理即可，比如给它们都加上<code>display:block</code>。</li>
<li>对于可替换元素，比如video、audio等，这种元素会涉及低版本浏览器没有功能，因此需要使用条件注释，在低版本浏览器中使用兼容的做法</li>
</ol>
<p>CSS</p>
<p>对于CSS代码，低版本浏览器可能无法识别某些CSS属性，比如圆角边框、背景渐变、过渡动画等。但由于浏览器对于不能识别样式的处理方式是「直接丢弃、不影响后续渲染」，所以，我们可以保持这样的原则：尽量让其兼容，实在不行，至少不影响浏览。按照这样的原则，我们可以对CSS进行以下处理：</p>
<ol>
<li>使用厂商前缀，尽量让其兼容。</li>
<li>对于某些样式使用JS替代，比如渐变、动画等</li>
</ol>
<p>JavaScript</p>
<p>对于JS代码，低版本浏览器无法识别H5的API，因此缺少了一些新功能，比如localstorage、web worker等。不仅如此，低版本浏览器还无法识别ES6的新语法，比如let、const、async、await等。因此，要处理JS的兼容性问题，只能具体情况具体分析，通常，我们会使用下面两种手段来完成兼容：</p>
<ol>
<li>模拟API。就是自己写一个功能完全和官方相同的API，来弥补低版本浏览器API没有的情况。比较典型的就是ES5中有大量的数组API，这些API都是可以轻松模拟的。</li>
<li>编译。某些新语法是无法模拟的，只能通过制作工具对源代码进行编译，将其新语法全部去掉，如果新语法涉及特殊功能，则转换为使用API完成，比较典型的例子就是async和await会被转换为generator的函数调用。</li>
</ol>
<p>在前端工程化的今天，上面的几乎所有兼容性问题都可以依靠工程化完成，比如，css可以依托postcss平台完成兼容性处理，JS可以依托babel平台完成兼容性处理。</p>
</blockquote>
<ol start="17">
<li>浏览器怪异模式和普通模式的区别</li>
</ol>
<blockquote>
<p>参考答案：</p>
<p>标准模式：浏览器按W3C标准解析执行代码</p>
<p>怪异模式：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以称之为怪异模式。比如IE中盒模型的宽高使用的是边框盒。</p>
</blockquote>
<ol start="18">
<li>各个浏览器兼容前缀？</li>
</ol>
<blockquote>
<p>参考答案：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>浏览器</th>
</tr>
</thead>
<tbody><tr>
<td>-moz-</td>
<td>firefox</td>
</tr>
<tr>
<td>-webkit-</td>
<td>chrome、safari</td>
</tr>
<tr>
<td>-o-</td>
<td>opera</td>
</tr>
<tr>
<td>-ms-</td>
<td>IE</td>
</tr>
</tbody></table>
</blockquote>
<ol start="19">
<li>跨标签页的通讯方式有哪些（哔哩哔哩）</li>
</ol>
<blockquote>
<p>参考答案：</p>
<ul>
<li>BroadCast Channel</li>
<li>Service Worker</li>
<li>LocalStorage window.onstorage 监听</li>
<li>Shared Worker 定时器轮询(setInterval)</li>
<li>IndexedDB 定时器轮询(setInterval)</li>
<li>cookie 定时器轮询(setInterval)</li>
<li>window.open window.postMessage</li>
<li>Websocket</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/vue%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/vue%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">vue问题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-19 09:20:46" itemprop="dateCreated datePublished" datetime="2024-12-19T09:20:46+08:00">2024-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Vue-问题汇总"><a href="#Vue-问题汇总" class="headerlink" title="Vue 问题汇总"></a><em>Vue</em> 问题汇总</h2><h3 id="1-谈一谈对-MVVM-的理解？"><a href="#1-谈一谈对-MVVM-的理解？" class="headerlink" title="1. 谈一谈对 MVVM 的理解？"></a>1. <strong>谈一谈对 <em>MVVM</em> 的理解？</strong></h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>MVVM</em> 是 <em>Model-View-ViewModel</em> 的缩写。<em>MVVM</em> 是一种设计思想。</li>
<li><em>Model</em> 层代表数据模型，也可以在 <em>Model</em> 中定义数据修改和操作的业务逻辑; </li>
<li><em>View</em> 代表 <em>UI</em> 组件，它负责将数据模型转化成 <em>UI</em> 展现出来，<em>View</em> 是一个同步 <em>View</em> 和 <em>Model</em> 的对象</li>
<li>在 <em>MVVM</em> 架构下，<em>View</em> 和 <em>Model</em> 之间并没有直接的联系，而是通过 <em>ViewModel</em> 进行交互， <em>Model</em> 和 <em>ViewModel</em> 之间的交互是双向的， 因此 <em>View</em> 数据的变化会同步到 <em>Model</em> 中，而 <em>Model</em> 数据的变化也会立即反应到 <em>View</em> 上。</li>
<li>对 <em>ViewModel</em> 通过双向数据绑定把 <em>View</em> 层和 <em>Model</em> 层连接了起来，而 <em>View</em> 和 <em>Model</em> 之间的 同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 <em>DOM</em>，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 <em>MVVM</em> 来统一管理。</li>
</ul>
</blockquote>
<h3 id="2-说一下-Vue-的优点"><a href="#2-说一下-Vue-的优点" class="headerlink" title="2. 说一下 Vue 的优点"></a>2. <strong>说一下 <em>Vue</em> 的优点</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Vue</em> 是一个构建数据驱动的 <em>Web</em> 界面的渐进式框架。</p>
<p><em>Vue</em> 的目标是通过尽可能简单的 <em>API</em> 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。</p>
<p>关于 <em>Vue</em> 的优点，主要有<strong>响应式编程、组件化开发、虚拟 <em>DOM</em></strong></p>
<p><strong>响应式编程</strong></p>
<p>这里的响应式不是 <em>@media</em> 媒体查询中的响应式布局，而是指 <em>Vue</em> 会自动对页面中某些数据的变化做出响应。这也就是 <em>Vue</em> 最大的优点，通过 <em>MVVM</em> 思想实现数据的双向绑定，让开发者不用再操作 <em>DOM</em> 对象，有更多的时间去思考业务逻辑。</p>
<p><strong>组件化开发</strong></p>
<p><em>Vue</em> 通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（<em>component</em>）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p>
<p>组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。</p>
<p><strong>虚拟 <em>DOM</em></strong></p>
<p>在传统开发中，用 <em>JQuery</em> 或者原生的 <em>JavaScript DOM</em> 操作函数对 <em>DOM</em> 进行频繁操作的时候，浏览器要不停的渲染新的 <em>DOM</em> 树，导致在性能上面的开销特别的高。</p>
<p>而 <em>Virtual DOM</em> 则是虚拟 <em>DOM</em> 的英文，简单来说，他就是一种可以预先通过 <em>JavaScript</em> 进行各种计算，把最终的 <em>DOM</em> 操作计算出来并优化，由于这个 <em>DOM</em> 操作属于预处理操作，并没有真实的操作 <em>DOM</em>，所以叫做虚拟 <em>DOM</em>。最后在计算完毕才真正将 <em>DOM</em> 操作提交，将 <em>DOM</em> 操作变化反映到 <em>DOM</em> 树上。</p>
</blockquote>
<h3 id="3-解释一下对-Vue-生命周期的理解"><a href="#3-解释一下对-Vue-生命周期的理解" class="headerlink" title="3. 解释一下对 Vue 生命周期的理解"></a>3. <strong>解释一下对 <em>Vue</em> 生命周期的理解</strong></h3><ul>
<li>什么是 <em>vue</em> 生命周期</li>
<li><em>vue</em> 生命周期的作用是什么</li>
<li><em>vue</em> 生命周期有几个阶段</li>
<li>第一次页面加载会触发哪几个钩子</li>
<li><em>DOM</em> 渲染在哪个周期就已经完成</li>
<li>多组件（父子组件）中生命周期的调用顺序说一下</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>什么是 <em>vue</em> 生命周期</strong></p>
<p>对于 <em>vue</em> 来讲，生命周期就是一个 <em>vue</em> 实例从创建到销毁的过程。</p>
<p><strong><em>vue</em> 生命周期的作用是什么</strong></p>
<p>在生命周期的过程中会运行着一些叫做生命周期的函数，给予了开发者在不同的生命周期阶段添加业务代码的能力。</p>
<p>其实和回调是一个概念，当系统执行到某处时，检查是否有 <em>hook</em>(钩子)，有的话就会执行回调。</p>
<p>通俗的说，<em>hook</em> 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写。</p>
<p><strong><em>vue</em> 生命周期有几个阶段</strong></p>
<p>它可以总共分为 <em>8</em> 个阶段：创建前&#x2F;后, 载入前&#x2F;后,更新前&#x2F;后,销毁前&#x2F;销毁后。</p>
<ul>
<li><p><em>beforeCreate</em>：是 <em>new Vue( )</em> 之后触发的第一个钩子，在当前阶段 <em>data、methods、computed</em> 以及 <em>watch</em> 上的数据和方法都不能被访问。</p>
</li>
<li><p><em>created</em>：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 <em>updated</em> 函数。可以做一些初始数据的获取，在当前阶段无法与 <em>DOM</em> 进行交互，如果非要想，可以通过 <em>vm.$nextTick</em> 来访问 <em>DOM</em> 。</p>
</li>
<li><p><em>beforeMount</em>：发生在挂载之前，在这之前 <em>template</em> 模板已导入渲染函数编译。而当前阶段虚拟 <em>DOM</em> 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 <em>updated</em>。</p>
</li>
<li><p><em>mounted</em>：在挂载完成后发生，在当前阶段，真实的 <em>DOM</em> 挂载完毕，数据完成双向绑定，可以访问到 <em>DOM</em> 节点，使用 <em>$refs</em> 属性对 <em>DOM</em> 进行操作。</p>
</li>
<li><p><em>beforeUpdate</em>：发生在更新之前，也就是响应式数据发生更新，虚拟 <em>DOM</em> 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p>
</li>
<li><p><em>updated</em>：发生在更新完成之后，当前阶段组件 <em>DOM</em> 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p>
</li>
<li><p><em>beforeDestroy</em>：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p>
</li>
<li><p><em>destroyed</em>：发生在实例销毁之后，这个时候只剩下了 <em>DOM</em> 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
</li>
</ul>
<p><strong>第一次页面加载会触发哪几个钩子</strong></p>
<p>会触发 <em>4</em> 个钩子，分别是：<em>beforeCreate、created、beforeMount、mounted</em></p>
<p><strong><em>DOM</em> 渲染在哪个周期就已经完成</strong></p>
<p><em>DOM</em> 渲染是在 <em>mounted</em> 阶段完成，此阶段真实的 <em>DOM</em> 挂载完毕，数据完成双向绑定，可以访问到 <em>DOM</em> 节点。</p>
<p><strong>多组件（父子组件）中生命周期的调用顺序说一下</strong></p>
<p>组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p>
<ul>
<li><p>加载渲染过程：父<em>beforeCreate</em>-&gt;父<em>created</em>-&gt;父<em>beforeMount</em>-&gt;子<em>beforeCreate</em>-&gt;子<em>created</em>-&gt;子<em>beforeMount</em>- &gt;子<em>mounted</em>-&gt;父<em>mounted</em></p>
</li>
<li><p>子组件更新过程：父<em>beforeUpdate</em>-&gt;子<em>beforeUpdate</em>-&gt;子<em>updated</em>-&gt;父<em>updated</em></p>
</li>
<li><p>父组件更新过程：父 <em>beforeUpdate</em> -&gt; 父 <em>updated</em></p>
</li>
<li><p>销毁过程：父<em>beforeDestroy</em>-&gt;子<em>beforeDestroy</em>-&gt;子<em>destroyed</em>-&gt;父<em>destroyed</em></p>
</li>
</ul>
</blockquote>
<h3 id="4-Vue-实现双向数据绑定原理是什么？"><a href="#4-Vue-实现双向数据绑定原理是什么？" class="headerlink" title="4. Vue 实现双向数据绑定原理是什么？"></a>4. <strong><em>Vue</em> 实现双向数据绑定原理是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Vue2.x</em> 采用数据劫持结合发布订阅模式（<em>PubSub</em> 模式）的方式，通过 <em>Object.defineProperty</em> 来劫持各个属性的 <em>setter、getter</em>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>当把一个普通 <em>Javascript</em> 对象传给 <em>Vue</em> 实例来作为它的 <em>data</em> 选项时，<em>Vue</em> 将遍历它的属性，用 <em>Object.defineProperty</em> 将它们转为 <em>getter&#x2F;setter</em>。用户看不到 <em>getter&#x2F;setter</em>，但是在内部它们让 <em>Vue</em> 追踪依赖，在属性被访问和修改时通知变化。</p>
<p><em>Vue</em> 的数据双向绑定整合了 <em>Observer</em>，<em>Compile</em> 和 <em>Watcher</em> 三者，通过 <em>Observer</em> 来监听自己的 <em>model</em> 的数据变化，通过 <em>Compile</em> 来解析编译模板指令，最终利用 <em>Watcher</em> 搭起 <em>Observer</em> 和 <em>Compile</em> 之间的通信桥梁，达到数据变化-&gt;视图更新，视图交互变化（例如 input 操作）-&gt;数据 <em>model</em> 变更的双向绑定效果。</p>
<p><em>Vue3.x</em> 放弃了 <em>Object.defineProperty</em> ，使用 <em>ES6</em> 原生的 <em>Proxy</em>，来解决以前使用  <em>Object.defineProperty</em> 所存在的一些问题。</p>
</blockquote>
<h3 id="5-说一下对-Vue2-x-响应式原理的理解"><a href="#5-说一下对-Vue2-x-响应式原理的理解" class="headerlink" title="5. 说一下对 Vue2.x 响应式原理的理解"></a>5. <strong>说一下对 <em>Vue2.x</em> 响应式原理的理解</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Vue</em> 在初始化数据时，会使用 <em>Object.defineProperty</em> 重新定义 <em>data</em> 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 <em>watcher</em>)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p>
<p>（可以参阅前面第 <em>4</em> 题答案）</p>
</blockquote>
<h3 id="6-说一下在-Vue2-x-中如何检测数组的变化？"><a href="#6-说一下在-Vue2-x-中如何检测数组的变化？" class="headerlink" title="6. 说一下在 Vue2.x 中如何检测数组的变化？"></a>6. <strong>说一下在 <em>Vue2.x</em> 中如何检测数组的变化？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Vue2.x</em> 中实现检测数组变化的方法，是<strong>将数组的常用方法进行了重写</strong>。<em>Vue</em> 将 <em>data</em> 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 <em>api</em> 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>
<p>流程:</p>
<ol>
<li>初始化传入 data 数据执行 initData</li>
<li>将数据进行观测 new Observer</li>
<li>将数组原型方法指向重写的原型</li>
<li>深度观察数组中的引用类型</li>
</ol>
<p>有两种情况无法检测到数组的变化。</p>
<ul>
<li>当利用索引直接设置一个数组项时，例如 <em>vm.items[indexOfItem] &#x3D; newValue</em></li>
<li>当修改数组的长度时，例如 <em>vm.items.length &#x3D; newLength</em></li>
</ul>
<p>不过这两种场景都有对应的解决方案。</p>
<p><strong>利用索引设置数组项的替代方案</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用该方法进行更新视图</span></span><br><span class="line"><span class="comment">// vm.$set，Vue.set的一个别名</span></span><br><span class="line">vm.$set(vm.<span class="property">items</span>, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>

<p><strong>修改数组的长度的替代方案</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用该方法进行更新视图</span></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.<span class="property">items</span>.<span class="title function_">splice</span>(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7-Vue3-x-响应式数据"><a href="#7-Vue3-x-响应式数据" class="headerlink" title="7. Vue3.x 响应式数据"></a>7. <strong><em>Vue3.x</em> 响应式数据</strong></h3><ul>
<li><em>Vue3.x</em> 响应式数据原理是什么？</li>
<li><em>Proxy</em> 只会代理对象的第一层，那么 <em>Vue3</em> 又是怎样处理这个问题的呢？</li>
<li>监测数组的时候可能触发多次 <em>get&#x2F;set</em>，那么如何防止触发多次呢？</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong><em>Vue3.x</em> 响应式数据原理是什么？</strong></p>
<p>在 <em>Vue 2</em> 中，响应式原理就是使用的 <em>Object.defineProperty</em> 来实现的。但是在 <em>Vue 3.0</em> 中采用了 <em>Proxy</em>，抛弃了 <em>Object.defineProperty</em> 方法。</p>
<p>究其原因，主要是以下几点：</p>
<ul>
<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li>
<li><em>Object.defineProperty</em> 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<em>Proxy</em> 可以劫持整个对象，并返回一个新的对象。</li>
<li><em>Proxy</em> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
<li><em>Proxy</em> 有多达 <em>13</em> 种拦截方法</li>
<li><em>Proxy</em>作为新标准将受到浏览器厂商重点持续的性能优化</li>
</ul>
<p><strong><em>Proxy</em> 只会代理对象的第一层，那么 <em>Vue3</em> 又是怎样处理这个问题的呢？</strong></p>
<p>判断当前 <em>Reflect.get</em> 的返回值是否为 <em>Object</em>，如果是则再通过 <em>reactive</em> 方法做代理， 这样就实现了深度观测。</p>
<p>*<em>监测数组的时候可能触发多次 <em>get&#x2F;set</em>，那么如何防止触发多次呢？</em>*</p>
<p>我们可以判断 <em>key</em> 是否为当前被代理对象 <em>target</em> 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 <em>trigger</em>。</p>
</blockquote>
<h3 id="8-v-model-双向绑定的原理是什么？"><a href="#8-v-model-双向绑定的原理是什么？" class="headerlink" title="8. v-model 双向绑定的原理是什么？"></a>8. <strong><em>v-model</em> 双向绑定的原理是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>v-model</em> 本质就是 <em>:value + input</em> 方法的语法糖。可以通过 <em>model</em> 属性的 <em>prop</em> 和 <em>event</em> 属性来进行自定义。原生的 <em>v-model</em>，会根据标签的不同生成不同的事件和属性。</p>
<p>例如：</p>
<ul>
<li><em>text</em> 和 <em>textarea</em> 元素使用 <em>value</em> 属性和 <em>input</em> 事件</li>
<li><em>checkbox</em> 和 <em>radio</em> 使用 <em>checked</em> 属性和 <em>change</em> 事件</li>
<li><em>select</em> 字段将 <em>value</em> 作为 <em>prop</em> 并将 <em>change</em> 作为事件</li>
</ul>
<p>以输入框为例，当用户在输入框输入内容时，会触发 <em>input</em> 事件，从而更新 <em>value</em>。而 <em>value</em> 的改变同样会更新视图，这就是 <em>vue</em> 中的双向绑定。双向绑定的原理，其实现思路如下：</p>
<p>首先要对数据进行劫持监听，所以我们需要设置一个监听器 <em>Observer</em>，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 <em>Watcher</em> 看是否需要更新。</p>
<p>因为订阅者是有很多个，所以我们需要有一个消息订阅器 <em>Dep</em> 来专门收集这些订阅者，然后在监听器 <em>Observer</em> 和订阅者 <em>Watcher</em> 之间进行统一管理的。</p>
<p>接着，我们还需要有一个指令解析器 <em>Compile</em>，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 <em>Watcher</em>，并替换模板数据或者绑定相应的函数，此时当订阅者 <em>Watcher</em> 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p>
<p>因此接下去我们执行以下 <em>3</em> 个步骤，实现数据的双向绑定：</p>
<ol>
<li><p>实现一个监听器 <em>Observer</em>，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
</li>
<li><p>实现一个订阅者 <em>Watcher</em>，可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
</li>
<li><p>实现一个解析器 <em>Compile</em>，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</p>
</li>
</ol>
<p>流程图如下：</p>
</blockquote>
<p><img src="/../images/717034f25ee385b09e9dee53b2988cae.png" alt="img"></p>
<h3 id="9-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？"><a href="#9-vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下？" class="headerlink" title="9. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？"></a>9. <strong><em>vue2.x</em> 和 <em>vuex3.x</em> 渲染器的 <em>diff</em> 算法分别说一下？</strong></h3><blockquote>
<p>直播讲解</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p>简单来说，<em>diff</em> 算法有以下过程</p>
<ul>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点一方没有子节点的情况(如果新的 <em>children</em> 没有子节点，将旧的子节点移除)</li>
<li>比较都有子节点的情况(核心 <em>diff</em>)</li>
<li>递归比较子节点</li>
</ul>
<p>正常 <em>Diff</em> 两个树的时间复杂度是 *O(n^3)<em>，但实际情况下我们很少会进行跨层级的移动 <em>DOM</em>，所以 <em>Vue</em> 将 <em>Diff</em> 进行了优化，从</em>O(n^3) -&gt; O(n)*，只有当新旧 <em>children</em> 都为多个子节点时才需要用核心的 <em>Diff</em> 算法进行同层级比较。</p>
<p><em>Vue2</em> 的核心 <em>Diff</em> 算法采用了双端比较的算法，同时从新旧 <em>children</em> 的两端开始进行比较，借助 <em>key</em> 值找到可复用的节点，再进行相关操作。相比 <em>React</em> 的 <em>Diff</em> 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p>
<p><em>Vue3.x</em> 借鉴了 <em>ivi</em> 算法和 <em>inferno</em> 算法</p>
<p>在创建 <em>VNode</em> 时就确定其类型，以及在 <em>mount&#x2F;patch</em> 的过程中采用位运算来判断一个 <em>VNode</em> 的类型，在这个基础之上再配合核心的 <em>Diff</em> 算法，使得性能上较 <em>Vue2.x</em> 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。</p>
</blockquote>
<h3 id="10-vue-组件的参数传递"><a href="#10-vue-组件的参数传递" class="headerlink" title="10. vue 组件的参数传递"></a>10. <strong><em>vue</em> 组件的参数传递</strong></h3><ul>
<li>解释一下父组件与子组件传值实现过程</li>
<li>非父子组件的数据传递，兄弟组件传值是如何实现的</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>解释一下父组件与子组件传值实现过程</strong></p>
<ul>
<li><p>父组件传给子组件：子组件通过 <em>props</em> 方法接受数据</p>
</li>
<li><p>子组件传给父组件：使用自定义事件，自组件通过 <em>$emit</em> 方法触发父组件的方法来传递参数</p>
</li>
</ul>
<p><strong>非父子组件的数据传递，兄弟组件传值是如何实现的</strong></p>
<p><em>eventBus</em>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。</p>
<p>此外，总结 <em>vue</em> 中的组件通信方式，常见使用场景可以分为三类：</p>
<ul>
<li>父子通信：<ul>
<li>父向子传递数据是通过 <em>props</em> ，子向父是通过 <em>$emit &#x2F; $on</em></li>
<li><em>$emit &#x2F; $bus</em></li>
<li><em>vuex</em></li>
<li>通过父链 &#x2F; 子链也可以通信（ <em>$parent &#x2F; $children</em> ）</li>
<li><em>ref</em> 也可以访问组件实例</li>
<li><em>v-model</em></li>
<li>.<em>sync</em> 修饰符</li>
</ul>
</li>
<li>兄弟通信：<ul>
<li><em>$emit &#x2F; $bus</em></li>
<li><em>vuex</em></li>
</ul>
</li>
<li>跨级通信：<ul>
<li><em>$emit &#x2F; $bus</em> </li>
<li><em>vuex</em> </li>
<li><em>provide &#x2F; inject API</em></li>
<li><em>$attrs&#x2F;$listeners</em></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="11-Vue-的路由实现"><a href="#11-Vue-的路由实现" class="headerlink" title="11. Vue 的路由实现"></a>11. <strong><em>Vue</em> 的路由实现</strong></h3><ul>
<li>解释 <em>hash</em> 模式和 <em>history</em> 模式的实现原理</li>
<li>说一下 <em>$router</em> 与 <em>$route</em> 的区别</li>
<li><em>vueRouter</em> 有哪几种导航守卫？</li>
<li>解释一下 <em>vueRouter</em> 的完整的导航解析流程是什么</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>解释 <em>hash</em> 模式和 <em>history</em> 模式的实现原理</strong></p>
<p><code>#</code> 后面 <em>hash</em> 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；通过监听 <em>hashchange</em> 事件可以知道 <em>hash</em> 发生了哪些变化，然后根据 <em>hash</em> 变化来实现更新页面部分内容的操作。</p>
<p><em>history</em> 模式的实现，主要是 <em>HTML5</em> 标准发布的两个 <em>API</em>，<em>pushState</em> 和 <em>replaceState</em>，这两个 <em>API</em> 可以在改变 <em>URL</em>，但是不会发送请求。这样就可以监听 <em>url</em> 变化来实现更新页面部分内容的操作。 </p>
<p>两种模式的区别：</p>
<ul>
<li><p>首先是在 <em>URL</em> 的展示上，<em>hash</em> 模式有“#”，<em>history</em> 模式没有</p>
</li>
<li><p>刷新页面时，<em>hash</em> 模式可以正常加载到 <em>hash</em> 值对应的页面，而 <em>history</em> 没有处理的话，会返回 <em>404</em>，一般需要后端将所有页面都配置重定向到首页路由</p>
</li>
<li><p>在兼容性上，<em>hash</em> 可以支持低版本浏览器和 <em>IE</em></p>
</li>
</ul>
<p><strong>说一下 <em>$router</em> 与 <em>$route</em> 的区别</strong></p>
<p><em>$route</em> 对象表示当前的路由信息，包含了当前 <em>URL</em> 解析得到的信息。包含当前的路径，参数，<em>query</em> 对象等。</p>
<ul>
<li><em>$route.path</em>：字符串，对应当前路由的路径，总是解析为绝对路径，如 “&#x2F;foo&#x2F;bar”。 </li>
<li><em>$route.params</em>： 一个 key&#x2F;value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。 </li>
<li><em>$route.query</em>：一个 key&#x2F;value 对象，表示 URL 查询参数。例如对于路径 <em>&#x2F;foo?user&#x3D;1</em>，则有 <em>$route.query.user &#x3D;&#x3D; 1</em>，如果没有查询参数，则是个空对象。 </li>
<li><em>$route.hash</em>：当前路由的 hash 值 (不带 #) ，如果没有 <em>hash</em> 值，则为空字符串。</li>
<li><em>$route.fullPath</em>：完成解析后的 <em>URL</em>，包含查询参数和 <em>hash</em> 的完整路径。 </li>
<li><em>$route.matched</em>：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。 </li>
<li><em>$route.name</em>：当前路径名字 </li>
<li><em>$route.meta</em>：路由元信息</li>
</ul>
<p><em>$route</em> 对象出现在多个地方:</p>
<ul>
<li>组件内的 <em>this.$route</em> 和 <em>route watcher</em> 回调（监测变化处理）</li>
<li><em>router.match(location)</em> 的返回值</li>
<li><em>scrollBehavior</em> 方法的参数</li>
<li>导航钩子的参数，例如 <em>router.beforeEach</em> 导航守卫的钩子函数中，<em>to</em> 和 <em>from</em> 都是这个路由信息对象。</li>
</ul>
<p><em>$router</em> 对象是全局路由的实例，是 <em>router</em> 构造方法的实例。</p>
<p><em>$router</em> 对象常用的方法有：</p>
<ul>
<li><em>push</em>：向 <em>history</em> 栈添加一个新的记录</li>
<li><em>go</em>：页面路由跳转前进或者后退</li>
<li><em>replace</em>：替换当前的页面，不会向 <em>history</em> 栈添加一个新的记录</li>
</ul>
<p><strong><em>vueRouter</em> 有哪几种导航守卫？</strong></p>
<ul>
<li><p>全局前置&#x2F;钩子：<em>beforeEach、beforeR-esolve、afterEach</em></p>
</li>
<li><p>路由独享的守卫：<em>beforeEnter</em></p>
</li>
<li><p>组件内的守卫：<em>beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</em></p>
</li>
</ul>
<p><strong>解释一下 <em>vueRouter</em> 的完整的导航解析流程是什么</strong></p>
<p>一次完整的导航解析流程如下：</p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <em>beforeEach</em> 守卫。</li>
<li>在重用的组件里调用 <em>beforeRouteUpdate</em> 守卫（*2.2+*）。</li>
<li>在路由配置里调用 <em>beforeEnter</em>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <em>beforeRouteEnter</em>。</li>
<li>调用全局的 <em>beforeResolve</em> 守卫（*2.5+*）。</li>
<li>导航被确认。</li>
<li>调用全局的 <em>afterEach</em> 钩子。</li>
<li>触发 <em>DOM</em> 更新。</li>
<li>用创建好的实例调用 <em>beforeRouteEnter</em> 守卫中传给 <em>next</em> 的回调函数。</li>
</ol>
</blockquote>
<h3 id="12-vuex-是什么？怎么使用它？什么场景下我们会使用到-vuex"><a href="#12-vuex-是什么？怎么使用它？什么场景下我们会使用到-vuex" class="headerlink" title="12. vuex* 是什么？怎么使用它？什么场景下我们会使用到 *vuex"></a>12. <em><strong>vuex* 是什么？怎么使用它？什么场景下我们会使用到 *vuex</strong></em></h3><blockquote>
<p>参考答案：</p>
<p><strong><em>vuex</em> 是什么</strong></p>
<p><em>vuex</em> 是一个专为 <em>Vue</em> 应用程序开发的状态管理器，采用集中式存储管理应用的所有组件的状态。每一个 <em>vuex</em> 应用的核心就是 <em>store</em>（仓库）。“<em>store</em>” 基本上就是一个容器，它包含着应用中大部分的状态 (<em>state</em>)。</p>
<p><strong>为什么需要 <em>vuex</em></strong></p>
<p>由于组件只维护自身的状态(<em>data</em>)，组件创建时或者路由切换时，组件会被初始化，从而导致 <em>data</em> 也随之销毁。</p>
<p><strong>使用方法</strong></p>
<p>在 <em>main.js</em> 引入 <em>store</em>，注入。只用来读取的状态集中放在 <em>store</em> 中， 改变状态的方式是提交 <em>mutations</em>，这是个同步的事物，异步逻辑应该封装在 <em>action</em> 中。</p>
<p><strong>什么场景下会使用到 <em>vuex</em></strong></p>
<p>如果是 <em>vue</em> 的小型应用，那么没有必要使用 <em>vuex</em>，这个时候使用 <em>vuex</em> 反而会带来负担。组件之间的状态传递使用 <em>props</em>、自定义事件来传递即可。</p>
<p>但是如果涉及到 <em>vue</em> 的大型应用，那么就需要类似于 <em>vuex</em> 这样的集中管理状态的状态机来管理所有组件的状态。例如登录状态、加入购物车、音乐播放等，总之只要是开发 <em>vue</em> 的大型应用，都推荐使用 <em>vuex</em> 来管理所有组件状态。</p>
</blockquote>
<h3 id="13-说一下-v-for-与-v-show-的区别"><a href="#13-说一下-v-for-与-v-show-的区别" class="headerlink" title="13. 说一下 v-for 与 v-show 的区别"></a>13. <strong>说一下 <em>v-for</em> 与 <em>v-show</em> 的区别</strong></h3><blockquote>
<p>参考答案：</p>
<ul>
<li><p>共同点：都是动态显示 <em>DOM</em> 元素 </p>
</li>
<li><p>区别点:</p>
<ul>
<li><p>手段</p>
<p><em>v-if</em> 是动态的向 <em>DOM</em> 树内添加或者删除 <em>DOM</em> 元素</p>
<p><em>v-show</em> 是通过设置 <em>DOM</em> 元素的 <em>display</em> 样式属性控制显隐</p>
</li>
<li><p>编译过程</p>
<p><em>v-if</em>  切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</p>
<p><em>v-show</em> 只是简单的基于 <em>css</em> 切换</p>
</li>
<li><p>编译条件</p>
<p><em>v-if</em>  是惰性的，如果初始条件为假，则什么也不做。只有在条件第一次变为真时才开始局部编译</p>
<p><em>v-show</em> 是在任何条件下(首次条件是否为真)都被编译，然后被缓存，而且 <em>DOM</em> 元素保留</p>
</li>
<li><p>性能消耗</p>
<p><em>v-if</em>  有更高的切换消耗</p>
<p><em>v-show</em> 有更高的初始渲染消耗</p>
</li>
<li><p>使用场景</p>
<p><em>v-if</em>  适合运营条件不大可能改变 </p>
<p><em>v-show</em> 适合频繁切换</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="14-如何让-CSS-值在当前的组件中起作用"><a href="#14-如何让-CSS-值在当前的组件中起作用" class="headerlink" title="14. 如何让 CSS 值在当前的组件中起作用"></a>14. <strong>如何让 <em>CSS</em> 值在当前的组件中起作用</strong></h3><blockquote>
<p>参考答案：</p>
<p>在 <em>vue</em> 文件中的 <em>style</em> 标签上，有一个特殊的属性：<em>scoped</em>。当一个 style 标签拥有 <em>scoped</em> 属性时，它的 <em>CSS</em> 样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有 <em>style</em> 标签全部加上了 <em>scoped</em>，相当于实现了样式的模块化。</p>
<p><strong><em>scoped</em> 的实现原理</strong></p>
<p><em>vue</em> 中的 <em>scoped</em> 属性的效果主要通过 <em>PostCSS</em> 转译实现的。<em>PostCSS</em> 给一个组件中的所有 <em>DOM</em> 添加了一个独一无二的动态属性，然后，给 <em>CSS</em> 选择器额外添加一个对应的属性选择器来选择该组件中 <em>DOM</em>，这种做法使得样式只作用于含有该属性的 <em>DOM</em>，即组件内部 <em>DOM</em>。</p>
<p>例如：</p>
<p>转译前</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.example</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>转译后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span> <span class="attr">data-v-5558831a</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.example</span><span class="selector-attr">[data-v-5558831a]</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="15-keep-alive-相关"><a href="#15-keep-alive-相关" class="headerlink" title="15. keep-alive 相关"></a>15. <strong><em>keep-alive</em> 相关</strong></h3><ul>
<li>keep-alive的实现原理是什么</li>
<li>与keep-alive相关的生命周期函数是什么，什么场景下会进行使用</li>
<li>keep-alive的常用属性有哪些</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p>keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。</p>
<p>keep-alive 具有 include 和 exclude 属性，通过它们可以控制哪些组件进入缓存。另外它还提供了 max 属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。</p>
<p>受keep-alive的影响，其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后</p>
<p>在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keep-alive 内部的声明周期函数</span></span><br><span class="line"><span class="title function_">created</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值</p>
<p>cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM</p>
<p>在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。</p>
<p>当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素。</p>
</blockquote>
<h3 id="16-Vue-中如何进行组件的使用？-Vue-如何实现全局组件的注册？"><a href="#16-Vue-中如何进行组件的使用？-Vue-如何实现全局组件的注册？" class="headerlink" title="16. *Vue 中如何进行组件的使用？*Vue 如何实现全局组件的注册？**"></a>16. <em>*<em>Vue</em> 中如何进行组件的使用？*Vue</em> 如何实现全局组件的注册？**</h3><blockquote>
<p>参考答案：</p>
<p>要使用组件，首先需要使用 <em>import</em> 来引入组件，然后在 <em>components</em> 属性中注册组件，之后就可以在模板中使用组件了。</p>
<p>可以使用 <em>Vue.component</em> 方法来实现全局组件的注册。</p>
</blockquote>
<h3 id="17-vue-cli-工程相关"><a href="#17-vue-cli-工程相关" class="headerlink" title="17. vue-cli 工程相关"></a>17. <strong><em>vue-cli</em> 工程相关</strong></h3><ul>
<li>构建 <em>vue-cli</em> 工程都用到了哪些技术？他们的作用分别是什么？</li>
<li><em>vue-cli</em> 工程常用的 <em>npm</em> 命令有哪些？</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p><strong>构建 <em>vue-cli</em> 工程都用到了哪些技术？他们的作用分别是什么？</strong></p>
<ol>
<li>vue.js：vue-cli 工程的核心，主要特点是双向数据绑定和组件系统。</li>
<li>vue-router：vue 官方推荐使用的路由框架。</li>
<li>vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。</li>
<li>axios（或者 fetch、ajax）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。</li>
<li>vux等：一个专为vue设计的移动端UI组件库。</li>
<li>webpack：模块加载和vue-cli工程打包器。</li>
<li>eslint：代码规范工具</li>
</ol>
<p><strong><em>vue-cli</em> 工程常用的 <em>npm</em> 命令有哪些？</strong></p>
<p>下载 node_modules 资源包的命令：npm install</p>
<p>启动 vue-cli 开发环境的 npm命令：npm run dev</p>
<p>vue-cli 生成 生产环境部署资源 的 npm命令：npm run build</p>
<p>用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：npm run build –report</p>
</blockquote>
<h3 id="18-nextTick-的作用是什么？他的实现原理是什么？"><a href="#18-nextTick-的作用是什么？他的实现原理是什么？" class="headerlink" title="18. nextTick 的作用是什么？他的实现原理是什么？"></a>18. <strong><em>nextTick</em> 的作用是什么？他的实现原理是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p>作用：<em>vue</em> 更新 <em>DOM</em> 是异步更新的，数据变化，<em>DOM</em> 的更新不会马上完成，<em>nextTick</em> 的回调是在下次 <em>DOM</em> 更新循环结束之后执行的延迟回调。</p>
<p>实现原理：<em>nextTick</em> 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li><em>Promise</em>：可以将函数延迟到当前函数调用栈最末端</li>
<li><em>MutationObserver</em> ：是 <em>H5</em> 新加的一个功能，其功能是监听 <em>DOM</em> 节点的变动，在所有 <em>DOM</em> 变动完成后，执行回调函数</li>
<li><em>setImmediate</em>：用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数</li>
<li>如果以上都不行则采用 <em>setTimeout</em> 把函数延迟到 DOM 更新之后再使用</li>
</ul>
<p>原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务。</p>
</blockquote>
<h3 id="19-说一下-Vue-SSR-的实现原理"><a href="#19-说一下-Vue-SSR-的实现原理" class="headerlink" title="19. 说一下 Vue SSR 的实现原理"></a>19. <strong>说一下 <em>Vue SSR</em> 的实现原理</strong></h3><blockquote>
<p>参考答案：</p>
<ul>
<li><em>app.js</em> 作为客户端与服务端的公用入口，导出 <em>Vue</em> 根实例，供客户端 <em>entry</em> 与服务端 <em>entry</em> 使用。客户端 <em>entry</em> 主要作用挂载到 <em>DOM</em> 上，服务端 <em>entry</em> 除了创建和返回实例，还需要进行路由匹配与数据预获取。</li>
<li><em>webpack</em> 为客服端打包一个 <em>ClientBundle</em>，为服务端打包一个 <em>ServerBundle</em>。</li>
<li>服务器接收请求时，会根据 <em>url</em>，加载相应组件，获取和解析异步数据，创建一个读取 <em>Server Bundle</em> 的 <em>BundleRenderer</em>，然后生成 <em>html</em> 发送给客户端。</li>
<li>客户端混合，客户端收到从服务端传来的 <em>DOM</em> 与自己的生成的 <em>DOM</em> 进行对比，把不相同的 <em>DOM</em> 激活，使其可以能够响应后续变化，这个过程称为客户端激活（也就是转换为单页应用）。为确保混合成功，客户 端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 <em>store</em> 里，这样，在客户端挂载到 <em>DOM</em> 之前，可以直接从 <em>store</em> 里取数据。首屏的动态数据通过 <em>window._<em>INITIAL_STATE</em>_</em> 发送到客户端</li>
<li><em>VueSSR</em> 的原理，主要就是通过 <em>vue-server-renderer</em> 把 <em>Vue</em> 的组件输出成一个完整 <em>HTML</em>，输出到客户端，到达客户端后重新展开为一个单页应用。</li>
</ul>
</blockquote>
<h3 id="20-Vue-组件的-data-为什么必须是函数"><a href="#20-Vue-组件的-data-为什么必须是函数" class="headerlink" title="20. Vue 组件的 data 为什么必须是函数"></a>20. <strong><em>Vue</em> 组件的 <em>data</em> 为什么必须是函数</strong></h3><blockquote>
<p>参考答案：</p>
<p>组件中的 <em>data</em> 写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的 <em>data</em>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 <em>data</em>，就会造成一个变了全都会变的结果。</p>
</blockquote>
<h3 id="21-说一下-Vue-的-computed-的实现原理"><a href="#21-说一下-Vue-的-computed-的实现原理" class="headerlink" title="21. 说一下 Vue 的 computed 的实现原理"></a>21. <strong>说一下 <em>Vue</em> 的 <em>computed</em> 的实现原理</strong></h3><blockquote>
<p>参考答案：</p>
<p>当组件实例触发生命周期函数 <em>beforeCreate</em> 后，它会做一系列事情，其中就包括对 <em>computed</em> 的处理。</p>
<p>它会遍历 <em>computed</em> 配置中的所有属性，为每一个属性创建一个 <em>Watcher</em> 对象，并传入一个函数，该函数的本质其实就是 <em>computed</em> 配置中的 <em>getter</em>，这样一来，<em>getter</em> 运行过程中就会收集依赖</p>
<p>但是和渲染函数不同，为计算属性创建的 <em>Watcher</em> 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 <em>Watcher</em> 的时候，它使用了 <em>lazy</em> 配置，<em>lazy</em> 配置可以让 <em>Watcher</em> 不会立即执行。</p>
<p>收到 <em>lazy</em> 的影响，<em>Watcher</em> 内部会保存两个关键属性来实现缓存，一个是 <em>value</em>，一个是 <em>dirty</em></p>
<p><em>value</em> 属性用于保存 <em>Watcher</em> 运行的结果，受 <em>lazy</em> 的影响，该值在最开始是 <em>undefined</em></p>
<p><em>dirty</em> 属性用于指示当前的 <em>value</em> 是否已经过时了，即是否为脏值，受 <em>lazy</em> 的影响，该值在最开始是 <em>true</em></p>
<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>
<p>当读取计算属性时，<em>vue</em> 检查其对应的 <em>Watcher</em> 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 <em>Watcher</em> 的 <em>value</em> 中，然后设置 <em>dirty</em> 为 <em>false</em>，然后返回。</p>
<p>如果 <em>dirty</em> 为 <em>false</em>，则直接返回 <em>watcher</em> 的 <em>value</em></p>
<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 <em>Watcher</em>，还会收集到组件的 <em>Watcher</em></p>
<p>当计算属性的依赖变化时，会先触发计算属性的 <em>Watcher</em> 执行，此时，它只需设置 <em>dirty</em> 为 <em>true</em> 即可，不做任何处理。</p>
<p>由于依赖同时会收集到组件的 <em>Watcher</em>，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 <em>getter</em> 进行运算</p>
<p>而对于计算属性的 <em>setter</em>，则极其简单，当设置计算属性时，直接运行 <em>setter</em> 即可。</p>
</blockquote>
<h3 id="22-说一下-Vue-complier-的实现原理是什么样的？"><a href="#22-说一下-Vue-complier-的实现原理是什么样的？" class="headerlink" title="22. 说一下 Vue complier 的实现原理是什么样的？"></a>22. <strong>说一下 <em>Vue complier</em> 的实现原理是什么样的？</strong></h3><blockquote>
<p>参考答案：</p>
<p>在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template 的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。</p>
<p>complier 的主要作用是解析模板，生成渲染模板的 <em>render</em>， 而 <em>render</em> 的作用主要是为了生成 <em>VNode</em></p>
<p>complier 主要分为 3 大块：</p>
<ul>
<li>parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast</li>
<li>optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能</li>
<li>generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</li>
</ul>
</blockquote>
<h3 id="23-vue-如何快速定位那个组件出现性能问题的"><a href="#23-vue-如何快速定位那个组件出现性能问题的" class="headerlink" title="23. vue 如何快速定位那个组件出现性能问题的"></a>23. <strong><em>vue</em> 如何快速定位那个组件出现性能问题的</strong></h3><blockquote>
<p>参考答案：</p>
<p>⽤ <em>timeline</em> ⼯具。 通过 <em>timeline</em> 来查看每个函数的调⽤时常，定位出哪个函数的问题，从⽽能判断哪个组件出了问题。</p>
</blockquote>
<h3 id="24-Proxy-相比-defineProperty-的优势在哪里"><a href="#24-Proxy-相比-defineProperty-的优势在哪里" class="headerlink" title="24. Proxy 相比 defineProperty 的优势在哪里"></a>24. <strong><em>Proxy</em> 相比 <em>defineProperty</em> 的优势在哪里</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Vue3.x</em> 改用 <em>Proxy</em> 替代 <em>Object.defineProperty</em></p>
<p>原因在于 <em>Object.defineProperty</em> 本身存在的一些问题：</p>
<ul>
<li><em>Object.defineProperty</em> 只能劫持对象属性的 <em>getter</em> 和 <em>setter</em> 方法。</li>
<li><em>Object.definedProperty</em> 不支持数组(可以监听数组,不过数组方法无法监听自己重写)，更准确的说是不支持数组的各种 <em>API</em>(所以 <em>Vue</em> 重写了数组方法。</li>
</ul>
<p>而相比  <em>Object.defineProperty</em>，<em>Proxy</em> 的优点在于：</p>
<ul>
<li><em>Proxy</em> 是直接代理劫持整个对象。</li>
<li><em>Proxy</em> 可以直接监听对象和数组的变化，并且有多达 <em>13</em> 种拦截方法。</li>
</ul>
<p>目前，<em>Object.definedProperty</em> 唯一比 <em>Proxy</em> 好的一点就是兼容性，不过 <em>Proxy</em> 新标准也受到浏览器厂商重点持续的性能优化当中。</p>
</blockquote>
<h3 id="25-Vue-与-Angular-以及-React-的区别是什么？"><a href="#25-Vue-与-Angular-以及-React-的区别是什么？" class="headerlink" title="25. Vue 与 Angular 以及 React 的区别是什么？"></a>25. <strong><em>Vue</em> 与 <em>Angular</em> 以及 <em>React</em> 的区别是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p>这种题目是开放性题目，一般是面试过程中面试官口头来提问，不太可能出现在笔试试卷里面。</p>
<p>关于 <em>Vue</em> 和其他框架的不同，官方专门写了一篇文档，从性能、体积、灵活性等多个方面来进行了说明。</p>
<p>详细可以参阅：<em><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/comparison.html">https://cn.vuejs.org/v2/guide/comparison.html</a></em></p>
<p>建议面试前通读一遍该篇文档，然后进行适当的总结。</p>
</blockquote>
<h3 id="26-说一下-watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？"><a href="#26-说一下-watch-与-computed-的区别是什么？以及他们的使用场景分别是什么？" class="headerlink" title="26. 说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？"></a>26. <strong>说一下 <em>watch</em> 与 <em>computed</em> 的区别是什么？以及他们的使用场景分别是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p>区别：</p>
<ol>
<li>都是观察数据变化的（相同）</li>
<li>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化；</li>
<li>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</li>
<li>watch 支持异步，computed 不支持；</li>
<li>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</li>
<li>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</li>
<li>computed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</li>
</ol>
<p>watch 的 参数：</p>
<ul>
<li>deep：深度监听</li>
<li>immediate ：组件加载立即触发回调函数执行</li>
</ul>
<p>computed 缓存原理：</p>
<p>conputed本质是一个惰性的观察者；当计算数据存在于 data 或者 props里时会被警告；</p>
<p>vue 初次运行会对 computed 属性做初始化处理（initComputed），初始化的时候会对每一个 computed 属性用 watcher 包装起来 ，这里面会生成一个 dirty 属性值为 true；然后执行 defineComputed 函数来计算，计算之后会将 dirty 值变为 false，这里会根据 dirty 值来判断是否需要重新计算；如果属性依赖的数据发生变化，computed 的 watcher 会把 dirty 变为 true，这样就会重新计算 computed 属性的值。</p>
</blockquote>
<h3 id="27-scoped-是如何实现样式穿透的？"><a href="#27-scoped-是如何实现样式穿透的？" class="headerlink" title="27. scoped 是如何实现样式穿透的？"></a>27. <strong><em>scoped</em> 是如何实现样式穿透的？</strong></h3><blockquote>
<p>参考答案：</p>
<p>首先说一下什么场景下需要 <em>scoped</em> 样式穿透。</p>
<p>在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除 <em>scoped</em> 属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透 <em>scoped</em>。</p>
<p>有三种常用的方法来实现样式穿透。</p>
<p><strong>方法一</strong></p>
<p>使用 <em>::v-deep</em> 操作符( &gt;&gt;&gt; 的别名)</p>
<p>如果希望 <em>scoped</em> 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 &gt;&gt;&gt; 操作符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .<span class="property">a</span> &gt;&gt;&gt; .<span class="property">b</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码将会编译成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">a</span>[data-v-f3f3eg9] .<span class="property">b</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>后面的类名没有 <em>data</em> 属性，所以能选到子组件里面的类名。</p>
<p>有些像 <em>Sass</em> 之类的预处理器无法正确解析 &gt;&gt;&gt;，所以需要使用 <em>::v-deep</em> 操作符来代替。</p>
<p><strong>方法二</strong></p>
<p>定义一个含有 <em>scoped</em> 属性的 <em>style</em> 标签之外，再定义一个不含有 <em>scoped</em> 属性的 <em>style</em> 标签，即在一个 <em>vue</em> 组件中定义一个全局的 <em>style</em> 标签，一个含有作用域的 <em>style</em> 标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/* global styles */</span></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="comment">/* local styles */</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>此时，我们只需要将修改第三方样式的 <em>css</em> 写在第一个 <em>style</em> 中即可。</p>
<p><strong>方法三</strong></p>
<p>上面的方法一需要单独书写一个不含有 <em>scoped</em> 属性的 <em>style</em> 标签，可能会造成全局样式的污染。</p>
<p>更推荐的方式是在组件的外层 <em>DOM</em> 上添加唯一的 <em>class</em> 来区分不同组件，在书写样式时就可以正常针对针对这部分 <em>DOM</em> 书写样式。</p>
</blockquote>
<h3 id="28-说一下-ref-的作用是什么？"><a href="#28-说一下-ref-的作用是什么？" class="headerlink" title="28. 说一下 ref 的作用是什么？"></a>28. <strong>说一下 <em>ref</em> 的作用是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>ref</em> 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <em>$refs</em> 对象上。其特点是：</p>
<ul>
<li>如果在普通的 <em>DOM</em> 元素上使用，引用指向的就是 <em>DOM</em> 元素</li>
<li>如果用在子组件上，引用就指向组件实例</li>
</ul>
<p>所以常见的使用场景有：</p>
<ol>
<li>基本用法，本页面获取 <em>DOM</em> 元素</li>
<li>获取子组件中的 <em>data</em></li>
<li>调用子组件中的方法</li>
</ol>
</blockquote>
<h3 id="29-说一下你知道的-vue-修饰符都有哪些？"><a href="#29-说一下你知道的-vue-修饰符都有哪些？" class="headerlink" title="29. 说一下你知道的 vue 修饰符都有哪些？"></a>29. <strong>说一下你知道的 <em>vue</em> 修饰符都有哪些？</strong></h3><blockquote>
<p>参考答案：</p>
<p>在 <em>vue</em> 中修饰符可以分为 <em>3</em> 类：</p>
<ul>
<li>事件修饰符</li>
<li>按键修饰符</li>
<li>表单修饰符</li>
</ul>
<p><strong>事件修饰符</strong></p>
<p>在事件处理程序中调用 <em>event.preventDefault</em> 或 <em>event.stopPropagation</em> 方法是非常常见的需求。尽管可以在 <em>methods</em> 中轻松实现这点，但更好的方式是：<em>methods</em> 只有纯粹的数据逻辑，而不是去处理 <em>DOM</em> 事件细节。</p>
<p>为了解决这个问题，<em>vue</em> 为 <em>v-on</em> 提供了事件修饰符。通过由点 <em>.</em> 表示的指令后缀来调用修饰符。</p>
<p>常见的事件修饰符如下：</p>
<ul>
<li><em>.stop</em>：阻止冒泡。</li>
<li><em>.prevent</em>：阻止默认事件。</li>
<li><em>.capture</em>：使用事件捕获模式。</li>
<li><em>.self</em>：只在当前元素本身触发。</li>
<li><em>.once</em>：只触发一次。</li>
<li><em>.passive</em>：默认行为将会立即触发。</li>
</ul>
<p><strong>按键修饰符</strong></p>
<p>除了事件修饰符以外，在 <em>vue</em> 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。</p>
<ul>
<li>.<em>left</em>：左键</li>
<li>.<em>right</em>：右键</li>
<li>.<em>middle</em>：滚轮</li>
<li>.<em>enter</em>：回车</li>
<li>.<em>tab</em>：制表键</li>
<li>.<em>delete</em>：捕获 “删除” 和 “退格” 键</li>
<li>.<em>esc</em>：返回</li>
<li>.<em>space</em>：空格</li>
<li>.<em>up</em>：上</li>
<li>.<em>down</em>：下</li>
<li>.<em>left</em>：左</li>
<li>.<em>right</em>：右</li>
<li>.<em>ctrl</em>：<em>ctrl</em> 键</li>
<li>.<em>alt</em>：<em>alt</em> 键</li>
<li>.<em>shift</em>：<em>shift</em> 键</li>
<li>.<em>meta</em>：<em>meta</em> 键</li>
</ul>
<p><strong>表单修饰符</strong></p>
<p><em>vue</em> 同样也为表单控件也提供了修饰符，常见的有 <em>.lazy</em>、*.number* 和 <em>.trim</em>。</p>
<ul>
<li>.<em>lazy</em>：在文本框失去焦点时才会渲染</li>
<li>.<em>number</em>：将文本框中所输入的内容转换为number类型</li>
<li>.<em>trim</em>：可以自动过滤输入首尾的空格</li>
</ul>
</blockquote>
<h3 id="30-如何实现-vue-项目中的性能优化？"><a href="#30-如何实现-vue-项目中的性能优化？" class="headerlink" title="30. 如何实现 vue 项目中的性能优化？"></a>30. <strong>如何实现 <em>vue</em> 项目中的性能优化？</strong></h3><blockquote>
<p>直播课讲解</p>
</blockquote>
<blockquote>
<p>参考答案：</p>
<p><strong>编码阶段</strong></p>
<ul>
<li>尽量减少 <em>data</em> 中的数据，<em>data</em> 中的数据都会增加 <em>getter</em> 和 <em>setter</em>，会收集对应的 <em>watcher</em></li>
<li><em>v-if</em> 和 <em>v-for</em> 不能连用</li>
<li>如果需要使用 <em>v-for</em> 给每项元素绑定事件时使用事件代理</li>
<li><em>SPA</em> 页面采用 <em>keep-alive</em> 缓存组件</li>
<li>在更多的情况下，使用 <em>v-if</em> 替代 <em>v-show</em></li>
<li><em>key</em> 保证唯一</li>
<li>使用路由懒加载、异步组件</li>
<li>防抖、节流</li>
<li>第三方模块按需导入</li>
<li>长列表滚动到可视区域动态加载</li>
<li>图片懒加载</li>
</ul>
<p><strong><em>SEO</em> 优化</strong></p>
<ul>
<li>预渲染</li>
<li>服务端渲染 <em>SSR</em></li>
</ul>
<p><strong>打包优化</strong></p>
<ul>
<li>压缩代码</li>
<li><em>Tree Shaking&#x2F;Scope Hoisting</em></li>
<li>使用 <em>cdn</em> 加载第三方模块</li>
<li>多线程打包 <em>happypack</em></li>
<li><em>splitChunks</em> 抽离公共文件</li>
<li><em>sourceMap</em> 优化</li>
</ul>
<p><strong>用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li><em>PWA</em></li>
</ul>
<p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 <em>gzip</em> 压缩等。</p>
</blockquote>
<h3 id="31-Vue-extend-和-Vue-component-的区别是什么？"><a href="#31-Vue-extend-和-Vue-component-的区别是什么？" class="headerlink" title="31. Vue.extend 和 Vue.component 的区别是什么？"></a>31. <strong><em>Vue.extend</em> 和 <em>Vue.component</em> 的区别是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Vue.extend</em> 用于创建一个基于 <em>Vue</em> 构造函数的“子类”，其参数应为一个包含组件选项的对象。</p>
<p><em>Vue.component</em> 用来注册全局组件。</p>
</blockquote>
<h3 id="32-vue-中的-spa-应用如何优化首屏加载速度"><a href="#32-vue-中的-spa-应用如何优化首屏加载速度" class="headerlink" title="32. vue 中的 spa 应用如何优化首屏加载速度?"></a>32. <strong><em>vue</em> 中的 <em>spa</em> 应用如何优化首屏加载速度?</strong></h3><blockquote>
<p>参考答案：</p>
<p>优化首屏加载可以从这几个方面开始：</p>
<ul>
<li>请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</li>
<li>缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验</li>
<li>gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。</li>
<li>http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。</li>
<li>懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件</li>
<li>预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化</li>
<li>合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积</li>
<li>使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化</li>
<li>提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程</li>
<li>封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化</li>
<li>图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验</li>
<li>使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求</li>
<li>压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片</li>
</ul>
</blockquote>
<h3 id="33-移动端如何实现一个比较友好的-header-组件"><a href="#33-移动端如何实现一个比较友好的-header-组件" class="headerlink" title="33. 移动端如何实现一个比较友好的 header 组件"></a>33. <strong>移动端如何实现一个比较友好的 <em>header</em> 组件</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>Header</em> 一般分为左、中、右三个部分，分为三个区域来设计，中间为主标题，每个页面的标题肯定不同，所以可以通过 <em>vue props</em>的方式做成可配置对外进行暴露，左侧大部分页面可能都是回退按钮，但是样式和内容不尽相同，右侧一般都是具有功能性的操作按钮，所以左右两侧可以通过 <em>vue slot</em> 插槽的方式对外暴露以实现多样化，同时也可以提供 <em>default slot</em> 默认插槽来统一页面风格。</p>
</blockquote>
<h3 id="34-既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？"><a href="#34-既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？" class="headerlink" title="34. 既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？"></a>34. <strong>既然 <em>Vue</em> 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 <em>DOM</em> 进行 <em>diff</em> 监测差异 ？</strong></h3><blockquote>
<p>参考答案：</p>
<p>现代前端框架有两种方式侦测变化，一种是 <em>pull</em>，一种是 <em>push</em>。</p>
<p><em><strong>pull</strong></em></p>
<p>其代表为 <em>React</em>，我们可以回忆一下 <em>React</em> 是如何侦测到变化的。</p>
<p>我们通常会用 <em>setState API</em> 显式更新,然后 <em>React</em> 会进行一层层的 <em>Virtual Dom Diff</em> 操作找出差异，然后 <em>Patch</em> 到 <em>DOM</em> 上，<em>React</em> 从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的 <em>Diff</em> 操作查找「哪发生变化了」，另外一个代表就是 <em>Angular</em> 的脏检查操作。</p>
<p><em><strong>push</strong></em></p>
<p><em>Vue</em> 的响应式系统则是 <em>push</em> 的代表，当 <em>Vue</em> 程序初始化的时候就会对数据 <em>data</em> 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此 <em>Vue</em> 是一开始就知道是「在哪发生变化了」</p>
<p>但是这又会产生一个问题，通常绑定一个数据就需要一个 <em>Watcher</em>，一但我们的绑定细粒度过高就会产生大量的 <em>Watcher</em>，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 <em>Vue</em> 的设计是选择中等细粒度的方案，在组件级别进行 <em>push</em> 侦测的方式，也就是那套响应式系统。</p>
<p>通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行 <em>Virtual Dom Diff</em> 获取更加具体的差异，而 <em>Virtual Dom Diff</em> 则是 <em>pull</em> 操作，<em>Vue</em> 是 <em>push + pull</em> 结合的方式进行变化侦测的。</p>
</blockquote>
<h3 id="35-Vue-为什么没有类似于-React-中-shouldComponentUpdate-的生命周期？"><a href="#35-Vue-为什么没有类似于-React-中-shouldComponentUpdate-的生命周期？" class="headerlink" title="35. Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？"></a>35. <strong><em>Vue</em> 为什么没有类似于 <em>React</em> 中 <em>shouldComponentUpdate</em> 的生命周期？</strong></h3><blockquote>
<p>参考答案：</p>
<p>根本原因是 <em>Vue</em> 与 <em>React</em> 的变化侦测方式有所不同</p>
<p><em>React</em> 是 <em>pull</em> 的方式侦测变化，当 <em>React</em> 知道发生变化后，会使用 <em>Virtual Dom Diff</em> 进行差异检测,但是很多组件实际上是肯定不会发生变化的，这个时候需要用 <em>shouldComponentUpdate</em> 进行手动操作来减少 <em>diff</em>，从而提高程序整体的性能。</p>
<p><em>Vue</em> 是 <em>pull+push</em> 的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在 <em>push</em> 的阶段并不需要手动控制 <em>diff</em>，而组件内部采用的 <em>diff</em> 方式实际上是可以引入类似于 <em>shouldComponentUpdate</em> 相关生命周期的，但是通常合理大小的组件不会有过量的 <em>diff</em>，手动优化的价值有限，因此目前 <em>Vue</em> 并没有考虑引入 <em>shouldComponentUpdate</em> 这种手动优化的生命周期。</p>
</blockquote>
<h3 id="36-Vue-中的-Key-的作用是什么？"><a href="#36-Vue-中的-Key-的作用是什么？" class="headerlink" title="36. Vue 中的 Key 的作用是什么？"></a>36. <strong><em>Vue</em> 中的 <em>Key</em> 的作用是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em><strong>key* 的作用主要是为了高效的更新虚拟 *DOM</strong></em>。另外 <em>vue</em> 中在使用相同标签名元素的过渡切换时，也会使用到 <em>key</em> 属性，其目的也是为了让 <em>vue</em> 可以区分它们，否则 <em>vue</em> 只会替换其内部属性而不会触发过渡效果。</p>
</blockquote>
<blockquote>
<p>解析：</p>
<p>其实不只是 <em>vue</em>，<em>react</em> 中在执行列表渲染时也会要求给每个组件添加上 <em>key</em> 这个属性。</p>
<p>要解释 <em>key</em> 的作用，不得不先介绍一下虚拟 <em>DOM</em> 的 <em>Diff</em> 算法了。</p>
<p>我们知道，<em>vue</em> 和 <em>react</em> 都实现了一套虚拟 <em>DOM</em>，使我们可以不直接操作 <em>DOM</em> 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 <em>Diff</em> 算法。</p>
<p><em>vue</em> 和 <em>react</em> 的虚拟 <em>DOM</em> 的 <em>Diff</em> 算法大致相同，其核心有以下两点：</p>
<ul>
<li><p>两个相同的组件产生类似的 <em>DOM</em> 结构，不同的组件产生不同的 <em>DOM</em> 结构。</p>
</li>
<li><p>同一层级的一组节点，他们可以通过唯一的 <em>id</em> 进行区分。</p>
</li>
</ul>
<p>基于以上这两点，使得虚拟 <em>DOM</em> 的 <em>Diff</em> 算法的复杂度从 <em>O(n^3)</em> 降到了 *O(n)*。</p>
</blockquote>
<p><img src="/../images/2021-08-21-062058.png"></p>
<blockquote>
<p>当页面的数据发生变化时，<em>Diff</em> 算法只会比较同一层级的节点：</p>
<ul>
<li>如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。</li>
<li>如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。</li>
</ul>
<p>当某一层有很多相同的节点时，也就是列表节点时，<em>Diff</em> 算法的更新过程默认情况下也是遵循以上原则。</p>
<p>比如一下这个情况：</p>
</blockquote>
<blockquote>
<p><img src="/../images/2021-08-21-062225.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>我们希望可以在 <em>B</em> 和 <em>C</em> 之间加一个 <em>F</em>，<em>Diff</em> 算法默认执行起来是这样的：</p>
<p><img src="/../images/2021-08-21-062244.jpg" alt="img"></p>
<p>即把 <em>C</em> 更新成 <em>F</em>，<em>D</em> 更新成 <em>C</em>，<em>E</em> 更新成 <em>D</em>，最后再插入 <em>E</em></p>
<p>是不是很没有效率？</p>
<p>所以我们需要使用 <em>key</em> 来给每个节点做一个唯一标识，<em>Diff</em> 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p>
<p><img src="/../images/2021-08-21-062321.jpg" alt="img"></p>
</blockquote>
<h3 id="37-你的接口请求一般放在哪个生命周期中？为什么要这样做？"><a href="#37-你的接口请求一般放在哪个生命周期中？为什么要这样做？" class="headerlink" title="37. 你的接口请求一般放在哪个生命周期中？为什么要这样做？"></a>37. <strong>你的接口请求一般放在哪个生命周期中？为什么要这样做？</strong></h3><blockquote>
<p>参考答案：</p>
<p>接口请求可以放在钩子函数 <em>created、beforeMount、mounted</em> 中进行调用，因为在这三个钩子函数中，<em>data</em> 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>但是推荐在 <em>created</em> 钩子函数中调用异步请求，因为在 <em>created</em> 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 <em>loading</em> 时间</li>
<li><em>SSR</em> 不支持 <em>beforeMount 、mounted</em> 钩子函数，所以放在 <em>created</em> 中有助于代码的一致性</li>
<li><em>created</em> 是在模板渲染成 <em>html</em> 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 <em>mounted</em> 钩子函数中请求数据可能导致页面闪屏问题</li>
</ul>
</blockquote>
<h3 id="38-说一下你对-vue-事件绑定原理的理解？"><a href="#38-说一下你对-vue-事件绑定原理的理解？" class="headerlink" title="38. 说一下你对 vue 事件绑定原理的理解？"></a>38. <strong>说一下你对 <em>vue</em> 事件绑定原理的理解？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>vue</em> 中的事件绑定是有两种，一种是原生的事件绑定，另一种是组件的事件绑定。</p>
<p>原生的事件绑定在普通元素上是通过 <em>@click</em> 进行绑定，在组件上是通过 <em>@click.native</em> 进行绑定，组件中的 <em>nativeOn</em> 是等价于 on 的。组件的事件绑定的 @click 是 vue 中自定义的 $on 方法来实现的，必须有 $emit 才可以触发。</p>
<p><strong>原生事件绑定原理</strong></p>
<p>在 runtime下的patch.js中createPatchFunction执行了之后再赋值给patch。</p>
<p>createPatchFunction方法有两个参数，分别是nodeOps存放操作dom节点的方法和modules，modules是有两个数组拼接起来的，modules拼接完的数组中有一个元素就是events，事件添加就发生在这里。</p>
<p>events元素关联的就是events.js文件，在events中有一个updateDOMListeners方法，在events文件的结尾导出了一个对象，然后对象有一个属性叫做create，这个属性关联的就是updateDOMListeners方法。</p>
<p>在执行createPatchFunction方法时，就会将这两个参数传入，在createPatchFunction方法中接收了一个参数backend，在该方法中一开始进行backend的解构，就是上面的nodeOps和modules参数，解构完之后进入for循环。</p>
<p>在createPatchFunction开头定义了一个cbs对象。for循环遍历一个叫hooks的数组。hooks是文件一开头定义的一个数组，其中包括有create，for循环就是在cbs上定义一系列和hooks元素相同的属性，然后键值是一个数组，然后数组内容是modules里面的一些内容。这时就把events文件中导出来的create属性放在了cbs上。</p>
<p>当我们进入首次渲染的时候，会执行到patch函数里面的createElm方法，这个方法中就会调用invokeCreateHooks函数，用来处理事件系统，这里就是真正准备进行原生事件绑定的入口。invokeCreateHooks方法中，遍历了cbs.create数组里面的内容。然后把cbs.create里面的函数全部都执行一次，在cbs.create其中一个函数就是updateDOMListeners。</p>
<p>updateDOMListeners就是用来添加事件的方法，在这方法中会根据vnode判断是否有定义一个点击事件。如果没有点击事件就return。有的话就继续执行，给on进行赋值，然后进行一些赋值操作，将vnode.elm赋值给target，elm这个属性就是指向vnode所对应的真实dom节点，这里就是把我们要绑定事件的dom结点进行缓存，接下来执行updateListeners方法。在接下来执行updateListeners方法中调用了一个add的方法，然后在app方法中通过原生addEventListener把事件绑定到dom上。</p>
<p><strong>组件事件绑定原理</strong></p>
<p>在组件实例初始化会调用initMixin方法中的Vue.prototype._init，在init函数中，会通过initInternalComponent方法初始化组件信息，将自定义的组件事件放到_parentListeners上，下来就会调用initEvents来初始化组件事件，在initEvents中会实例上添加一个 _event对象，用于保存自定义事件，然后获取到 父组件给 子组件绑定的自定义事件，也就是刚才在初始化组件信息的时候将自定义的组件事件放在了_parentListeners上，这时候vm.$options._parentListeners就是自定义的事件。</p>
<p>最后进行判断，如果有自定义的组件事件就执行updateComponentListeners方法进行事件绑定，在updateComponentListeners方法中会调用updateListeners方法，并传传一个add方法进行执行，这个add方法里就是$on方法。</p>
</blockquote>
<h3 id="39-说一下-vue-模版编译的原理是什么"><a href="#39-说一下-vue-模版编译的原理是什么" class="headerlink" title="39. 说一下 vue 模版编译的原理是什么"></a>39. <strong>说一下 <em>vue</em> 模版编译的原理是什么</strong></h3><blockquote>
<p>参考答案：</p>
<p>简单说，<em>Vue</em> 的编译过程就是将 <em>template</em> 转化为 <em>render</em> 函数的过程。会经历以下阶段：</p>
<ul>
<li>生成 <em>AST</em> 树</li>
<li>优化</li>
<li><em>codegen</em></li>
</ul>
<p>首先解析模版，生成 <em>AST</em> 语法树(一种用 <em>JavaScript</em> 对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p>
<p><em>Vue</em> 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 <em>DOM</em> 也不会变化。那么优化过程就是深度遍历 <em>AST</em> 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p>
<p>编译的最后一步是将优化后的 <em>AST</em> 树转换为可执行的代码。</p>
</blockquote>
<blockquote>
<p>可以参阅前面第 <em>22</em> 题。</p>
</blockquote>
<h3 id="40-delete-和-Vue-delete-删除数组的区别是什么？"><a href="#40-delete-和-Vue-delete-删除数组的区别是什么？" class="headerlink" title="40. delete 和 Vue.delete 删除数组的区别是什么？"></a>40. <strong><em>delete</em> 和 <em>Vue.delete</em> 删除数组的区别是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>delete</em> 只是被删除的元素变成了 <em>empty&#x2F;undefined</em> 其他的元素的键值还是不变。<br><em>Vue.delete</em> 是直接将元素从数组中完全删除，改变了数组其他元素的键值。</p>
</blockquote>
<h3 id="41-v-on-可以实现监听多个方法么？"><a href="#41-v-on-可以实现监听多个方法么？" class="headerlink" title="41. v-on 可以实现监听多个方法么？"></a>41. <strong><em>v-on</em> 可以实现监听多个方法么？</strong></h3><blockquote>
<p>参考答案：</p>
<p>可以监听多个方法。关于监听多个方法提供了几种不同的写法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写法一：<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; 事件类型: 事件处理函数, 事件类型: 事件处理函数 &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">写法二：<span class="tag">&lt;<span class="name">div</span> @<span class="attr">事件类型</span>=<span class="string">“事件处理函数”</span> @<span class="attr">事件类型</span>=<span class="string">“事件处理函数”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">写法三：在一个事件里面书写多个事件处理函数</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">事件类型</span>=<span class="string">“事件处理函数1，事件处理函数2”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">写法四：在事件处理函数内部调用其他的函数</span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-on在vue2.x中测试,以下两种均可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; mouseenter: onEnter, mouseleave: onLeave &#125;&quot;</span>&gt;</span></span><br><span class="line">      鼠标进来1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseenter</span>=<span class="string">&quot;onEnter&quot;</span> @<span class="attr">mouseleave</span>=<span class="string">&quot;onLeave&quot;</span>&gt;</span>鼠标进来2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;a(), b()&quot;</span>&gt;</span>点我ab<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;one()&quot;</span>&gt;</span>点我onetwothree<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//这里是es6对象里函数写法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">a</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">b</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">one</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">two</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="title function_">three</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">two</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">three</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;three&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">onEnter</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mouse enter&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">onLeave</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mouse leave&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="42-vue-的数据为什么频繁变化但只会更新一次？"><a href="#42-vue-的数据为什么频繁变化但只会更新一次？" class="headerlink" title="42. vue 的数据为什么频繁变化但只会更新一次？"></a>42. <strong><em>vue</em> 的数据为什么频繁变化但只会更新一次？</strong></h3><blockquote>
<p>参考答案：</p>
<p>这是因为 <em>vue</em> 的 <em>DOM</em> 更新是一个异步操作，在数据更新后会首先被 <em>set</em> 钩子监听到，但是不会马上执行 <em>DOM</em> 更新，而是在下一轮循环中执行更新。</p>
<p>具体实现是 <em>vue</em> 中实现了一个 <em>queue</em> 队列用于存放本次事件循环中的所有 <em>watcher</em> 更新，并且同一个 <em>watcher</em> 的更新只会被推入队列一次，并在本轮事件循环的微任务执行结束后执行此更新(<em>UI Render</em> 阶段)，这就是 <em>DOM</em> 只会更新一次的原因。</p>
<p>这种在缓冲时去除重复数据对于避免不必要的计算和 <em>DOM</em> 操作是非常重要的。然后，在下一个的事件循环“<em>tick</em>”中，<em>vue</em> 刷新队列并执行实际 (已去重的) 工作。<em>vue</em> 在内部对异步队列尝试使用原生的 <em>Promise.then、MutationObserver</em>  和 <em>setImmediate</em>，如果执行环境不支持，则会采用 <em>setTimeout(fn, 0)</em> 代替。</p>
</blockquote>
<h3 id="43-说一下-vue-中-computed-和-methods-的区别是什么？"><a href="#43-说一下-vue-中-computed-和-methods-的区别是什么？" class="headerlink" title="43. 说一下 vue 中 computed 和 methods 的区别是什么？"></a>43. <strong>说一下 <em>vue</em> 中 <em>computed</em> 和 <em>methods</em> 的区别是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p>首先从表现形式上面来看， <em>computed</em> 和 <em>methods</em> 的区别大致有下面 <em>4</em> 点：</p>
<ol>
<li>在使用时，<em>computed</em> 当做属性使用，而 <em>methods</em> 则当做方法调用</li>
<li><em>computed</em> 可以具有 <em>getter</em> 和 <em>setter</em>，因此可以赋值，而 <em>methods</em> 不行</li>
<li><em>computed</em> 无法接收多个参数，而 <em>methods</em> 可以</li>
<li><em>computed</em> 具有缓存，而 <em>methods</em> 没有</li>
</ol>
<p>而如果从底层来看的话， <em>computed</em> 和 <em>methods</em> 在底层实现上面还有很大的区别。</p>
<p><em>vue</em> 对 <em>methods</em> 的处理比较简单，只需要遍历 <em>methods</em> 配置中的每个属性，将其对应的函数使用 <em>bind</em> 绑定当前组件实例后复制其引用到组件实例中即可</p>
<p>而 <em>vue</em> 对 <em>computed</em> 的处理会稍微复杂一些。</p>
<p>具体可以参阅前面第 <em>21</em> 题。</p>
</blockquote>
<h3 id="44-在-Vue-中要获取当前时间你会放到-computed-还是-methods-里？-抖音直播"><a href="#44-在-Vue-中要获取当前时间你会放到-computed-还是-methods-里？-抖音直播" class="headerlink" title="44. 在 Vue 中要获取当前时间你会放到 computed 还是 methods 里？(抖音直播)"></a>44. <strong>在 <em>Vue</em> 中要获取当前时间你会放到 <em>computed</em> 还是 <em>methods</em> 里？(抖音直播)</strong></h3><blockquote>
<p>参考答案：</p>
<p>放在 <em>computed</em> 里面。因为 <em>computed</em> 只有在它的相关依赖发生改变时才会重新求值。相比而言，方法只要发生重新渲染，<em>methods</em> 调用总会执行所有函数。 </p>
</blockquote>
<h3 id="45-在给-vue-中的元素设置-key-值时可以使用-Math-的-random-方法么？"><a href="#45-在给-vue-中的元素设置-key-值时可以使用-Math-的-random-方法么？" class="headerlink" title="45. 在给 vue 中的元素设置 key 值时可以使用 Math 的 random 方法么？"></a>45. <strong>在给 <em>vue</em> 中的元素设置 <em>key</em> 值时可以使用 <em>Math</em> 的 <em>random</em> 方法么？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>random</em> 是生成随机数，有一定概率多个 <em>item</em> 会生成相同的值，不能保证唯一。</p>
<p>如果是根据数据来生成 <em>item</em>，数据具有 <em>id</em> 属性，那么就可以使用 <em>id</em> 来作为 <em>key</em>。</p>
<p>如果不是根据数据生成 <em>item</em>，那么最好的方式就是使用时间戳来作为 <em>key</em>。或者使用诸如 <em>uuid</em> 之类的库来生成唯一的 <em>id</em>。</p>
</blockquote>
<h3 id="46-插槽与作用域插槽的区别是什么？"><a href="#46-插槽与作用域插槽的区别是什么？" class="headerlink" title="46. 插槽与作用域插槽的区别是什么？"></a>46. <strong>插槽与作用域插槽的区别是什么？</strong></h3><blockquote>
<p>参考答案：</p>
<p>插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。</p>
<p>作用域插槽给了子组件将数据返给父组件的能力，子组件一样可以复用，同时父组件也可以重新组织内容和样式。</p>
</blockquote>
<h3 id="47-vue-中相同逻辑如何进行抽离？"><a href="#47-vue-中相同逻辑如何进行抽离？" class="headerlink" title="47. vue 中相同逻辑如何进行抽离？"></a>47. <strong><em>vue</em> 中相同逻辑如何进行抽离？</strong></h3><blockquote>
<p>参考答案：</p>
<p>可以使用 <em>vue</em> 里面的混入（<em>mixin</em>）技术。混入（<em>mixin</em>）提供了一种非常灵活的方式，来将 <em>vue</em> 中相同的业务逻辑进行抽离。</p>
<p>例如：</p>
<ul>
<li>在 <em>data</em> 中有很多是公用数据</li>
<li>引用封装好的组件也都是一样的</li>
<li><em>methods、watch、computed</em> 中也都有大量的重复代码</li>
</ul>
<p>当然这个时候可以将所有的代码重复去写来实现功能，但是我们并不不推荐使用这种方式，无论是工作量、工作效率和后期维护来说都是不建议的，这个时候 <em>mixin</em> 就可以大展身手了。</p>
<p>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。</p>
<p><strong>混入技术特点</strong></p>
<ul>
<li>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li>
<li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li>
<li>值为对象的选项，例如 <em>methods、components</em> 和 <em>directives</em>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ul>
</blockquote>
<h3 id="48-如何监听-pushstate-和-replacestate-的变化呢？"><a href="#48-如何监听-pushstate-和-replacestate-的变化呢？" class="headerlink" title="48. 如何监听 pushstate 和 replacestate 的变化呢？"></a>48. <strong>如何监听 <em>pushstate</em> 和 <em>replacestate</em> 的变化呢？</strong></h3><blockquote>
<p>参考答案：</p>
<p><em>History.replaceState</em> 和 <em>pushState</em> 不会触发 <em>popstate</em> 事件，所以我们可以通过在方法中创建一个新的全局事件来实现  <em>pushstate</em> 和 <em>replacestate</em> 变化的监听。</p>
<p>具体做法为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> _wr = <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> orig = history[type];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> rv = orig.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">     <span class="keyword">var</span> e = <span class="keyword">new</span> <span class="title class_">Event</span>(type);</span><br><span class="line">      e.<span class="property">arguments</span> = <span class="variable language_">arguments</span>;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">dispatchEvent</span>(e);</span><br><span class="line">      <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;history.<span class="property">pushState</span> = <span class="title function_">_wr</span>(<span class="string">&#x27;pushState&#x27;</span>);</span><br><span class="line">&gt;history.<span class="property">replaceState</span> = <span class="title function_">_wr</span>(<span class="string">&#x27;replaceState&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就创建了 <em>2</em> 个全新的事件，事件名为 <em>pushState</em> 和 <em>replaceState</em>，我们就可以在全局监听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;replaceState&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;THEY DID IT AGAIN! replaceState 111111&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pushState&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;THEY DID IT AGAIN! pushState 2222222&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就可以监听到 <em>pushState</em> 和 <em>replaceState</em> 行为。</p>
</blockquote>
<h3 id="49-说一下-vue3-0-是如何变得更快的？"><a href="#49-说一下-vue3-0-是如何变得更快的？" class="headerlink" title="49. 说一下 vue3.0 是如何变得更快的？"></a>49. <strong>说一下 <em>vue3.0</em> 是如何变得更快的？</strong></h3><blockquote>
<p>参考答案：</p>
<p><strong>优化 <em>Diff</em> 算法</strong></p>
<p>相比 <em>Vue 2</em>，<em>Vue 3</em> 采用了更加优化的渲染策略。去掉不必要的虚拟 <em>DOM</em> 树遍历和属性比较，因为这在更新期间往往会产生最大的性能开销。</p>
<p>这里有三个主要的优化：</p>
<ul>
<li>首先，在 <em>DOM</em> 树级别。</li>
</ul>
<p> 在没有动态改变节点结构的模板指令（例如 <em>v-if</em> 和 <em>v-for</em>）的情况下，节点结构保持完全静态。</p>
<p> 当更新节点时，不再需要递归遍历 <em>DOM</em> 树。所有的动态绑定部分将在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟 <em>DOM</em> 的大部分开销。</p>
<ul>
<li><p>其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。</p>
</li>
<li><p>第三，在元素级别。</p>
</li>
</ul>
<p> 编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。</p>
<p> 例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。</p>
<p>综合起来，这些技术大大改进了渲染更新基准，<em>Vue 3.0</em> 有时占用的 <em>CPU</em> 时间不到 <em>Vue 2</em> 的十分之一。</p>
<p><strong>体积变小</strong></p>
<p>重写后的 <em>Vue</em> 支持了 <em>tree-shaking</em>，像修剪树叶一样把不需要的东西给修剪掉，使 <em>Vue 3.0</em> 的体积更小。</p>
<p>需要的模块才会打入到包里，优化后的 <em>Vue 3.0</em> 的打包体积只有原来的一半（<em>13kb</em>）。哪怕把所有的功能都引入进来也只有 <em>23kb</em>，依然比 <em>Vue 2.x</em> 更小。像 <em>keep-alive、transition</em> 甚至 <em>v-for</em> 等功能都可以按需引入。</p>
<p>并且 <em>Vue 3.0</em> 优化了打包方法，使得打包后的 <em>bundle</em> 的体积也更小。</p>
<p>官方所给出的一份惊艳的数据：打包大小减少 *41%*，初次渲染快 *55%*，更新快 *133%*，内存使用减少 *54%*。</p>
</blockquote>
<h3 id="50-说一说自定义指令有哪些生命周期？"><a href="#50-说一说自定义指令有哪些生命周期？" class="headerlink" title="50. 说一说自定义指令有哪些生命周期？"></a>50. 说一说自定义指令有哪些生命周期？</h3><blockquote>
<p>参考答案：</p>
<p>自定义指令的生命周期，有 5 个事件钩子，可以设置指令在某一个事件发生时的具体行为：</p>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<p>钩子函数的参数 (包括 el，binding，vnode，oldVnode)</p>
<ul>
<li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li>binding: 一个对象，包含以下属性：name: 指令名、value: 指令的绑定值、oldValue: 指令绑定的前一个值、expression: 绑定值的字符串形式、arg: 传给指令的参数、modifiers: 一个包含修饰符的对象。</li>
<li>vnode: Vue 编译生成的虚拟节点。</li>
<li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
</blockquote>
<h3 id="51-说一说相比-vue3-x-对比-vue2-x-变化"><a href="#51-说一说相比-vue3-x-对比-vue2-x-变化" class="headerlink" title="51. 说一说相比 vue3.x 对比 vue2.x 变化"></a>51. 说一说相比 <em>vue3.x</em> 对比 <em>vue2.x</em> 变化</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>源码组织方式变化：使用 TS 重写</li>
<li>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>
<li>响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>
<li>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li>
<li>打包体积优化：移除了一些不常用的api（inline-template、filter）</li>
<li>生命周期的变化：使用setup代替了之前的beforeCreate和created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li>
<li>Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance&#x2F; userRoute和userRouter方法获取当前组件实例</li>
<li>Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>
<li>父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>
</ol>
</blockquote>
<h3 id="52-vue-为什么采用异步渲染"><a href="#52-vue-为什么采用异步渲染" class="headerlink" title="52. vue 为什么采用异步渲染"></a>52. <em>vue</em> 为什么采用异步渲染</h3><blockquote>
<p>参考答案：</p>
<p>因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染；所以为了性能考虑，<em>Vue</em> 会在本轮数据更新后，再去异步更新视图。</p>
<p>异步渲染的原理：</p>
<ol>
<li>调用 <em>notify( )</em> 方法，通知 <em>watcher</em> 进行更新操作</li>
<li>依次调用 watcher 的 update 方法</li>
<li>对 watcher 进行去重操作（通过id）放到队列里</li>
<li>执行完后异步清空这个队列，nextTick（flushSchedulerQueue）进行批量更新操作</li>
</ol>
</blockquote>
<h3 id="53-组件中写-name-选项有哪些好处"><a href="#53-组件中写-name-选项有哪些好处" class="headerlink" title="53. 组件中写 name 选项有哪些好处"></a>53. 组件中写 <em>name</em> 选项有哪些好处</h3><blockquote>
<p>参考答案：</p>
<ol>
<li>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</li>
<li>可以通过 <em>name</em> 属性实现缓存功能（<em>keep-alive</em>）</li>
<li>可以通过 <em>name</em> 来识别组件（跨级组件通信时非常重要）</li>
<li>使用 <em>vue-devtools</em> 调试工具里显示的组见名称是由 <em>vue</em> 中组件 <em>name</em> 决定的</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/19/promise%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wangzhiwei">
      <meta itemprop="description" content="javascript nodejs web developer...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/19/promise%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">promise问题汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-19 09:19:44" itemprop="dateCreated datePublished" datetime="2024-12-19T09:19:44+08:00">2024-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-18 11:10:52" itemprop="dateModified" datetime="2025-03-18T11:10:52+08:00">2025-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Promise的问题基本都是代码题，不提供参考答案，否则容易干扰思考</p>
<p>若需知道正确答案，请自行运行</p>
</blockquote>
<ol>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="title function_">resolve</span>(); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">      <span class="title function_">resolve</span>(); </span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1) </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2) </span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">m</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">m</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="keyword">await</span> <span class="title function_">m1</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">m3</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="title function_">m2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">m3</span>().<span class="title function_">then</span>(<span class="function"><span class="params">n</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">m3</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)	</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">await</span> b;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after1&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> a</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面代码的输出结果是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wangzhiwei</p>
  <div class="site-description" itemprop="description">javascript nodejs web developer...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangzhiwei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
